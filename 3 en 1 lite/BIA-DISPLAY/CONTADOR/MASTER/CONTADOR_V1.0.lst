CCS PCH C Compiler, Version 5.025, 24934               17-may.-22 12:45

               Filename:   D:\PROYECTOS\TRANSPORTE\CONTADORES\3 en 1 lite\BIA-DISPLAY\CONTADOR\MASTER\CONTADOR_V1.0.lst

               ROM used:   12970 bytes (40%)
                           Largest free fragment is 19794
               RAM used:   465 (30%) at main() level
                           491 (32%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2AC2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0216
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   00EE
006C:  BTFSS  FA0.1
006E:  GOTO   0078
0072:  BTFSC  FA1.1
0074:  GOTO   01A4
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... #include <18F4580.h> 
.................... //////////// Standard Header file for the PIC18F4580 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4580 
00C6:  CLRF   FF7
00C8:  ADDLW  D6
00CA:  MOVWF  FF6
00CC:  MOVLW  00
00CE:  ADDWFC FF7,F
00D0:  TBLRD*+
00D2:  MOVF   FF5,W
00D4:  RETURN 0
00D6:  DATA 28,0C
00D8:  DATA 01,06
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 3A,2F
00EC:  DATA 00,00
*
0270:  DATA 42,4F
0272:  DATA 52,52
0274:  DATA 41,52
0276:  DATA 5F,41
0278:  DATA 4C,4C
027A:  DATA 0D,00
027C:  DATA 0C,42
027E:  DATA 4F,52
0280:  DATA 52,41
0282:  DATA 52,5F
0284:  DATA 41,4C
0286:  DATA 4C,00
0288:  DATA 42,4F
028A:  DATA 52,52
028C:  DATA 41,52
028E:  DATA 5F,41
0290:  DATA 4C,4C
0292:  DATA 0D,00
0294:  DATA 52,45
0296:  DATA 53,45
0298:  DATA 54,5F
029A:  DATA 4F,4B
029C:  DATA 0D,0A
029E:  DATA 00,00
02A0:  DATA 52,45
02A2:  DATA 53,45
02A4:  DATA 54,5F
02A6:  DATA 4F,4B
02A8:  DATA 0D,0A
02AA:  DATA 00,00
02AC:  DATA 42,4F
02AE:  DATA 52,52
02B0:  DATA 41,52
02B2:  DATA 5F,41
02B4:  DATA 4C,4C
02B6:  DATA 0D,00
02B8:  DATA 43,32
02BA:  DATA 4F,4B
02BC:  DATA 00,00
02BE:  DATA 43,31
02C0:  DATA 4F,4B
02C2:  DATA 00,00
02C4:  DATA 53,45
02C6:  DATA 52,49
02C8:  DATA 41,4C
02CA:  DATA 5F,54
02CC:  DATA 4F,4B
02CE:  DATA 0D,00
02D0:  DATA 43,32
02D2:  DATA 4F,4B
02D4:  DATA 00,00
02D6:  DATA 53,75
02D8:  DATA 62,32
02DA:  DATA 00,00
02DC:  DATA 63,3D
02DE:  DATA 30,00
02E0:  DATA 20,20
02E2:  DATA 20,20
02E4:  DATA 00,00
02E6:  DATA 20,20
02E8:  DATA 20,20
02EA:  DATA 00,00
02EC:  DATA 20,20
02EE:  DATA 20,20
02F0:  DATA 00,00
02F2:  DATA 42,4C
02F4:  DATA 00,00
02F6:  DATA 42,4C
02F8:  DATA 00,00
02FA:  DATA 42,4C
02FC:  DATA 00,00
02FE:  DATA 20,20
0300:  DATA 00,00
0302:  DATA 53,4F
0304:  DATA 4C,49
0306:  DATA 43,49
0308:  DATA 54,41
030A:  DATA 44,4F
030C:  DATA 0D,00
030E:  DATA 50,41
0310:  DATA 53,41
0312:  DATA 4A,45
0314:  DATA 52,4F
0316:  DATA 53,3A
0318:  DATA 0D,00
031A:  DATA 53,32
031C:  DATA 3A,25
031E:  DATA 4C,64
0320:  DATA 20,00
0322:  DATA 42,32
0324:  DATA 3A,25
0326:  DATA 4C,64
0328:  DATA 20,00
032A:  DATA 41,43
032C:  DATA 43,2B
032E:  DATA 30,31
0330:  DATA 3A,25
0332:  DATA 30,34
0334:  DATA 4C,75
0336:  DATA 2C,25
0338:  DATA 30,34
033A:  DATA 4C,75
033C:  DATA 2C,25
033E:  DATA 30,34
0340:  DATA 4C,75
0342:  DATA 2C,25
0344:  DATA 30,33
0346:  DATA 4C,75
0348:  DATA 2C,25
034A:  DATA 30,33
034C:  DATA 4C,75
034E:  DATA 2C,25
0350:  DATA 30,32
0352:  DATA 75,2C
0354:  DATA 0D,0A
0356:  DATA 00,00
0358:  DATA 41,43
035A:  DATA 43,2B
035C:  DATA 30,31
035E:  DATA 3A,25
0360:  DATA 30,34
0362:  DATA 4C,75
0364:  DATA 2C,25
0366:  DATA 30,34
0368:  DATA 4C,75
036A:  DATA 2C,44
036C:  DATA 45,53
036E:  DATA 43,2C
0370:  DATA 25,30
0372:  DATA 33,4C
0374:  DATA 75,2C
0376:  DATA 30,30
0378:  DATA 30,2C
037A:  DATA 25,30
037C:  DATA 32,75
037E:  DATA 2C,0D
0380:  DATA 0A,00
0382:  DATA 44,45
0384:  DATA 53,43
0386:  DATA 00,00
0388:  DATA 0C,00
038A:  DATA 20,00
038C:  DATA 20,00
038E:  DATA 20,00
0390:  DATA 20,00
0392:  DATA 20,00
0394:  DATA 20,00
0396:  DATA 20,00
0398:  DATA 20,00
039A:  DATA 20,00
039C:  DATA 20,00
039E:  DATA 20,00
03A0:  DATA 20,00
03A2:  DATA 6D,65
03A4:  DATA 6D,6F
03A6:  DATA 72,79
03A8:  DATA 3A,25
03AA:  DATA 73,0D
03AC:  DATA 00,00
03AE:  DATA 53,31
03B0:  DATA 3A,25
03B2:  DATA 4C,64
03B4:  DATA 20,00
03B6:  DATA 42,31
03B8:  DATA 3A,25
03BA:  DATA 4C,64
03BC:  DATA 20,00
03BE:  DATA 53,32
03C0:  DATA 3A,25
03C2:  DATA 4C,64
03C4:  DATA 20,00
03C6:  DATA 42,32
03C8:  DATA 3A,25
03CA:  DATA 4C,64
03CC:  DATA 20,00
03CE:  DATA 53,31
03D0:  DATA 3A,20
03D2:  DATA 20,20
03D4:  DATA 20,00
03D6:  DATA 42,31
03D8:  DATA 3A,20
03DA:  DATA 20,20
03DC:  DATA 20,00
03DE:  DATA 53,32
03E0:  DATA 3A,25
03E2:  DATA 4C,64
03E4:  DATA 20,00
03E6:  DATA 42,32
03E8:  DATA 3A,25
03EA:  DATA 4C,64
03EC:  DATA 20,00
03EE:  DATA 53,45
03F0:  DATA 52,49
03F2:  DATA 41,4C
03F4:  DATA 54,45
03F6:  DATA 53,54
03F8:  DATA 0D,0A
03FA:  DATA 00,00
03FC:  DATA 53,55
03FE:  DATA 42,49
0400:  DATA 45,4E
0402:  DATA 44,4F
0404:  DATA 43,32
0406:  DATA 00,00
*
091E:  TBLRD*+
0920:  MOVFF  FF6,1D3
0924:  MOVFF  FF7,1D4
0928:  MOVFF  FF5,1DB
092C:  RCALL  08BE
092E:  MOVFF  1D3,FF6
0932:  MOVFF  1D4,FF7
0936:  MOVLB  1
0938:  DECFSZ xD2,F
093A:  BRA    093E
093C:  BRA    0942
093E:  MOVLB  0
0940:  BRA    091E
0942:  MOVLB  0
0944:  RETURN 0
0946:  MOVFF  FEA,1DA
094A:  MOVFF  FE9,1D9
094E:  MOVLB  1
0950:  BTFSS  xD3.7
0952:  BRA    0964
0954:  BSF    xD9.7
0956:  BTFSS  xD9.4
0958:  INCF   xD9,F
095A:  COMF   xD2,F
095C:  COMF   xD3,F
095E:  INCF   xD2,F
0960:  BTFSC  FD8.2
0962:  INCF   xD3,F
0964:  SWAPF  xD3,W
0966:  IORLW  F0
0968:  MOVWF  xD5
096A:  ADDWF  xD5,F
096C:  ADDLW  E2
096E:  MOVWF  xD6
0970:  ADDLW  32
0972:  MOVWF  xD8
0974:  MOVF   xD3,W
0976:  ANDLW  0F
0978:  ADDWF  xD6,F
097A:  ADDWF  xD6,F
097C:  ADDWF  xD8,F
097E:  ADDLW  E9
0980:  MOVWF  xD7
0982:  ADDWF  xD7,F
0984:  ADDWF  xD7,F
0986:  SWAPF  xD2,W
0988:  ANDLW  0F
098A:  ADDWF  xD7,F
098C:  ADDWF  xD8,F
098E:  RLCF   xD7,F
0990:  RLCF   xD8,F
0992:  COMF   xD8,F
0994:  RLCF   xD8,F
0996:  MOVF   xD2,W
0998:  ANDLW  0F
099A:  ADDWF  xD8,F
099C:  RLCF   xD5,F
099E:  MOVLW  07
09A0:  MOVWF  xD4
09A2:  MOVLW  0A
09A4:  DECF   xD7,F
09A6:  ADDWF  xD8,F
09A8:  BNC   09A4
09AA:  DECF   xD6,F
09AC:  ADDWF  xD7,F
09AE:  BNC   09AA
09B0:  DECF   xD5,F
09B2:  ADDWF  xD6,F
09B4:  BNC   09B0
09B6:  DECF   xD4,F
09B8:  ADDWF  xD5,F
09BA:  BNC   09B6
09BC:  MOVLW  01
09BE:  MOVWF  FEA
09C0:  MOVLW  D4
09C2:  MOVWF  FE9
09C4:  MOVLW  07
09C6:  ANDWF  xD9,W
09C8:  BCF    xD9.6
09CA:  MOVF   FED,F
09CC:  ANDWF  xD9,W
09CE:  BNZ   09DE
09D0:  BTFSC  xD9.4
09D2:  MOVF   FEE,F
09D4:  BTFSC  xD9.4
09D6:  BRA    09DE
09D8:  MOVLW  20
09DA:  MOVWF  00
09DC:  BRA    0A1E
09DE:  ADDWF  FE9,F
09E0:  MOVLW  00
09E2:  ADDWFC FEA,F
09E4:  MOVF   FE9,W
09E6:  SUBLW  D8
09E8:  BNZ   09F0
09EA:  DECFSZ FEA,W
09EC:  BRA    09F0
09EE:  BSF    xD9.6
09F0:  MOVF   FEF,W
09F2:  MOVWF  00
09F4:  BNZ   0A06
09F6:  BTFSC  xD9.6
09F8:  BRA    0A06
09FA:  BTFSC  xD9.4
09FC:  BRA    0A38
09FE:  BTFSC  xD9.3
0A00:  BRA    0A06
0A02:  MOVLW  20
0A04:  BRA    0A1C
0A06:  BTFSS  xD9.7
0A08:  BRA    0A16
0A0A:  MOVLW  2D
0A0C:  MOVWF  00
0A0E:  MOVF   FED,W
0A10:  BCF    xD9.6
0A12:  BCF    xD9.7
0A14:  BRA    0A1E
0A16:  BSF    xD9.3
0A18:  BCF    xD9.4
0A1A:  MOVLW  30
0A1C:  ADDWF  00,F
0A1E:  MOVFF  FEA,1D3
0A22:  MOVFF  FE9,1D2
0A26:  MOVFF  00,1DB
0A2A:  MOVLB  0
0A2C:  RCALL  08BE
0A2E:  MOVFF  1D3,FEA
0A32:  MOVFF  1D2,FE9
0A36:  MOVLB  1
0A38:  MOVF   FEE,W
0A3A:  BTFSS  xD9.6
0A3C:  BRA    09E4
0A3E:  MOVLB  0
0A40:  RETURN 0
0A42:  TBLRD*+
0A44:  MOVF   FF5,F
0A46:  BZ    0A60
0A48:  MOVFF  FF6,1D1
0A4C:  MOVFF  FF7,1D2
0A50:  MOVFF  FF5,1DB
0A54:  RCALL  08BE
0A56:  MOVFF  1D1,FF6
0A5A:  MOVFF  1D2,FF7
0A5E:  BRA    0A42
0A60:  RETURN 0
*
0E3A:  TBLRD*+
0E3C:  MOVF   FF5,F
0E3E:  BZ    0E5A
0E40:  MOVFF  FF6,1D3
0E44:  MOVFF  FF7,1D4
0E48:  MOVF   FF5,W
0E4A:  BTFSS  F9E.4
0E4C:  BRA    0E4A
0E4E:  MOVWF  FAD
0E50:  MOVFF  1D3,FF6
0E54:  MOVFF  1D4,FF7
0E58:  BRA    0E3A
0E5A:  RETURN 0
*
0F9C:  MOVLB  1
0F9E:  MOVF   xD8,W
0FA0:  CLRF   01
0FA2:  SUBWF  xD7,W
0FA4:  BC    0FAC
0FA6:  MOVFF  1D7,00
0FAA:  BRA    0FC4
0FAC:  CLRF   00
0FAE:  MOVLW  08
0FB0:  MOVWF  xD9
0FB2:  RLCF   xD7,F
0FB4:  RLCF   00,F
0FB6:  MOVF   xD8,W
0FB8:  SUBWF  00,W
0FBA:  BTFSC  FD8.0
0FBC:  MOVWF  00
0FBE:  RLCF   01,F
0FC0:  DECFSZ xD9,F
0FC2:  BRA    0FB2
0FC4:  MOVLB  0
0FC6:  RETURN 0
0FC8:  MOVLW  20
0FCA:  MOVLB  1
0FCC:  BTFSS  xD2.4
0FCE:  MOVLW  30
0FD0:  MOVWF  xD3
0FD2:  MOVFF  1D1,00
0FD6:  BTFSS  xD1.7
0FD8:  BRA    0FEA
0FDA:  COMF   00,F
0FDC:  INCF   00,F
0FDE:  MOVFF  00,1D1
0FE2:  MOVLW  2D
0FE4:  MOVWF  xD3
0FE6:  BSF    xD2.7
0FE8:  BSF    xD2.0
0FEA:  MOVF   01,W
0FEC:  MOVFF  1D1,1D7
0FF0:  MOVLW  64
0FF2:  MOVWF  xD8
0FF4:  MOVLB  0
0FF6:  RCALL  0F9C
0FF8:  MOVFF  00,1D1
0FFC:  MOVLW  30
0FFE:  ADDWF  01,W
1000:  MOVLB  1
1002:  MOVWF  xD4
1004:  MOVFF  1D1,1D7
1008:  MOVLW  0A
100A:  MOVWF  xD8
100C:  MOVLB  0
100E:  RCALL  0F9C
1010:  MOVLW  30
1012:  ADDWF  00,W
1014:  MOVLB  1
1016:  MOVWF  xD6
1018:  MOVLW  30
101A:  ADDWF  01,W
101C:  MOVWF  xD5
101E:  MOVFF  1D3,00
1022:  MOVLW  30
1024:  SUBWF  xD4,W
1026:  BZ    1030
1028:  BSF    xD2.1
102A:  BTFSC  xD2.7
102C:  BSF    xD2.2
102E:  BRA    1054
1030:  MOVFF  1D3,1D4
1034:  MOVLW  20
1036:  MOVWF  xD3
1038:  MOVLW  30
103A:  SUBWF  xD5,W
103C:  BZ    1046
103E:  BSF    xD2.0
1040:  BTFSC  xD2.7
1042:  BSF    xD2.1
1044:  BRA    1054
1046:  BTFSS  FD8.2
1048:  BSF    xD2.0
104A:  BNZ   1054
104C:  MOVFF  1D4,1D5
1050:  MOVLW  20
1052:  MOVWF  xD4
1054:  BTFSC  xD2.2
1056:  BRA    1062
1058:  BTFSC  xD2.1
105A:  BRA    106A
105C:  BTFSC  xD2.0
105E:  BRA    1072
1060:  BRA    107A
1062:  MOVFF  1D3,1DB
1066:  MOVLB  0
1068:  RCALL  08BE
106A:  MOVFF  1D4,1DB
106E:  MOVLB  0
1070:  RCALL  08BE
1072:  MOVFF  1D5,1DB
1076:  MOVLB  0
1078:  RCALL  08BE
107A:  MOVFF  1D6,1DB
107E:  MOVLB  0
1080:  RCALL  08BE
1082:  RETURN 0
*
10D2:  TBLRD*+
10D4:  MOVF   FF5,F
10D6:  BZ    10F0
10D8:  MOVFF  FF6,1D1
10DC:  MOVFF  FF7,1D2
10E0:  MOVFF  FF5,1DA
10E4:  RCALL  1084
10E6:  MOVFF  1D1,FF6
10EA:  MOVFF  1D2,FF7
10EE:  BRA    10D2
10F0:  RETURN 0
*
1160:  TSTFSZ 01
1162:  BRA    116A
1164:  TSTFSZ 02
1166:  BRA    116C
1168:  BRA    1178
116A:  INCF   02,F
116C:  MOVFF  00,FEE
1170:  DECFSZ 01,F
1172:  BRA    116C
1174:  DECFSZ 02,F
1176:  BRA    116C
1178:  RETURN 0
*
1848:  TBLRD*+
184A:  MOVFF  FF6,1D2
184E:  MOVFF  FF7,1D3
1852:  MOVFF  FF5,1DA
1856:  RCALL  1084
1858:  MOVFF  1D2,FF6
185C:  MOVFF  1D3,FF7
1860:  MOVLB  1
1862:  DECFSZ xD1,F
1864:  BRA    1868
1866:  BRA    186C
1868:  MOVLB  0
186A:  BRA    1848
186C:  MOVLB  0
186E:  RETURN 0
1870:  MOVFF  FEA,1D9
1874:  MOVFF  FE9,1D8
1878:  MOVLB  1
187A:  SWAPF  xD2,W
187C:  IORLW  F0
187E:  MOVWF  xD4
1880:  ADDWF  xD4,F
1882:  ADDLW  E2
1884:  MOVWF  xD5
1886:  ADDLW  32
1888:  MOVWF  xD7
188A:  MOVF   xD2,W
188C:  ANDLW  0F
188E:  ADDWF  xD5,F
1890:  ADDWF  xD5,F
1892:  ADDWF  xD7,F
1894:  ADDLW  E9
1896:  MOVWF  xD6
1898:  ADDWF  xD6,F
189A:  ADDWF  xD6,F
189C:  SWAPF  xD1,W
189E:  ANDLW  0F
18A0:  ADDWF  xD6,F
18A2:  ADDWF  xD7,F
18A4:  RLCF   xD6,F
18A6:  RLCF   xD7,F
18A8:  COMF   xD7,F
18AA:  RLCF   xD7,F
18AC:  MOVF   xD1,W
18AE:  ANDLW  0F
18B0:  ADDWF  xD7,F
18B2:  RLCF   xD4,F
18B4:  MOVLW  07
18B6:  MOVWF  xD3
18B8:  MOVLW  0A
18BA:  DECF   xD6,F
18BC:  ADDWF  xD7,F
18BE:  BNC   18BA
18C0:  DECF   xD5,F
18C2:  ADDWF  xD6,F
18C4:  BNC   18C0
18C6:  DECF   xD4,F
18C8:  ADDWF  xD5,F
18CA:  BNC   18C6
18CC:  DECF   xD3,F
18CE:  ADDWF  xD4,F
18D0:  BNC   18CC
18D2:  MOVLW  01
18D4:  MOVWF  FEA
18D6:  MOVLW  D3
18D8:  MOVWF  FE9
18DA:  MOVLW  07
18DC:  ANDWF  xD8,W
18DE:  BCF    xD8.6
18E0:  ADDWF  FE9,F
18E2:  MOVLW  00
18E4:  ADDWFC FEA,F
18E6:  MOVF   FE9,W
18E8:  SUBLW  D7
18EA:  BNZ   18F2
18EC:  DECFSZ FEA,W
18EE:  BRA    18F2
18F0:  BSF    xD8.6
18F2:  MOVF   FEF,W
18F4:  MOVWF  00
18F6:  BNZ   1908
18F8:  BTFSC  xD8.6
18FA:  BRA    1908
18FC:  BTFSC  xD8.4
18FE:  BRA    192C
1900:  BTFSC  xD8.3
1902:  BRA    1908
1904:  MOVLW  20
1906:  BRA    190E
1908:  BSF    xD8.3
190A:  BCF    xD8.4
190C:  MOVLW  30
190E:  ADDWF  00,F
1910:  MOVFF  FEA,1D2
1914:  MOVFF  FE9,1D1
1918:  MOVFF  00,1DA
191C:  MOVLB  0
191E:  CALL   1084
1922:  MOVFF  1D2,FEA
1926:  MOVFF  1D1,FE9
192A:  MOVLB  1
192C:  MOVF   FEE,W
192E:  BTFSS  xD8.6
1930:  BRA    18E6
1932:  MOVLB  0
1934:  RETURN 0
1936:  MOVF   01,W
1938:  MOVFF  1D1,1D7
193C:  MOVLW  64
193E:  MOVLB  1
1940:  MOVWF  xD8
1942:  MOVLB  0
1944:  CALL   0F9C
1948:  MOVFF  00,1D1
194C:  MOVF   01,W
194E:  MOVLW  30
1950:  BNZ   1962
1952:  MOVLB  1
1954:  BTFSS  xD2.1
1956:  BRA    1978
1958:  BTFSC  xD2.3
195A:  BRA    1978
195C:  BTFSC  xD2.4
195E:  MOVLW  20
1960:  BRA    196A
1962:  MOVLB  1
1964:  BCF    xD2.3
1966:  BCF    xD2.4
1968:  BSF    xD2.0
196A:  ADDWF  01,F
196C:  MOVFF  01,1DA
1970:  MOVLB  0
1972:  CALL   1084
1976:  MOVLB  1
1978:  MOVFF  1D1,1D7
197C:  MOVLW  0A
197E:  MOVWF  xD8
1980:  MOVLB  0
1982:  CALL   0F9C
1986:  MOVFF  00,1D1
198A:  MOVF   01,W
198C:  MOVLW  30
198E:  BNZ   19A0
1990:  MOVLB  1
1992:  BTFSC  xD2.3
1994:  BRA    19AC
1996:  BTFSS  xD2.0
1998:  BRA    19AC
199A:  BTFSC  xD2.4
199C:  MOVLW  20
199E:  MOVLB  0
19A0:  ADDWF  01,F
19A2:  MOVFF  01,1DA
19A6:  CALL   1084
19AA:  MOVLB  1
19AC:  MOVLW  30
19AE:  ADDWF  xD1,F
19B0:  MOVFF  1D1,1DA
19B4:  MOVLB  0
19B6:  CALL   1084
19BA:  RETURN 0
*
211A:  ADDWF  FE8,W
211C:  CLRF   FF7
211E:  RLCF   FF7,F
2120:  ADDLW  35
2122:  MOVWF  FF6
2124:  MOVLW  21
2126:  ADDWFC FF7,F
2128:  TBLRD*-
212A:  MOVF   FF5,W
212C:  MOVWF  FFA
212E:  TBLRD*
2130:  MOVF   FF5,W
2132:  MOVWF  FF9
2134:  DATA EA,20
2136:  DATA 14,21
2138:  DATA 14,21
213A:  DATA 14,21
213C:  DATA EC,20
213E:  DATA FC,20
2140:  DATA 00,21
2142:  DATA 14,21
2144:  DATA 14,21
2146:  DATA 14,21
2148:  DATA 02,21
214A:  DATA 12,21
*
2422:  ADDWF  FE8,W
2424:  CLRF   FF7
2426:  RLCF   FF7,F
2428:  ADDLW  3D
242A:  MOVWF  FF6
242C:  MOVLW  24
242E:  ADDWFC FF7,F
2430:  TBLRD*-
2432:  MOVF   FF5,W
2434:  MOVWF  FFA
2436:  TBLRD*
2438:  MOVF   FF5,W
243A:  MOVWF  FF9
243C:  DATA F2,23
243E:  DATA 1C,24
2440:  DATA 1C,24
2442:  DATA 1C,24
2444:  DATA F4,23
2446:  DATA 04,24
2448:  DATA 08,24
244A:  DATA 1C,24
244C:  DATA 1C,24
244E:  DATA 1C,24
2450:  DATA 0A,24
2452:  DATA 1A,24
*
272C:  ADDWF  FE8,W
272E:  CLRF   FF7
2730:  RLCF   FF7,F
2732:  ADDLW  47
2734:  MOVWF  FF6
2736:  MOVLW  27
2738:  ADDWFC FF7,F
273A:  TBLRD*-
273C:  MOVF   FF5,W
273E:  MOVWF  FFA
2740:  TBLRD*
2742:  MOVF   FF5,W
2744:  MOVWF  FF9
2746:  DATA FC,26
2748:  DATA 26,27
274A:  DATA 26,27
274C:  DATA 26,27
274E:  DATA FE,26
2750:  DATA 0E,27
2752:  DATA 12,27
2754:  DATA 26,27
2756:  DATA 26,27
2758:  DATA 26,27
275A:  DATA 14,27
275C:  DATA 24,27
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0E94:  MOVLB  1
0E96:  MOVFF  1D7,FE9
0E9A:  MOVFF  1D8,FEA
0E9E:  MOVFF  FEF,1DB
0EA2:  MOVFF  1DA,03
0EA6:  MOVFF  1D9,FE9
0EAA:  MOVFF  1DA,FEA
0EAE:  MOVF   FEF,W
0EB0:  SUBWF  xDB,W
0EB2:  BNZ   0EDE
....................       if (*s1 == '\0') 
0EB4:  MOVFF  1D8,03
0EB8:  MOVFF  1D7,FE9
0EBC:  MOVFF  03,FEA
0EC0:  MOVF   FEF,F
0EC2:  BNZ   0ECA
....................          return(0); 
0EC4:  MOVLW  00
0EC6:  MOVWF  01
0EC8:  BRA    0F08
0ECA:  MOVFF  1D8,03
0ECE:  MOVF   xD7,W
0ED0:  INCF   xD7,F
0ED2:  BTFSC  FD8.2
0ED4:  INCF   xD8,F
0ED6:  INCF   xD9,F
0ED8:  BTFSC  FD8.2
0EDA:  INCF   xDA,F
0EDC:  BRA    0E96
....................    return((*s1 < *s2) ? -1: 1); 
0EDE:  MOVFF  1D8,03
0EE2:  MOVFF  1D7,FE9
0EE6:  MOVFF  1D8,FEA
0EEA:  MOVFF  FEF,1DB
0EEE:  MOVFF  1DA,03
0EF2:  MOVFF  1D9,FE9
0EF6:  MOVFF  1DA,FEA
0EFA:  MOVF   FEF,W
0EFC:  SUBWF  xDB,W
0EFE:  BC    0F04
0F00:  MOVLW  FF
0F02:  BRA    0F06
0F04:  MOVLW  01
0F06:  MOVWF  01
0F08:  MOVLB  0
0F0A:  GOTO   0F4E (RETURN)
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
120A:  MOVFF  1DB,1DF
120E:  MOVFF  1DA,1DE
1212:  MOVFF  1DF,03
1216:  MOVLB  1
1218:  MOVFF  1DE,FE9
121C:  MOVFF  1DF,FEA
1220:  MOVF   FEF,F
1222:  BZ    1278
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
1224:  MOVFF  1DD,1E1
1228:  MOVFF  1DC,1E0
122C:  MOVFF  1E1,03
1230:  MOVFF  1E0,FE9
1234:  MOVFF  1E1,FEA
1238:  MOVF   FEF,F
123A:  BZ    126C
....................          if (*sc1 == *sc2) 
123C:  MOVFF  1DE,FE9
1240:  MOVFF  1DF,FEA
1244:  MOVFF  FEF,1E2
1248:  MOVFF  1E1,03
124C:  MOVFF  1E0,FE9
1250:  MOVFF  1E1,FEA
1254:  MOVF   FEF,W
1256:  SUBWF  xE2,W
1258:  BNZ   1264
....................             return(sc1); 
125A:  MOVFF  1DE,01
125E:  MOVFF  1DF,02
1262:  BRA    127E
1264:  INCF   xE0,F
1266:  BTFSC  FD8.2
1268:  INCF   xE1,F
126A:  BRA    122C
126C:  INCF   xDE,F
126E:  BTFSC  FD8.2
1270:  INCF   xDF,F
1272:  MOVLB  0
1274:  BRA    1212
1276:  MOVLB  1
....................    return(0); 
1278:  MOVLW  00
127A:  MOVWF  01
127C:  MOVWF  02
127E:  MOVLB  0
1280:  GOTO   12F6 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
117A:  MOVFF  1DB,1DF
117E:  MOVFF  1DA,1DE
1182:  MOVFF  1DF,03
1186:  MOVLB  1
1188:  MOVFF  1DE,FE9
118C:  MOVFF  1DF,FEA
1190:  MOVF   FEF,F
1192:  BZ    11F4
....................       for (sc2 = s2; ; sc2++) 
1194:  MOVFF  1DD,1E1
1198:  MOVFF  1DC,1E0
....................     if (*sc2 == '\0') 
119C:  MOVFF  1E1,03
11A0:  MOVFF  1E0,FE9
11A4:  MOVFF  1E1,FEA
11A8:  MOVF   FEF,F
11AA:  BNZ   11C0
....................        return(sc1 - s1); 
11AC:  MOVF   xDA,W
11AE:  SUBWF  xDE,W
11B0:  MOVWF  00
11B2:  MOVF   xDB,W
11B4:  SUBWFB xDF,W
11B6:  MOVWF  03
11B8:  MOVFF  00,01
11BC:  BRA    1204
11BE:  BRA    11E0
....................          else if (*sc1 == *sc2) 
11C0:  MOVFF  1DE,FE9
11C4:  MOVFF  1DF,FEA
11C8:  MOVFF  FEF,1E2
11CC:  MOVFF  1E1,03
11D0:  MOVFF  1E0,FE9
11D4:  MOVFF  1E1,FEA
11D8:  MOVF   FEF,W
11DA:  SUBWF  xE2,W
11DC:  BNZ   11E0
....................             break; 
11DE:  BRA    11E8
11E0:  INCF   xE0,F
11E2:  BTFSC  FD8.2
11E4:  INCF   xE1,F
11E6:  BRA    119C
11E8:  INCF   xDE,F
11EA:  BTFSC  FD8.2
11EC:  INCF   xDF,F
11EE:  MOVLB  0
11F0:  BRA    1182
11F2:  MOVLB  1
....................    return(sc1 - s1); 
11F4:  MOVF   xDA,W
11F6:  SUBWF  xDE,W
11F8:  MOVWF  00
11FA:  MOVF   xDB,W
11FC:  SUBWFB xDF,W
11FE:  MOVWF  03
1200:  MOVFF  00,01
1204:  MOVLB  0
1206:  GOTO   12B4 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
1284:  MOVLB  1
1286:  MOVF   xD2,W
1288:  IORWF  xD3,W
128A:  BZ    1294
128C:  MOVFF  1D3,03
1290:  MOVF   xD2,W
1292:  BRA    129A
1294:  MOVFF  1A,03
1298:  MOVF   19,W
129A:  MOVWF  xD6
129C:  MOVFF  03,1D7
....................    beg += strspn(beg, s2); 
12A0:  MOVFF  1D7,1DB
12A4:  MOVFF  1D6,1DA
12A8:  MOVFF  1D5,1DD
12AC:  MOVFF  1D4,1DC
12B0:  MOVLB  0
12B2:  BRA    117A
12B4:  MOVF   01,W
12B6:  MOVLB  1
12B8:  ADDWF  xD6,F
12BA:  MOVLW  00
12BC:  ADDWFC xD7,F
....................    if (*beg == '\0') 
12BE:  MOVFF  1D7,03
12C2:  MOVFF  1D6,FE9
12C6:  MOVFF  1D7,FEA
12CA:  MOVF   FEF,F
12CC:  BNZ   12E2
....................    { 
....................       *save = ' '; 
12CE:  MOVFF  19,FE9
12D2:  MOVFF  1A,FEA
12D6:  MOVLW  20
12D8:  MOVWF  FEF
....................       return(0); 
12DA:  MOVLW  00
12DC:  MOVWF  01
12DE:  MOVWF  02
12E0:  BRA    1330
....................    } 
....................    end = strpbrk(beg, s2); 
12E2:  MOVFF  1D7,1DB
12E6:  MOVFF  1D6,1DA
12EA:  MOVFF  1D5,1DD
12EE:  MOVFF  1D4,1DC
12F2:  MOVLB  0
12F4:  BRA    120A
12F6:  MOVFF  02,1D9
12FA:  MOVFF  01,1D8
....................    if (*end != '\0') 
12FE:  MOVFF  1D9,03
1302:  MOVLB  1
1304:  MOVFF  1D8,FE9
1308:  MOVFF  1D9,FEA
130C:  MOVF   FEF,F
130E:  BZ    1320
....................    { 
....................       *end = '\0'; 
1310:  MOVFF  1D8,FE9
1314:  MOVFF  1D9,FEA
1318:  CLRF   FEF
....................       end++; 
131A:  INCF   xD8,F
131C:  BTFSC  FD8.2
131E:  INCF   xD9,F
....................    } 
....................    save = end; 
1320:  MOVFF  1D9,1A
1324:  MOVFF  1D8,19
....................    return(beg); 
1328:  MOVFF  1D6,01
132C:  MOVFF  1D7,02
1330:  MOVLB  0
1332:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
1334:  MOVLB  1
1336:  CLRF   xDA
....................    sign = 0; 
1338:  CLRF   xD8
....................    base = 10; 
133A:  MOVLW  0A
133C:  MOVWF  xD9
....................    result = 0; 
133E:  CLRF   xD7
1340:  CLRF   xD6
1342:  CLRF   xD5
1344:  CLRF   xD4
....................  
....................    if (!s) 
1346:  MOVF   xD2,W
1348:  IORWF  xD3,W
134A:  BNZ   1356
....................       return 0; 
134C:  CLRF   00
134E:  CLRF   01
1350:  CLRF   02
1352:  CLRF   03
1354:  BRA    15C4
....................    c = s[index++]; 
1356:  MOVF   xDA,W
1358:  INCF   xDA,F
135A:  ADDWF  xD2,W
135C:  MOVWF  FE9
135E:  MOVLW  00
1360:  ADDWFC xD3,W
1362:  MOVWF  FEA
1364:  MOVFF  FEF,1DB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1368:  MOVF   xDB,W
136A:  SUBLW  2D
136C:  BNZ   1386
....................    { 
....................       sign = 1;         // Set the sign to negative 
136E:  MOVLW  01
1370:  MOVWF  xD8
....................       c = s[index++]; 
1372:  MOVF   xDA,W
1374:  INCF   xDA,F
1376:  ADDWF  xD2,W
1378:  MOVWF  FE9
137A:  MOVLW  00
137C:  ADDWFC xD3,W
137E:  MOVWF  FEA
1380:  MOVFF  FEF,1DB
....................    } 
1384:  BRA    139E
....................    else if (c == '+') 
1386:  MOVF   xDB,W
1388:  SUBLW  2B
138A:  BNZ   139E
....................    { 
....................       c = s[index++]; 
138C:  MOVF   xDA,W
138E:  INCF   xDA,F
1390:  ADDWF  xD2,W
1392:  MOVWF  FE9
1394:  MOVLW  00
1396:  ADDWFC xD3,W
1398:  MOVWF  FEA
139A:  MOVFF  FEF,1DB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
139E:  MOVF   xDB,W
13A0:  SUBLW  2F
13A2:  BTFSC  FD8.0
13A4:  BRA    1594
13A6:  MOVF   xDB,W
13A8:  SUBLW  39
13AA:  BTFSS  FD8.0
13AC:  BRA    1594
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
13AE:  MOVF   xDB,W
13B0:  SUBLW  30
13B2:  BNZ   13F0
13B4:  MOVF   xDA,W
13B6:  ADDWF  xD2,W
13B8:  MOVWF  FE9
13BA:  MOVLW  00
13BC:  ADDWFC xD3,W
13BE:  MOVWF  FEA
13C0:  MOVF   FEF,W
13C2:  SUBLW  78
13C4:  BZ    13D8
13C6:  MOVF   xDA,W
13C8:  ADDWF  xD2,W
13CA:  MOVWF  FE9
13CC:  MOVLW  00
13CE:  ADDWFC xD3,W
13D0:  MOVWF  FEA
13D2:  MOVF   FEF,W
13D4:  SUBLW  58
13D6:  BNZ   13F0
....................       { 
....................          base = 16; 
13D8:  MOVLW  10
13DA:  MOVWF  xD9
....................          index++; 
13DC:  INCF   xDA,F
....................          c = s[index++]; 
13DE:  MOVF   xDA,W
13E0:  INCF   xDA,F
13E2:  ADDWF  xD2,W
13E4:  MOVWF  FE9
13E6:  MOVLW  00
13E8:  ADDWFC xD3,W
13EA:  MOVWF  FEA
13EC:  MOVFF  FEF,1DB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
13F0:  MOVF   xD9,W
13F2:  SUBLW  0A
13F4:  BNZ   147C
....................       { 
....................          while (c >= '0' && c <= '9') { 
13F6:  MOVF   xDB,W
13F8:  SUBLW  2F
13FA:  BC    147A
13FC:  MOVF   xDB,W
13FE:  SUBLW  39
1400:  BNC   147A
....................             result = (result << 1) + (result << 3);  // result *= 10; 
1402:  BCF    FD8.0
1404:  RLCF   xD4,W
1406:  MOVWF  xDD
1408:  RLCF   xD5,W
140A:  MOVWF  xDE
140C:  RLCF   xD6,W
140E:  MOVWF  xDF
1410:  RLCF   xD7,W
1412:  MOVWF  xE0
1414:  RLCF   xD4,W
1416:  MOVWF  00
1418:  RLCF   xD5,W
141A:  MOVWF  01
141C:  RLCF   xD6,W
141E:  MOVWF  02
1420:  RLCF   xD7,W
1422:  MOVWF  03
1424:  RLCF   00,F
1426:  RLCF   01,F
1428:  RLCF   02,F
142A:  RLCF   03,F
142C:  RLCF   00,F
142E:  RLCF   01,F
1430:  RLCF   02,F
1432:  RLCF   03,F
1434:  MOVLW  F8
1436:  ANDWF  00,F
1438:  MOVF   xDD,W
143A:  ADDWF  00,F
143C:  MOVF   xDE,W
143E:  ADDWFC 01,F
1440:  MOVF   xDF,W
1442:  ADDWFC 02,F
1444:  MOVF   xE0,W
1446:  ADDWFC 03,F
1448:  MOVFF  03,1D7
144C:  MOVFF  02,1D6
1450:  MOVFF  01,1D5
1454:  MOVFF  00,1D4
....................             result += (c - '0'); 
1458:  MOVLW  30
145A:  SUBWF  xDB,W
145C:  ADDWF  xD4,F
145E:  MOVLW  00
1460:  ADDWFC xD5,F
1462:  ADDWFC xD6,F
1464:  ADDWFC xD7,F
....................             c = s[index++]; 
1466:  MOVF   xDA,W
1468:  INCF   xDA,F
146A:  ADDWF  xD2,W
146C:  MOVWF  FE9
146E:  MOVLW  00
1470:  ADDWFC xD3,W
1472:  MOVWF  FEA
1474:  MOVFF  FEF,1DB
1478:  BRA    13F6
....................          } 
....................       } 
147A:  BRA    1594
....................       else if (base == 16)    // The number is a hexa number 
147C:  MOVF   xD9,W
147E:  SUBLW  10
1480:  BTFSS  FD8.2
1482:  BRA    1594
....................       { 
....................          c = toupper(c); 
1484:  MOVF   xDB,W
1486:  SUBLW  60
1488:  BC    1496
148A:  MOVF   xDB,W
148C:  SUBLW  7A
148E:  BNC   1496
1490:  MOVF   xDB,W
1492:  ANDLW  DF
1494:  BRA    1498
1496:  MOVF   xDB,W
1498:  MOVWF  xDB
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
149A:  MOVF   xDB,W
149C:  SUBLW  2F
149E:  BC    14A6
14A0:  MOVF   xDB,W
14A2:  SUBLW  39
14A4:  BC    14B4
14A6:  MOVF   xDB,W
14A8:  SUBLW  40
14AA:  BTFSC  FD8.0
14AC:  BRA    1594
14AE:  MOVF   xDB,W
14B0:  SUBLW  46
14B2:  BNC   1594
....................          { 
....................             if (c >= '0' && c <= '9') 
14B4:  MOVF   xDB,W
14B6:  SUBLW  2F
14B8:  BC    1516
14BA:  MOVF   xDB,W
14BC:  SUBLW  39
14BE:  BNC   1516
....................                result = (result << 4) + (c - '0'); 
14C0:  RLCF   xD4,W
14C2:  MOVWF  xDD
14C4:  RLCF   xD5,W
14C6:  MOVWF  xDE
14C8:  RLCF   xD6,W
14CA:  MOVWF  xDF
14CC:  RLCF   xD7,W
14CE:  MOVWF  xE0
14D0:  RLCF   xDD,F
14D2:  RLCF   xDE,F
14D4:  RLCF   xDF,F
14D6:  RLCF   xE0,F
14D8:  RLCF   xDD,F
14DA:  RLCF   xDE,F
14DC:  RLCF   xDF,F
14DE:  RLCF   xE0,F
14E0:  RLCF   xDD,F
14E2:  RLCF   xDE,F
14E4:  RLCF   xDF,F
14E6:  RLCF   xE0,F
14E8:  MOVLW  F0
14EA:  ANDWF  xDD,F
14EC:  MOVLW  30
14EE:  SUBWF  xDB,W
14F0:  ADDWF  xDD,W
14F2:  MOVWF  00
14F4:  MOVLW  00
14F6:  ADDWFC xDE,W
14F8:  MOVWF  01
14FA:  MOVLW  00
14FC:  ADDWFC xDF,W
14FE:  MOVWF  02
1500:  MOVLW  00
1502:  ADDWFC xE0,W
1504:  MOVWF  03
1506:  MOVWF  xD7
1508:  MOVFF  02,1D6
150C:  MOVFF  01,1D5
1510:  MOVFF  00,1D4
1514:  BRA    156A
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
1516:  RLCF   xD4,W
1518:  MOVWF  xDD
151A:  RLCF   xD5,W
151C:  MOVWF  xDE
151E:  RLCF   xD6,W
1520:  MOVWF  xDF
1522:  RLCF   xD7,W
1524:  MOVWF  xE0
1526:  RLCF   xDD,F
1528:  RLCF   xDE,F
152A:  RLCF   xDF,F
152C:  RLCF   xE0,F
152E:  RLCF   xDD,F
1530:  RLCF   xDE,F
1532:  RLCF   xDF,F
1534:  RLCF   xE0,F
1536:  RLCF   xDD,F
1538:  RLCF   xDE,F
153A:  RLCF   xDF,F
153C:  RLCF   xE0,F
153E:  MOVLW  F0
1540:  ANDWF  xDD,F
1542:  MOVLW  41
1544:  SUBWF  xDB,W
1546:  ADDLW  0A
1548:  ADDWF  xDD,W
154A:  MOVWF  00
154C:  MOVLW  00
154E:  ADDWFC xDE,W
1550:  MOVWF  01
1552:  MOVLW  00
1554:  ADDWFC xDF,W
1556:  MOVWF  02
1558:  MOVLW  00
155A:  ADDWFC xE0,W
155C:  MOVWF  xD7
155E:  MOVFF  02,1D6
1562:  MOVFF  01,1D5
1566:  MOVFF  00,1D4
....................  
....................             c = s[index++];c = toupper(c); 
156A:  MOVF   xDA,W
156C:  INCF   xDA,F
156E:  ADDWF  xD2,W
1570:  MOVWF  FE9
1572:  MOVLW  00
1574:  ADDWFC xD3,W
1576:  MOVWF  FEA
1578:  MOVFF  FEF,1DB
157C:  MOVF   xDB,W
157E:  SUBLW  60
1580:  BC    158E
1582:  MOVF   xDB,W
1584:  SUBLW  7A
1586:  BNC   158E
1588:  MOVF   xDB,W
158A:  ANDLW  DF
158C:  BRA    1590
158E:  MOVF   xDB,W
1590:  MOVWF  xDB
1592:  BRA    149A
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1594:  MOVF   xD9,W
1596:  SUBLW  0A
1598:  BNZ   15B4
159A:  DECFSZ xD8,W
159C:  BRA    15B4
....................       result = -result; 
159E:  COMF   xD4,F
15A0:  COMF   xD5,F
15A2:  COMF   xD6,F
15A4:  COMF   xD7,F
15A6:  INCF   xD4,F
15A8:  BTFSC  FD8.2
15AA:  INCF   xD5,F
15AC:  BTFSC  FD8.2
15AE:  INCF   xD6,F
15B0:  BTFSC  FD8.2
15B2:  INCF   xD7,F
....................  
....................    return(result); 
15B4:  MOVFF  1D4,00
15B8:  MOVFF  1D5,01
15BC:  MOVFF  1D6,02
15C0:  MOVFF  1D7,03
15C4:  MOVLB  0
15C6:  RETURN 0
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock = 20000000) 
*
01B8:  MOVLW  03
01BA:  MOVLB  1
01BC:  SUBWF  xEA,F
01BE:  BNC   01D4
01C0:  MOVLW  01
01C2:  MOVWF  FEA
01C4:  MOVLW  EA
01C6:  MOVWF  FE9
01C8:  MOVF   FEF,W
01CA:  BZ    01D4
01CC:  BRA    01D0
01CE:  BRA    01D0
01D0:  DECFSZ FEF,F
01D2:  BRA    01CE
01D4:  MOVLB  0
01D6:  GOTO   01EC (RETURN)
*
0408:  MOVLW  01
040A:  MOVWF  FEA
040C:  MOVLW  DC
040E:  MOVWF  FE9
0410:  MOVF   FEF,W
0412:  BZ    042E
0414:  MOVLW  06
0416:  MOVWF  01
0418:  CLRF   00
041A:  DECFSZ 00,F
041C:  BRA    041A
041E:  DECFSZ 01,F
0420:  BRA    0418
0422:  MOVLW  7B
0424:  MOVWF  00
0426:  DECFSZ 00,F
0428:  BRA    0426
042A:  DECFSZ FEF,F
042C:  BRA    0414
042E:  RETURN 0
.................... #use rs232(uart1, baud = 9600, TIMEOUT = 10, stream = monitor) // pic to pic 
*
01DA:  MOVLW  20
01DC:  MOVLB  1
01DE:  MOVWF  xE8
01E0:  MOVLW  02
01E2:  MOVWF  xE9
01E4:  MOVLW  9B
01E6:  MOVWF  xEA
01E8:  MOVLB  0
01EA:  BRA    01B8
01EC:  MOVLB  1
01EE:  DECFSZ xE9,F
01F0:  BRA    01E4
01F2:  DECFSZ xE8,F
01F4:  BRA    01FC
01F6:  CLRF   1F
01F8:  CLRF   01
01FA:  BRA    0210
01FC:  BTFSS  F9E.5
01FE:  BRA    01E0
0200:  MOVF   FAB,W
0202:  MOVWF  1F
0204:  MOVF   FAE,W
0206:  MOVWF  01
0208:  BTFSS  1F.1
020A:  BRA    0210
020C:  BCF    FAB.4
020E:  BSF    FAB.4
0210:  MOVLB  0
0212:  GOTO   023E (RETURN)
.................... //#use rs232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C0,rcv=PIN_C1,TIMEOUT=40,stream=GPS,DISABLE_INTS)// 
.................... #use rs232(BAUD = 9600, BITS = 8, PARITY = N, XMIT = PIN_C1, rcv = PIN_C0, TIMEOUT = 40, stream = GPS, DISABLE_INTS) // 
*
1084:  MOVFF  FF2,03
1088:  BCF    FF2.7
108A:  BCF    F94.1
108C:  BCF    F8B.1
108E:  MOVLW  08
1090:  MOVWF  01
1092:  BRA    1094
1094:  NOP   
1096:  BSF    01.7
1098:  BRA    10BA
109A:  BCF    01.7
109C:  MOVLB  1
109E:  RRCF   xDA,F
10A0:  MOVLB  0
10A2:  BTFSC  FD8.0
10A4:  BSF    F8B.1
10A6:  BTFSS  FD8.0
10A8:  BCF    F8B.1
10AA:  BSF    01.6
10AC:  BRA    10BA
10AE:  BCF    01.6
10B0:  DECFSZ 01,F
10B2:  BRA    109C
10B4:  BRA    10B6
10B6:  NOP   
10B8:  BSF    F8B.1
10BA:  MOVLW  A7
10BC:  MOVWF  FE9
10BE:  DECFSZ FE9,F
10C0:  BRA    10BE
10C2:  BRA    10C4
10C4:  BTFSC  01.7
10C6:  BRA    109A
10C8:  BTFSC  01.6
10CA:  BRA    10AE
10CC:  BTFSC  03.7
10CE:  BSF    FF2.7
10D0:  RETURN 0
.................... #fuses HS, NOLVP, PUT, PROTECT, NODEBUG, NOWDT, WDT4096                                                              // pin D5 rx, tx_d0 
.................... #priority int_rda 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0430:  MOVLB  1
0432:  BTFSC  xE3.0
0434:  BRA    043A
0436:  BCF    F89.4
0438:  BRA    043C
043A:  BSF    F89.4
043C:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
043E:  BTFSC  xE3.1
0440:  BRA    0446
0442:  BCF    F89.2
0444:  BRA    0448
0446:  BSF    F89.2
0448:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
044A:  BTFSC  xE3.2
044C:  BRA    0452
044E:  BCF    F89.1
0450:  BRA    0454
0452:  BSF    F89.1
0454:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0456:  BTFSC  xE3.3
0458:  BRA    045E
045A:  BCF    F89.0
045C:  BRA    0460
045E:  BSF    F89.0
0460:  BCF    F92.0
....................  
....................  delay_cycles(1);  
0462:  NOP   
....................  output_high(LCD_E);  
0464:  BCF    F92.3
0466:  BSF    F89.3
....................  delay_us(2);  
0468:  MOVLW  02
046A:  MOVWF  00
046C:  DECFSZ 00,F
046E:  BRA    046C
0470:  BRA    0472
0472:  NOP   
....................  output_low(LCD_E);  
0474:  BCF    F92.3
0476:  BCF    F89.3
0478:  MOVLB  0
047A:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
047C:  BCF    F96.2
047E:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0480:  MOVLW  63
0482:  MOVWF  00
0484:  DECFSZ 00,F
0486:  BRA    0484
0488:  BRA    048A
.................... #endif  
....................  
.................... if(address)  
048A:  MOVLB  1
048C:  MOVF   xE0,F
048E:  BZ    0496
....................    output_high(LCD_RS);  
0490:  BCF    F96.2
0492:  BSF    F8D.2
0494:  BRA    049A
.................... else  
....................    output_low(LCD_RS);  
0496:  BCF    F96.2
0498:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
049A:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
049C:  BCF    F92.3
049E:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
04A0:  SWAPF  xE1,W
04A2:  MOVWF  xE2
04A4:  MOVLW  0F
04A6:  ANDWF  xE2,F
04A8:  MOVFF  1E2,1E3
04AC:  MOVLB  0
04AE:  RCALL  0430
.................... lcd_send_nibble(n & 0xf);  
04B0:  MOVLB  1
04B2:  MOVF   xE1,W
04B4:  ANDLW  0F
04B6:  MOVWF  xE2
04B8:  MOVWF  xE3
04BA:  MOVLB  0
04BC:  RCALL  0430
04BE:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
04C0:  MOVLW  01
04C2:  MOVWF  21
....................  
....................    output_low(LCD_RS);  
04C4:  BCF    F96.2
04C6:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
04C8:  BCF    F92.3
04CA:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
04CC:  MOVLW  23
04CE:  MOVLB  1
04D0:  MOVWF  xDC
04D2:  MOVLB  0
04D4:  RCALL  0408
....................  
....................    for(i=0 ;i < 3; i++)  
04D6:  MOVLB  1
04D8:  CLRF   xD1
04DA:  MOVF   xD1,W
04DC:  SUBLW  02
04DE:  BNC   04F8
....................    {  
....................       lcd_send_nibble(0x03);  
04E0:  MOVLW  03
04E2:  MOVWF  xE3
04E4:  MOVLB  0
04E6:  RCALL  0430
....................       delay_ms(5);  
04E8:  MOVLW  05
04EA:  MOVLB  1
04EC:  MOVWF  xDC
04EE:  MOVLB  0
04F0:  RCALL  0408
04F2:  MOVLB  1
04F4:  INCF   xD1,F
04F6:  BRA    04DA
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
04F8:  MOVLW  02
04FA:  MOVWF  xE3
04FC:  MOVLB  0
04FE:  RCALL  0430
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
0500:  MOVLB  1
0502:  CLRF   xD1
0504:  MOVF   xD1,W
0506:  SUBLW  03
0508:  BNC   052E
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
050A:  CLRF   03
050C:  MOVF   xD1,W
050E:  MOVLB  0
0510:  RCALL  00C6
0512:  MOVLB  1
0514:  MOVWF  xD2
0516:  CLRF   xE0
0518:  MOVWF  xE1
051A:  MOVLB  0
051C:  RCALL  047C
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
051E:  MOVLW  05
0520:  MOVLB  1
0522:  MOVWF  xDC
0524:  MOVLB  0
0526:  RCALL  0408
....................       #endif  
0528:  MOVLB  1
052A:  INCF   xD1,F
052C:  BRA    0504
....................    }  
052E:  MOVLB  0
0530:  GOTO   2C8E (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
086C:  MOVLB  1
086E:  MOVF   xDD,W
0870:  XORLW  01
0872:  MOVLB  0
0874:  BZ    0884
0876:  XORLW  03
0878:  BZ    088A
087A:  XORLW  01
087C:  BZ    0892
087E:  XORLW  07
0880:  BZ    089A
0882:  BRA    08A4
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
0884:  MOVLB  1
0886:  CLRF   xDE
....................      break;  
0888:  BRA    08A8
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
088A:  MOVLW  40
088C:  MOVLB  1
088E:  MOVWF  xDE
....................      break;  
0890:  BRA    08A8
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0892:  MOVLW  14
0894:  MOVLB  1
0896:  MOVWF  xDE
....................      break;  
0898:  BRA    08A8
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
089A:  MOVLW  54
089C:  MOVLB  1
089E:  MOVWF  xDE
....................      break;  
08A0:  BRA    08A8
08A2:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
08A4:  MOVLB  1
08A6:  CLRF   xDE
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
08A8:  MOVLW  01
08AA:  SUBWF  xDC,W
08AC:  ADDWF  xDE,F
.................... lcd_send_byte(0, 0x80 | address);  
08AE:  MOVF   xDE,W
08B0:  IORLW  80
08B2:  MOVWF  xDF
08B4:  CLRF   xE0
08B6:  MOVWF  xE1
08B8:  MOVLB  0
08BA:  RCALL  047C
08BC:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
08BE:  MOVLB  1
08C0:  MOVF   xDB,W
08C2:  XORLW  0C
08C4:  MOVLB  0
08C6:  BZ    08D2
08C8:  XORLW  06
08CA:  BZ    08EE
08CC:  XORLW  02
08CE:  BZ    0900
08D0:  BRA    090E
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
08D2:  MOVLB  1
08D4:  CLRF   xE0
08D6:  MOVLW  01
08D8:  MOVWF  xE1
08DA:  MOVLB  0
08DC:  RCALL  047C
....................       lcd_line = 1;  
08DE:  MOVLW  01
08E0:  MOVWF  21
....................       delay_ms(2);  
08E2:  MOVLW  02
08E4:  MOVLB  1
08E6:  MOVWF  xDC
08E8:  MOVLB  0
08EA:  RCALL  0408
....................       break;  
08EC:  BRA    091C
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
08EE:  INCF   21,F
08F0:  MOVLW  01
08F2:  MOVLB  1
08F4:  MOVWF  xDC
08F6:  MOVFF  21,1DD
08FA:  MOVLB  0
08FC:  RCALL  086C
....................        break;  
08FE:  BRA    091C
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
0900:  MOVLB  1
0902:  CLRF   xE0
0904:  MOVLW  10
0906:  MOVWF  xE1
0908:  MOVLB  0
090A:  RCALL  047C
....................        break;  
090C:  BRA    091C
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
090E:  MOVLW  01
0910:  MOVLB  1
0912:  MOVWF  xE0
0914:  MOVFF  1DB,1E1
0918:  MOVLB  0
091A:  RCALL  047C
....................        break;  
....................    }  
091C:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_eeprom.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_D6//PIN_B7 
.................... #define EEPROM_SCL  PIN_D7//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
053C:  MOVLW  08
053E:  MOVWF  01
0540:  MOVLW  05
0542:  MOVWF  00
0544:  DECFSZ 00,F
0546:  BRA    0544
0548:  BCF    F8C.7
054A:  BCF    F95.7
054C:  MOVLW  06
054E:  MOVWF  00
0550:  DECFSZ 00,F
0552:  BRA    0550
0554:  MOVLB  1
0556:  RLCF   xDB,F
0558:  BCF    F8C.6
055A:  BTFSC  FD8.0
055C:  BSF    F95.6
055E:  BTFSS  FD8.0
0560:  BCF    F95.6
0562:  BSF    F95.7
0564:  BTFSS  F83.7
0566:  BRA    0564
0568:  DECFSZ 01,F
056A:  BRA    056E
056C:  BRA    0572
056E:  MOVLB  0
0570:  BRA    0540
0572:  MOVLW  05
0574:  MOVWF  00
0576:  DECFSZ 00,F
0578:  BRA    0576
057A:  BCF    F8C.7
057C:  BCF    F95.7
057E:  NOP   
0580:  BSF    F95.6
0582:  MOVLW  06
0584:  MOVWF  00
0586:  DECFSZ 00,F
0588:  BRA    0586
058A:  MOVLW  06
058C:  MOVWF  00
058E:  DECFSZ 00,F
0590:  BRA    058E
0592:  BSF    F95.7
0594:  BTFSS  F83.7
0596:  BRA    0594
0598:  CLRF   01
059A:  MOVLW  06
059C:  MOVWF  00
059E:  DECFSZ 00,F
05A0:  BRA    059E
05A2:  BTFSC  F83.6
05A4:  BSF    01.0
05A6:  BCF    F8C.7
05A8:  BCF    F95.7
05AA:  BCF    F8C.6
05AC:  BCF    F95.6
05AE:  MOVLB  0
05B0:  RETURN 0
*
0706:  MOVLW  08
0708:  MOVLB  1
070A:  MOVWF  xD9
070C:  MOVFF  00,1DA
0710:  BSF    F95.6
0712:  MOVLW  06
0714:  MOVWF  00
0716:  DECFSZ 00,F
0718:  BRA    0716
071A:  BSF    F95.7
071C:  BTFSS  F83.7
071E:  BRA    071C
0720:  BTFSC  F83.6
0722:  BSF    FD8.0
0724:  BTFSS  F83.6
0726:  BCF    FD8.0
0728:  RLCF   01,F
072A:  MOVLW  05
072C:  MOVWF  00
072E:  DECFSZ 00,F
0730:  BRA    072E
0732:  BCF    F95.7
0734:  BCF    F8C.7
0736:  DECFSZ xD9,F
0738:  BRA    0710
073A:  BSF    F95.6
073C:  MOVLW  06
073E:  MOVWF  00
0740:  DECFSZ 00,F
0742:  BRA    0740
0744:  BCF    F8C.6
0746:  MOVF   xDA,W
0748:  BTFSS  FD8.2
074A:  BCF    F95.6
074C:  NOP   
074E:  BSF    F95.7
0750:  BTFSS  F83.7
0752:  BRA    0750
0754:  MOVLW  05
0756:  MOVWF  00
0758:  DECFSZ 00,F
075A:  BRA    0758
075C:  BCF    F8C.7
075E:  BCF    F95.7
0760:  MOVLW  06
0762:  MOVWF  00
0764:  DECFSZ 00,F
0766:  BRA    0764
0768:  BCF    F8C.6
076A:  BCF    F95.6
076C:  MOVLB  0
076E:  GOTO   07EC (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
0534:  BSF    F95.7
....................    output_float(EEPROM_SDA); 
0536:  BSF    F95.6
0538:  GOTO   2C92 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
05B2:  BSF    F95.6
05B4:  MOVLW  05
05B6:  MOVWF  00
05B8:  DECFSZ 00,F
05BA:  BRA    05B8
05BC:  BSF    F95.7
05BE:  MOVLW  06
05C0:  MOVWF  00
05C2:  DECFSZ 00,F
05C4:  BRA    05C2
05C6:  BCF    F8C.6
05C8:  BCF    F95.6
05CA:  MOVLW  05
05CC:  MOVWF  00
05CE:  DECFSZ 00,F
05D0:  BRA    05CE
05D2:  BCF    F8C.7
05D4:  BCF    F95.7
....................    i2c_write(0xa0); 
05D6:  MOVLW  A0
05D8:  MOVLB  1
05DA:  MOVWF  xDB
05DC:  MOVLB  0
05DE:  RCALL  053C
....................    i2c_write(address>>8); 
05E0:  MOVFF  1D6,1D9
05E4:  MOVLB  1
05E6:  CLRF   xDA
05E8:  MOVFF  1D6,1DB
05EC:  MOVLB  0
05EE:  RCALL  053C
....................    i2c_write(address); 
05F0:  MOVFF  1D5,1DB
05F4:  RCALL  053C
....................    i2c_write(data); 
05F6:  MOVFF  1D7,1DB
05FA:  RCALL  053C
....................    i2c_stop(); 
05FC:  BCF    F95.6
05FE:  NOP   
0600:  BSF    F95.7
0602:  BTFSS  F83.7
0604:  BRA    0602
0606:  MOVLW  05
0608:  MOVWF  00
060A:  DECFSZ 00,F
060C:  BRA    060A
060E:  BRA    0610
0610:  NOP   
0612:  BSF    F95.6
0614:  MOVLW  05
0616:  MOVWF  00
0618:  DECFSZ 00,F
061A:  BRA    0618
....................    i2c_start(); 
061C:  BSF    F95.6
061E:  MOVLW  05
0620:  MOVWF  00
0622:  DECFSZ 00,F
0624:  BRA    0622
0626:  BSF    F95.7
0628:  MOVLW  06
062A:  MOVWF  00
062C:  DECFSZ 00,F
062E:  BRA    062C
0630:  BCF    F8C.6
0632:  BCF    F95.6
0634:  MOVLW  05
0636:  MOVWF  00
0638:  DECFSZ 00,F
063A:  BRA    0638
063C:  BCF    F8C.7
063E:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0640:  MOVLW  A0
0642:  MOVLB  1
0644:  MOVWF  xDB
0646:  MOVLB  0
0648:  RCALL  053C
064A:  MOVF   01,W
064C:  MOVLB  1
064E:  BCF    xD8.0
0650:  BTFSC  01.0
0652:  BSF    xD8.0
....................    while(status==1) 
0654:  BTFSS  xD8.0
0656:  BRA    0694
....................    { 
....................    i2c_start(); 
0658:  BSF    F95.6
065A:  MOVLW  05
065C:  MOVWF  00
065E:  DECFSZ 00,F
0660:  BRA    065E
0662:  BSF    F95.7
0664:  MOVLW  06
0666:  MOVWF  00
0668:  DECFSZ 00,F
066A:  BRA    0668
066C:  BTFSS  F83.7
066E:  BRA    066C
0670:  BCF    F8C.6
0672:  BCF    F95.6
0674:  MOVLW  05
0676:  MOVWF  00
0678:  DECFSZ 00,F
067A:  BRA    0678
067C:  BCF    F8C.7
067E:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0680:  MOVLW  A0
0682:  MOVWF  xDB
0684:  MOVLB  0
0686:  RCALL  053C
0688:  MOVF   01,W
068A:  MOVLB  1
068C:  BCF    xD8.0
068E:  BTFSC  01.0
0690:  BSF    xD8.0
0692:  BRA    0654
....................    } 
....................    i2c_stop(); 
0694:  BCF    F95.6
0696:  NOP   
0698:  BSF    F95.7
069A:  BTFSS  F83.7
069C:  BRA    069A
069E:  MOVLW  05
06A0:  MOVWF  00
06A2:  DECFSZ 00,F
06A4:  BRA    06A2
06A6:  BRA    06A8
06A8:  NOP   
06AA:  BSF    F95.6
06AC:  MOVLW  05
06AE:  MOVWF  00
06B0:  DECFSZ 00,F
06B2:  BRA    06B0
06B4:  MOVLB  0
06B6:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0772:  BSF    F95.6
0774:  MOVLW  05
0776:  MOVWF  00
0778:  DECFSZ 00,F
077A:  BRA    0778
077C:  BSF    F95.7
077E:  MOVLW  06
0780:  MOVWF  00
0782:  DECFSZ 00,F
0784:  BRA    0782
0786:  BCF    F8C.6
0788:  BCF    F95.6
078A:  MOVLW  05
078C:  MOVWF  00
078E:  DECFSZ 00,F
0790:  BRA    078E
0792:  BCF    F8C.7
0794:  BCF    F95.7
....................    i2c_write(0xa0); 
0796:  MOVLW  A0
0798:  MOVLB  1
079A:  MOVWF  xDB
079C:  MOVLB  0
079E:  RCALL  053C
....................    i2c_write(address>>8); 
07A0:  MOVFF  1D6,1D8
07A4:  MOVLB  1
07A6:  CLRF   xD9
07A8:  MOVFF  1D6,1DB
07AC:  MOVLB  0
07AE:  RCALL  053C
....................    i2c_write(address); 
07B0:  MOVFF  1D5,1DB
07B4:  RCALL  053C
....................    i2c_start(); 
07B6:  BSF    F95.6
07B8:  MOVLW  05
07BA:  MOVWF  00
07BC:  DECFSZ 00,F
07BE:  BRA    07BC
07C0:  BSF    F95.7
07C2:  MOVLW  06
07C4:  MOVWF  00
07C6:  DECFSZ 00,F
07C8:  BRA    07C6
07CA:  BTFSS  F83.7
07CC:  BRA    07CA
07CE:  BCF    F8C.6
07D0:  BCF    F95.6
07D2:  MOVLW  05
07D4:  MOVWF  00
07D6:  DECFSZ 00,F
07D8:  BRA    07D6
07DA:  BCF    F8C.7
07DC:  BCF    F95.7
....................    i2c_write(0xa1); 
07DE:  MOVLW  A1
07E0:  MOVLB  1
07E2:  MOVWF  xDB
07E4:  MOVLB  0
07E6:  RCALL  053C
....................    data=i2c_read(0); 
07E8:  CLRF   00
07EA:  BRA    0706
07EC:  MOVFF  01,1D7
....................    i2c_stop(); 
07F0:  BCF    F95.6
07F2:  NOP   
07F4:  BSF    F95.7
07F6:  BTFSS  F83.7
07F8:  BRA    07F6
07FA:  MOVLW  05
07FC:  MOVWF  00
07FE:  DECFSZ 00,F
0800:  BRA    07FE
0802:  BRA    0804
0804:  NOP   
0806:  BSF    F95.6
0808:  MOVLW  05
080A:  MOVWF  00
080C:  DECFSZ 00,F
080E:  BRA    080C
....................    return(data); 
0810:  MOVLB  1
0812:  MOVFF  1D7,01
0816:  MOVLB  0
0818:  RETURN 0
.................... } 
....................  
.................... //****************************************************************************** 
.................... // entradas 
.................... #define entrada01 PIN_B4 ////SENSOR 1              2  1 
.................... #define entrada02 PIN_D4 ////SENSOR 2              4  3 
.................... #define entrada03 PIN_B2 ////SENSOR 3              6  5 
.................... #define entrada04 PIN_B3 ////SENSOR 4 
.................... #define entrada05 PIN_B0 ////SENSOR 5 
.................... #define entrada06 PIN_B1 ////SENSOR 6 
....................  
.................... #define rst_cta PIN_D3    ////REINICIAR CONTADOR 
.................... #define frente PIN_D2     /// INDICADOR DE MAESTRO 
.................... #define B_silencio PIN_D1 /// BOTON PARA SILENCIAR (eliminado) 
.................... // salidas 
.................... #define salida01 PIN_C3 // Buzzer 
.................... #define salida02 PIN_C4 // Indicador de Sensado 
.................... #define salida03 PIN_C5 // Relay 
....................  
.................... #define HB PIN_E0 // habilita recepcion de datos en gprs  pin 25->D39 
.................... #define EN PIN_E1 // monitor de "envio listo" desde gprs  pin 26->D38 
....................  
.................... const int s_cta = 5; // numero de veces para verificar obsturbcion (sensibilidad de deteccion) 
.................... int size_s;          // Tamao de trama que espera leer el puerto serial (se utiliza para agilizar la captura de datos) 
.................... ///////VARIABLES DE CONEXION///// 
.................... int error, transmitir; // variable para indicar un error al escuchar la cuenta del poste trasero, bandera para inciar transmision a gprs 
.................... ///////GENERALES////////////////////// 
.................... int sumae1, sumas1;                                                  // Variables temporales de suma de entradas y salidas 
.................... int lim_b;                                                           // cuenta de sensores bloqueados 
.................... int fse1, fse2, fse3, fss1, fss2, fss3;                              // banderas que indican si los pares de sensores detectaron entrada o salida 
.................... unsigned int16 temporal1, temporal2, tempo_tn, sub_atras, baj_atras; // variables temporales para hacer calculos. 
.................... int16 entran1, salen1;                                               // variables temporales para hacer calculos. 
.................... ///////--------------------/////////// 
.................... int16 salian, time_clr; // variable temporal para guardar salidas 
.................... int ini, i, ii, j = 0, a, master = 0, flag_enviar, f_clr; 
.................... int16 b, n, cta_bloqueo, cta_enviar, total2_t;                                                //,envia_ent,envia_sal; 
.................... int cta_bloq1 = 0, cta_bloq2 = 0, cta_bloq3 = 0;                                              // variables para contar bloqueos por pares 
.................... int ent1 = 0, ent2 = 0, ent3 = 0, ent4 = 0, ent5 = 0, ent6 = 0;                               // variables de estado de sensores 
.................... int sen_ent = 0, sen_sal = 0;                                                                 // variables para definir el sentido (subio o bajo) 
.................... int16 sub_cta1 = 0, sub_cta2 = 0, sub_cta3 = 0, sub_cta4 = 0, sub_cta5 = 0, sub_cta6 = 0;     // variables para calculos de cuentas 
.................... int detec1, detec2, detec3, detec4, detec5, detec6;                                           // variables para determinar el cambio de estado de los sensores 
.................... int sub_d1, sub_d2, sub_d3, sub_d4, sub_d5, sub_d6;                                           // variables para determinar el cambio de estado de los sensores 
.................... int entra_act1 = 0, edo1 = 0, entra1 = 0, sale1 = 0, edoa1 = 0, enable1 = 0, entra_temp1 = 0; // variables para la maquina de estados de sensores par1 
.................... int entra_act2 = 0, edo2 = 0, entra2 = 0, sale2 = 0, edoa2 = 0, enable2 = 0, entra_temp2 = 0; // variables para la maquina de estados de sensores par2 
.................... int entra_act3 = 0, edo3 = 0, entra3 = 0, sale3 = 0, edoa3 = 0, enable3 = 0, entra_temp3 = 0; // variables para la maquina de estados de sensores par3 
.................... int16 entraront = 0, salieront = 0, pasaje = 0, pasajet = 0;                                  // cuenta total de entradas y salidas 
.................... int16 tem_entraront = 0, tem_salieront = 0, temporal3;                                        // cuenta total de entradas y salidas recibidas de cuentas del poste trasero. 
.................... int des1 = 0, des2 = 0, des3 = 0; 
.................... int bloq_p1, bloq_p2, bloq_p3, en_b1, en_b2, en_b3; 
.................... int16 tim_p1, tim_p2, tim_p3, segundoen, time_envio; 
.................... const int32 set_timer = 59286;  // 10ms 
.................... const int16 time_bloqueo = 500; // 5seg. 100=1seg. 
.................... int clear_lcd1, time_lcd1; 
.................... int y = 0; 
.................... int bandera_revision = 0; 
.................... int16 cntbnd = 0; 
.................... int nuevo_pulso = 0; 
.................... int time_s3 = 0; 
.................... int fls3 = 0; 
.................... int cta_pulsos = 0; 
....................  
.................... // variables temporales para la conversion de string a entero de datos seriales de la cuenta de pasajeros del poste trasero/// 
.................... char term[3], *ptr; 
.................... char data1[14]; 
.................... char data2[10]; 
.................... char data3[10]; 
.................... char data4[10]; 
.................... char data5[10]; 
.................... int caso_valor = 0; 
.................... int solicitud_reset_gps = 0; 
....................  
.................... // lista de comandos para contadores /// 
.................... char *textosearch[11] = {"V5.01     \r", 
....................                          "BORRAR_ALL\r", 
....................                          "GRABAR_DAT\r", 
....................                          "LEERCUENTA\r", // 
....................                          "SOLICITADO\r", 
....................                          "PASAJEROS:\r", 
....................                          "SERIALTEST\r", 
....................                          "SERIAL_TOK\r", 
....................                          "SUBIENDOC2\r", 
....................                          "SINFUNCION\r", 
....................                          "          \r"}; 
....................  
.................... char version[] = "V1.00"; //<---Version de codigo de contador 
....................  
.................... /////EEPROM/////////// 
.................... const int word_size = 10; // TAMAO DE LOS DATOS EN EEPROM//antes 8 
.................... const int data_set = 9; 
.................... // char XX[word_size+19];// ARREGLO SERIAL 
.................... char XX[word_size + 22]; // ARREGLO SERIAL 
.................... char entran[5]; 
.................... char salen[5]; 
.................... char bloqueado[5]; 
.................... char memory[word_size]; 
.................... //*******************************// 
.................... char tempo_tc[5]; 
.................... /////////////FUNCIONES///////////// 
.................... void rev_suben(); 
.................... void cuenta_pulsos(); 
.................... void rev_suben(); 
.................... void enviop1(); 
.................... void finsuma(); 
.................... void leer_conta2(); 
.................... void graba_conta2(); 
....................  
.................... //int convertir_to_entero(char *cadena); 
.................... int evaluar_string(char *command[]); 
.................... void envia2(); 
.................... void solicitar(); 
.................... void envio_master(); 
.................... void envio(); 
.................... void limpiar(); 
.................... void detecta_suma(); 
.................... void write_ent(); 
.................... void write_sal(); 
.................... void entraron_total(); 
.................... void salieron_total(); 
.................... //void rd_eeprom(); 
.................... void rd_eeprom_inicio(); 
.................... // void llaves(); 
....................  
.................... void lcd_cuentas(); 
.................... void sentidos(); 
.................... void sensores(); 
.................... void sensando1(); 
.................... void sensando2(); 
.................... void sensando3(); 
.................... void contando1(); 
.................... void contando2(); 
.................... void contando3(); 
.................... void dar_dato(); 
.................... void reset(); 
.................... //------------------------------------------------------------------------------ 
.................... // Rutina de gestin de interrupciones 
.................... //------------------------------------------------------------------------------ 
.................... #int_TIMER1 // se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void) 
.................... { 
....................    time_clr++; 
*
00EE:  INCF   3E,F
00F0:  BTFSC  FD8.2
00F2:  INCF   3F,F
....................    time_s3++; 
00F4:  INCF   xB2,F
....................    segundoen++; 
00F6:  INCF   xA7,F
00F8:  BTFSC  FD8.2
00FA:  INCF   xA8,F
....................    if (segundoen >= 100) 
00FC:  MOVF   xA8,F
00FE:  BNZ   0106
0100:  MOVF   xA7,W
0102:  SUBLW  63
0104:  BC    0112
....................    { 
....................       segundoen = 0; 
0106:  CLRF   xA8
0108:  CLRF   xA7
....................       time_envio++; 
010A:  INCF   xA9,F
010C:  BTFSC  FD8.2
010E:  INCF   xAA,F
....................       time_lcd1++; 
0110:  INCF   xAC,F
....................    } 
....................    //****Se definen los estados de los sensores (deteccion)***// 
....................    // sensor1 
....................    ent1 = input(entrada01); 
0112:  BSF    F93.4
0114:  CLRF   55
0116:  BTFSC  F81.4
0118:  INCF   55,F
....................    if (ent1 == 0) 
011A:  MOVF   55,F
011C:  BNZ   0124
....................       sub_cta1++; // ent1 =0 (no pulso) 
011E:  INCF   5D,F
0120:  BTFSC  FD8.2
0122:  INCF   5E,F
....................    // sensor2 
....................    ent2 = input(entrada02); 
0124:  BSF    F95.4
0126:  CLRF   56
0128:  BTFSC  F83.4
012A:  INCF   56,F
....................    if (ent2 == 0) 
012C:  MOVF   56,F
012E:  BNZ   0136
....................       sub_cta2++; 
0130:  INCF   5F,F
0132:  BTFSC  FD8.2
0134:  INCF   x60,F
....................    // sensor3 
....................    ent3 = input(entrada03); 
0136:  BSF    F93.2
0138:  CLRF   57
013A:  BTFSC  F81.2
013C:  INCF   57,F
....................    if (ent3 == 0) 
013E:  MOVF   57,F
0140:  BNZ   0148
....................       sub_cta3++; 
0142:  INCF   x61,F
0144:  BTFSC  FD8.2
0146:  INCF   x62,F
....................    // sensor4 
....................    ent4 = input(entrada04); 
0148:  BSF    F93.3
014A:  CLRF   58
014C:  BTFSC  F81.3
014E:  INCF   58,F
....................    if (ent4 == 0) 
0150:  MOVF   58,F
0152:  BNZ   015A
....................       sub_cta4++; 
0154:  INCF   x63,F
0156:  BTFSC  FD8.2
0158:  INCF   x64,F
....................    // sensor5 
....................    ent5 = input(entrada05); 
015A:  BSF    F93.0
015C:  CLRF   59
015E:  BTFSC  F81.0
0160:  INCF   59,F
....................    if (ent5 == 0) 
0162:  MOVF   59,F
0164:  BNZ   016C
....................       sub_cta5++; 
0166:  INCF   x65,F
0168:  BTFSC  FD8.2
016A:  INCF   x66,F
....................    // sensor6 
....................    ent6 = input(entrada06); 
016C:  BSF    F93.1
016E:  CLRF   5A
0170:  BTFSC  F81.1
0172:  INCF   5A,F
....................    if (ent6 == 0) 
0174:  MOVF   5A,F
0176:  BNZ   017E
....................       sub_cta6++; 
0178:  INCF   x67,F
017A:  BTFSC  FD8.2
017C:  INCF   x68,F
....................    //****************************************// 
....................    tim_p1++; 
017E:  INCF   xA1,F
0180:  BTFSC  FD8.2
0182:  INCF   xA2,F
....................    tim_p2++; 
0184:  INCF   xA3,F
0186:  BTFSC  FD8.2
0188:  INCF   xA4,F
....................    tim_p3++; 
018A:  INCF   xA5,F
018C:  BTFSC  FD8.2
018E:  INCF   xA6,F
....................    cta_enviar++; 
0190:  INCF   4E,F
0192:  BTFSC  FD8.2
0194:  INCF   4F,F
....................    set_timer1(set_timer); // 10ms 
0196:  MOVLW  E7
0198:  MOVWF  FCF
019A:  MOVLW  96
019C:  MOVWF  FCE
.................... } 
.................... //****************************************************************************// 
....................  
.................... //----------------------------------------------------------------------------- 
.................... // timer para la el tiempo de espera del puerto serial emulado, datos del gprs// 
019E:  BCF    F9E.0
01A0:  GOTO   0078
.................... #int_TIMER3 
.................... void TIMER3_isr(void) 
.................... { 
....................    cntbnd++; // bandera de conteo de timepo de espera de para puerto serial emlado 
01A4:  INCF   xAF,F
01A6:  BTFSC  FD8.2
01A8:  INCF   xB0,F
....................    set_timer3(65036); 
01AA:  MOVLW  FE
01AC:  MOVWF  FB3
01AE:  MOVLW  0C
01B0:  MOVWF  FB2
.................... } 
....................  
.................... //----------------------------------------------------------------------------- 
.................... // captura de datos seriales entre postes, delantero y trasero ///////////// 
01B2:  BCF    FA1.1
01B4:  GOTO   0078
.................... #int_rda 
.................... void isr_rs232() 
.................... {                              // escucha segundo poste 
....................    disable_interrupts(GLOBAL); // deshabilita interrupciones globales 
*
0216:  BCF    FF2.6
0218:  BCF    FF2.7
021A:  BTFSC  FF2.7
021C:  BRA    0218
....................    i = 0;                      // CONTADOR DE ARREGLO SERIAL INICIADO 
021E:  CLRF   41
....................    while (i <= 30) 
0220:  MOVF   41,W
0222:  SUBLW  1E
0224:  BNC   0264
....................    { 
....................       XX[i] = fgetc(monitor); 
0226:  CLRF   03
0228:  MOVF   41,W
022A:  ADDLW  92
022C:  MOVWF  FE9
022E:  MOVLW  01
0230:  ADDWFC 03,W
0232:  MOVWF  FEA
0234:  MOVFF  FEA,1E7
0238:  MOVFF  FE9,1E6
023C:  BRA    01DA
023E:  MOVFF  1E7,FEA
0242:  MOVFF  1E6,FE9
0246:  MOVFF  01,FEF
....................       i++; 
024A:  INCF   41,F
....................       if (XX[i] == 13) 
024C:  CLRF   03
024E:  MOVF   41,W
0250:  ADDLW  92
0252:  MOVWF  FE9
0254:  MOVLW  01
0256:  ADDWFC 03,W
0258:  MOVWF  FEA
025A:  MOVF   FEF,W
025C:  SUBLW  0D
025E:  BNZ   0262
....................          break; 
0260:  BRA    0264
0262:  BRA    0220
....................    } // se captura el dato del serial monitor(comunicacion entre pics) 
....................    j = 1; 
0264:  MOVLW  01
0266:  MOVWF  43
....................    y = 1; 
0268:  MOVWF  xAD
....................    // sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
....................  
026A:  BCF    F9E.5
026C:  GOTO   0078
.................... #ZERO_RAM 
.................... void main() 
*
2AC2:  CLRF   FF8
2AC4:  BCF    FD0.7
2AC6:  BSF    07.7
2AC8:  MOVLW  FE
2ACA:  MOVWF  00
2ACC:  MOVLW  06
2ACE:  MOVWF  01
2AD0:  MOVLW  02
2AD2:  MOVWF  FE9
2AD4:  MOVLW  00
2AD6:  MOVWF  FEA
2AD8:  CLRF   FEE
2ADA:  DECFSZ 00,F
2ADC:  BRA    2AD8
2ADE:  DECFSZ 01,F
2AE0:  BRA    2AD8
2AE2:  CLRF   1F
2AE4:  BSF    FB8.3
2AE6:  MOVLW  08
2AE8:  MOVWF  FAF
2AEA:  MOVLW  02
2AEC:  MOVWF  FB0
2AEE:  MOVLW  A6
2AF0:  MOVWF  FAC
2AF2:  MOVLW  90
2AF4:  MOVWF  FAB
2AF6:  CLRF   20
2AF8:  BCF    F94.1
2AFA:  BSF    F8B.1
2AFC:  CLRF   43
2AFE:  CLRF   45
2B00:  CLRF   52
2B02:  CLRF   53
2B04:  CLRF   54
2B06:  CLRF   55
2B08:  CLRF   56
2B0A:  CLRF   57
2B0C:  CLRF   58
2B0E:  CLRF   59
2B10:  CLRF   5A
2B12:  CLRF   5B
2B14:  CLRF   5C
2B16:  CLRF   5E
2B18:  CLRF   5D
2B1A:  CLRF   x60
2B1C:  CLRF   5F
2B1E:  CLRF   x62
2B20:  CLRF   x61
2B22:  CLRF   x64
2B24:  CLRF   x63
2B26:  CLRF   x66
2B28:  CLRF   x65
2B2A:  CLRF   x68
2B2C:  CLRF   x67
2B2E:  CLRF   x75
2B30:  CLRF   x76
2B32:  CLRF   x77
2B34:  CLRF   x78
2B36:  CLRF   x79
2B38:  CLRF   x7A
2B3A:  CLRF   x7B
2B3C:  CLRF   x7C
2B3E:  CLRF   x7D
2B40:  CLRF   x7E
2B42:  CLRF   x7F
2B44:  CLRF   x80
2B46:  CLRF   x81
2B48:  CLRF   x82
2B4A:  CLRF   x83
2B4C:  CLRF   x84
2B4E:  CLRF   x85
2B50:  CLRF   x86
2B52:  CLRF   x87
2B54:  CLRF   x88
2B56:  CLRF   x89
2B58:  CLRF   x8B
2B5A:  CLRF   x8A
2B5C:  CLRF   x8D
2B5E:  CLRF   x8C
2B60:  CLRF   x8F
2B62:  CLRF   x8E
2B64:  CLRF   x91
2B66:  CLRF   x90
2B68:  CLRF   x93
2B6A:  CLRF   x92
2B6C:  CLRF   x95
2B6E:  CLRF   x94
2B70:  CLRF   x98
2B72:  CLRF   x99
2B74:  CLRF   x9A
2B76:  CLRF   xAD
2B78:  CLRF   xAE
2B7A:  CLRF   xB0
2B7C:  CLRF   xAF
2B7E:  CLRF   xB1
2B80:  CLRF   xB2
2B82:  CLRF   xB3
2B84:  CLRF   xB4
2B86:  CLRF   xF0
2B88:  CLRF   xF1
2B8A:  MOVF   FC1,W
2B8C:  ANDLW  C0
2B8E:  IORLW  0F
2B90:  MOVWF  FC1
2B92:  MOVLW  07
2B94:  MOVWF  FB4
2B96:  BRA    2C42
2B98:  DATA 02,00
2B9A:  DATA 19,00
2B9C:  DATA 00,05
2B9E:  DATA 01,08
2BA0:  DATA 56,35
2BA2:  DATA 2E,30
2BA4:  DATA 31,05
2BA6:  DATA C0,20
2BA8:  DATA 6E,80
2BAA:  DATA 0D,00
2BAC:  DATA 42,4F
2BAE:  DATA 52,52
2BB0:  DATA 41,52
2BB2:  DATA 5F,41
2BB4:  DATA 4C,4C
2BB6:  DATA 0D,00
2BB8:  DATA 47,52
2BBA:  DATA 41,42
2BBC:  DATA 41,52
2BBE:  DATA 5F,44
2BC0:  DATA 41,54
2BC2:  DATA 0D,00
2BC4:  DATA 4C,45
2BC6:  DATA 45,52
2BC8:  DATA 43,55
2BCA:  DATA 45,4E
2BCC:  DATA 54,41
2BCE:  DATA 0D,00
2BD0:  DATA 53,4F
2BD2:  DATA 4C,49
2BD4:  DATA 43,49
2BD6:  DATA 54,41
2BD8:  DATA 44,4F
2BDA:  DATA 0D,00
2BDC:  DATA 50,41
2BDE:  DATA 53,41
2BE0:  DATA 4A,45
2BE2:  DATA 52,4F
2BE4:  DATA 53,3A
2BE6:  DATA 0D,00
2BE8:  DATA 53,45
2BEA:  DATA 52,49
2BEC:  DATA 41,4C
2BEE:  DATA 54,45
2BF0:  DATA 53,54
2BF2:  DATA 0D,00
2BF4:  DATA 53,45
2BF6:  DATA 52,49
2BF8:  DATA 41,4C
2BFA:  DATA 5F,54
2BFC:  DATA 4F,4B
2BFE:  DATA 0D,00
2C00:  DATA 53,55
2C02:  DATA 42,49
2C04:  DATA 45,4E
2C06:  DATA 44,4F
2C08:  DATA 43,32
2C0A:  DATA 0D,00
2C0C:  DATA 53,49
2C0E:  DATA 4E,46
2C10:  DATA 55,4E
2C12:  DATA 43,49
2C14:  DATA 4F,4E
2C16:  DATA 0D,00
2C18:  DATA 0A,C0
2C1A:  DATA 20,02
2C1C:  DATA 80,0D
2C1E:  DATA 00,16
2C20:  DATA 00,F2
2C22:  DATA 08,01
2C24:  DATA 14,01
2C26:  DATA 20,01
2C28:  DATA 2C,01
2C2A:  DATA 38,01
2C2C:  DATA 44,01
2C2E:  DATA 50,01
2C30:  DATA 5C,01
2C32:  DATA 68,01
2C34:  DATA 74,01
2C36:  DATA 80,01
2C38:  DATA 06,01
2C3A:  DATA 8C,56
2C3C:  DATA 31,2E
2C3E:  DATA 30,30
2C40:  DATA 00,00
2C42:  MOVLW  00
2C44:  MOVWF  FF8
2C46:  MOVLW  2B
2C48:  MOVWF  FF7
2C4A:  MOVLW  98
2C4C:  MOVWF  FF6
2C4E:  TBLRD*+
2C50:  MOVF   FF5,W
2C52:  MOVWF  00
2C54:  XORLW  00
2C56:  BZ    2C7E
2C58:  TBLRD*+
2C5A:  MOVF   FF5,W
2C5C:  MOVWF  01
2C5E:  BTFSC  FE8.7
2C60:  BRA    2C6C
2C62:  ANDLW  0F
2C64:  MOVWF  FEA
2C66:  TBLRD*+
2C68:  MOVFF  FF5,FE9
2C6C:  BTFSC  01.6
2C6E:  TBLRD*+
2C70:  BTFSS  01.6
2C72:  TBLRD*+
2C74:  MOVFF  FF5,FEE
2C78:  DCFSNZ 00,F
2C7A:  BRA    2C4E
2C7C:  BRA    2C70
2C7E:  CLRF   FF8
.................... { 
....................    // Apaga entradas analogicas 
....................    setup_adc_ports(NO_ANALOGS); 
2C80:  MOVF   FC1,W
2C82:  ANDLW  C0
2C84:  IORLW  0F
2C86:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
2C88:  BCF    FC2.0
....................    lcd_init();                               // inicia LCD 
2C8A:  GOTO   04C0
....................    init_ext_eeprom();                        // Inicia EEPROM 
2C8E:  GOTO   0534
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); // Configura timer1:Reloj interno, preescaler=8 
2C92:  MOVLW  B5
2C94:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);            // Habilito interrupcin particular del TIMER1 
2C96:  BSF    F9D.0
....................    set_timer1(set_timer);                    // Setea cuenta para la interrupcion. 
2C98:  MOVLW  E7
2C9A:  MOVWF  FCF
2C9C:  MOVLW  96
2C9E:  MOVWF  FCE
....................    disable_interrupts(INT_EXT);              // desabilita interrupciones externas 
2CA0:  BCF    FF2.4
....................    enable_interrupts(GLOBAL);                // habilita interrupciones globales 
2CA2:  MOVLW  C0
2CA4:  IORWF  FF2,F
....................    ///**************************************************************************/// 
....................    ////////Confuguracion de PWM//////// 
....................    output_low(PIN_C2); // CCP1 
2CA6:  BCF    F94.2
2CA8:  BCF    F8B.2
....................    setup_ccp1(CCP_PWM); 
2CAA:  BCF    F94.2
2CAC:  BCF    F8B.2
2CAE:  MOVLW  0C
2CB0:  MOVWF  FBD
....................    setup_timer_2(t2_div_By_1, 131, 1); // frecuencia 38khz 
2CB2:  MOVLW  00
2CB4:  IORLW  04
2CB6:  MOVWF  FCA
2CB8:  MOVLW  83
2CBA:  MOVWF  FCB
....................    // set_pwm1_duty(26);//(5%) alto 
....................    set_pwm1_duty(279); //(10%) Parte alta del ciclo 
2CBC:  MOVLW  45
2CBE:  MOVWF  FBE
2CC0:  MOVF   FBD,W
2CC2:  ANDLW  CF
2CC4:  IORLW  30
2CC6:  MOVWF  FBD
....................    //////////////////////////////////// 
....................    ini = read_eeprom(100); // Carga estado de inicio 
2CC8:  MOVFF  FF2,1D1
2CCC:  BCF    FF2.7
2CCE:  MOVLW  64
2CD0:  MOVWF  FA9
2CD2:  BCF    FA6.6
2CD4:  BCF    FA6.7
2CD6:  BSF    FA6.0
2CD8:  MOVF   FA8,W
2CDA:  MOVLB  1
2CDC:  BTFSC  xD1.7
2CDE:  BSF    FF2.7
2CE0:  MOVWF  40
....................    if (ini != 1) 
2CE2:  DECFSZ 40,W
2CE4:  BRA    2CE8
2CE6:  BRA    2D1A
....................    {                        // Verifica si es la primera vez que se enciende el poste y graba configuracion inicial 
....................       write_eeprom(100, 1); // Graba inicio 
2CE8:  MOVF   FF2,W
2CEA:  MOVWF  00
2CEC:  BCF    FF2.7
2CEE:  MOVLW  64
2CF0:  MOVWF  FA9
2CF2:  MOVLW  01
2CF4:  MOVWF  FA8
2CF6:  BCF    FA6.6
2CF8:  BCF    FA6.7
2CFA:  BSF    FA6.2
2CFC:  MOVLB  F
2CFE:  MOVLW  55
2D00:  MOVWF  FA7
2D02:  MOVLW  AA
2D04:  MOVWF  FA7
2D06:  BSF    FA6.1
2D08:  BTFSC  FA6.1
2D0A:  BRA    2D08
2D0C:  BCF    FA6.2
2D0E:  MOVF   00,W
2D10:  IORWF  FF2,F
....................       limpiar();            // pone en 0 el registro de cuentas almacenadas. 
2D12:  MOVLB  0
2D14:  CALL   0D1A
2D18:  MOVLB  1
....................    } 
....................    ///////////////////////////////////////////////////////////////////////////////////////////////// 
....................    entraron_total();                            // carga el total de entradas registradas 
2D1A:  MOVLB  0
2D1C:  GOTO   0D86
....................    salieron_total();                            // carga el total de salidas registradas 
2D20:  GOTO   0DE0
....................    ent1 = ent2 = ent3 = ent4 = ent5 = ent6 = 0; // inicia en 0 variables de estado de sensores 
2D24:  CLRF   5A
2D26:  MOVFF  5A,59
2D2A:  MOVFF  59,58
2D2E:  MOVFF  58,57
2D32:  MOVFF  57,56
2D36:  MOVFF  56,55
....................    tim_p1 = tim_p2 = tim_p3 = 0;                // inicia en 0 las cuentas para detectar sensores bloqueados 
2D3A:  CLRF   xA6
2D3C:  CLRF   xA5
2D3E:  MOVFF  A6,A4
2D42:  MOVFF  A5,A3
2D46:  MOVFF  A4,A2
2D4A:  MOVFF  A3,A1
....................    en_b1 = en_b2 = en_b3 = 0;                   // bandera de pares bloqueados 
2D4E:  CLRF   xA0
2D50:  MOVFF  A0,9F
2D54:  MOVFF  9F,9E
....................    time_envio = 0;                              // inicia en 0 cuenta para transmitir datos 
2D58:  CLRF   xAA
2D5A:  CLRF   xA9
....................    if (input(frente)) 
2D5C:  BSF    F95.2
2D5E:  BTFSS  F83.2
2D60:  BRA    2D6C
....................    { // revisa si es maestro (1) o escalvo (2) 
....................       master = 1; 
2D62:  MOVLW  01
2D64:  MOVWF  45
....................       size_s = 29; 
2D66:  MOVLW  1D
2D68:  MOVWF  22
....................    } 
2D6A:  BRA    2D72
....................    else 
....................    { 
....................       master = 0; 
2D6C:  CLRF   45
....................       size_s = 15; 
2D6E:  MOVLW  0F
2D70:  MOVWF  22
....................    } 
....................    lcd_cuentas();                   // Escribe texto base en LCD 
2D72:  CALL   0A62
....................    cta_bloq1 = read_ext_eeprom(9);  // carga bloqueos acumulados en par1 
2D76:  MOVLB  1
2D78:  CLRF   xD6
2D7A:  MOVLW  09
2D7C:  MOVWF  xD5
2D7E:  MOVLB  0
2D80:  CALL   0772
2D84:  MOVFF  01,52
....................    cta_bloq2 = read_ext_eeprom(10); // carga bloqueos acumulados en par2 
2D88:  MOVLB  1
2D8A:  CLRF   xD6
2D8C:  MOVLW  0A
2D8E:  MOVWF  xD5
2D90:  MOVLB  0
2D92:  CALL   0772
2D96:  MOVFF  01,53
....................    cta_bloq3 = read_ext_eeprom(11); // carga bloqueos acumulados en par3 
2D9A:  MOVLB  1
2D9C:  CLRF   xD6
2D9E:  MOVLW  0B
2DA0:  MOVWF  xD5
2DA2:  MOVLB  0
2DA4:  CALL   0772
2DA8:  MOVFF  01,54
....................    int tem_res; 
....................    tem_res = input(rst_cta); // inicializa variable de reset de cuenta fisico 
2DAC:  BSF    F95.3
2DAE:  MOVLB  1
2DB0:  CLRF   xD0
2DB2:  BTFSC  F83.3
2DB4:  INCF   xD0,F
....................    j = 0; 
2DB6:  CLRF   43
....................    flag_enviar = 0; 
2DB8:  CLRF   46
....................    salian = 0; 
2DBA:  CLRF   3D
2DBC:  CLRF   3C
....................    enable_interrupts(INT_RDA); // habilita interrupcion serial 
2DBE:  BSF    F9D.5
....................    setup_wdt(WDT_ON);          // habilita watch dog 
2DC0:  BSF    FD1.0
....................    sub_cta1 = sub_cta2 = sub_cta3 = sub_cta4 = sub_cta5 = sub_cta6 = 0; 
2DC2:  MOVLB  0
2DC4:  CLRF   x68
2DC6:  CLRF   x67
2DC8:  MOVFF  68,66
2DCC:  MOVFF  67,65
2DD0:  MOVFF  66,64
2DD4:  MOVFF  65,63
2DD8:  MOVFF  64,62
2DDC:  MOVFF  63,61
2DE0:  MOVFF  62,60
2DE4:  MOVFF  61,5F
2DE8:  MOVFF  60,5E
2DEC:  MOVFF  5F,5D
....................    tem_entraront = tem_salieront = 0; 
2DF0:  CLRF   x95
2DF2:  CLRF   x94
2DF4:  MOVFF  95,93
2DF8:  MOVFF  94,92
....................    error = 0; 
2DFC:  CLRF   23
....................    reset(); // Revisa causa de inicio del pic 
2DFE:  GOTO   0E5C
....................    transmitir = 0; 
2E02:  CLRF   24
....................    output_low(salida02); 
2E04:  BCF    F94.4
2E06:  BCF    F8B.4
....................    output_low(salida03);      // se inicia relay apagado 
2E08:  BCF    F94.5
2E0A:  BCF    F8B.5
....................    sub_atras = baj_atras = 0; 
2E0C:  CLRF   37
2E0E:  CLRF   36
2E10:  MOVFF  37,35
2E14:  MOVFF  36,34
....................    clear_lcd1 = 0; 
2E18:  CLRF   xAB
....................  
....................    output_low(HB); // esperamos a que se aliste un dato del puerto serial emulado 
2E1A:  BCF    F96.0
2E1C:  BCF    F8D.0
....................    bandera_revision = 1; 
2E1E:  MOVLW  01
2E20:  MOVWF  xAE
....................    caso_valor = 0; 
2E22:  CLRF   xF0
....................  
....................    while (TRUE) 
....................    { 
....................       // solo para reinicializar interrupciones despues de obtener datos por puerto serial nato 
....................       if (y == 1) 
2E24:  DECFSZ xAD,W
2E26:  BRA    2E2E
....................       { 
....................          enable_interrupts(GLOBAL); // habilita interrupciones globales 
2E28:  MOVLW  C0
2E2A:  IORWF  FF2,F
....................          y = 0; 
2E2C:  CLRF   xAD
....................       } 
....................       //////////////////////boton para reset cuenta//////////////////////////////////////////// 
....................       if (tem_res != input(rst_cta)) 
2E2E:  BSF    F95.3
2E30:  MOVLW  00
2E32:  BTFSC  F83.3
2E34:  MOVLW  01
2E36:  MOVLB  1
2E38:  SUBWF  xD0,W
2E3A:  BZ    2E84
....................       { // BOTON DE RESET DE CUENTA 
....................          delay_ms(50); 
2E3C:  MOVLW  32
2E3E:  MOVWF  xDC
2E40:  MOVLB  0
2E42:  CALL   0408
....................          if (tem_res != input(rst_cta)) 
2E46:  BSF    F95.3
2E48:  MOVLW  00
2E4A:  BTFSC  F83.3
2E4C:  MOVLW  01
2E4E:  MOVLB  1
2E50:  SUBWF  xD0,W
2E52:  BZ    2E84
....................          { 
....................             tem_res = input(rst_cta); 
2E54:  BSF    F95.3
2E56:  CLRF   xD0
2E58:  BTFSC  F83.3
2E5A:  INCF   xD0,F
....................             if ((master == 1) && (tem_res == 0)) 
2E5C:  DECFSZ 45,W
2E5E:  BRA    2E84
2E60:  MOVF   xD0,F
2E62:  BNZ   2E84
....................             { 
....................                fprintf(monitor, "BORRAR_ALL\r"); 
2E64:  MOVLW  70
2E66:  MOVWF  FF6
2E68:  MOVLW  02
2E6A:  MOVWF  FF7
2E6C:  MOVLB  0
2E6E:  CALL   0E3A
....................                printf(lcd_putc, "\fBORRAR_ALL"); 
2E72:  MOVLW  7C
2E74:  MOVWF  FF6
2E76:  MOVLW  02
2E78:  MOVWF  FF7
2E7A:  CALL   0A42
....................                limpiar(); 
2E7E:  CALL   0D1A
2E82:  MOVLB  1
....................             } 
....................          } 
....................       } 
....................       //-------pines de monitoreo de datos seriales por puerto emulado---------------------------- 
....................       /* 
....................       if (input(EN) == 1 && bandera_revision == 1) 
....................       {                   // 1 
....................          output_high(HB); // avisa que ya est listo para recibir dato serial 
....................          cntbnd = 0; 
....................          // i=0; 
....................          bandera_revision = 0; 
....................          output_high(salida03); 
....................          // fprintf(monitor,"relay-"); 
....................          while (kbhit(GPS) != 1 || cntbnd >= 200) /// espera a que se complete dato serial o timer se agote 
....................          // while (XX[0]==0 || cntbnd >= 200) /// espera a que se complete dato serial o timer se agote 
....................          { 
....................             bandera_revision = 1; 
....................             // fprintf(monitor,"wh-"); 
....................          } 
....................          XX[0] = fgetc(GPS); 
....................  
....................          if (XX[0] == 63) 
....................          { 
....................             output_low(salida03); 
....................             j = 1; 
....................             sub_cta1 = sub_cta2 = sub_cta3 = sub_cta4 = sub_cta5 = sub_cta6 = 0; // se inicializa cuenta pasajeros 
....................             solicitud_reset_gps = 1; 
....................  
....................             strcpy(XX, "BORRAR_ALL\r"); // BORRAR_ALL\r 
....................             output_low(HB);             // se reinicia la espera de nuevo dato serial 
....................             bandera_revision = 1; 
....................          } 
....................       }*/ 
....................       //------------------------------------------------------------------------------ 
....................  
....................       if (j == 1) 
2E84:  DECFSZ 43,W
2E86:  BRA    3044
....................       {               // Revisa si hubo datos por cualquiera de los 2 puertos seriales 
....................          //rd_eeprom(); // valida dato recibido para ver si es una palabra de control 
....................          caso_valor = evaluar_string(XX); 
2E88:  MOVLW  01
2E8A:  MOVWF  xD2
2E8C:  MOVLW  92
2E8E:  MOVWF  xD1
2E90:  MOVLB  0
2E92:  GOTO   0F0E
2E96:  MOVFF  01,F0
....................          lcd_gotoxy(9, 1); 
2E9A:  MOVLW  09
2E9C:  MOVLB  1
2E9E:  MOVWF  xDC
2EA0:  MOVLW  01
2EA2:  MOVWF  xDD
2EA4:  MOVLB  0
2EA6:  CALL   086C
....................          printf(lcd_putc, "%d ", caso_valor); // pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
2EAA:  MOVFF  F0,1D1
2EAE:  MOVLW  18
2EB0:  MOVLB  1
2EB2:  MOVWF  xD2
2EB4:  MOVLB  0
2EB6:  CALL   0FC8
2EBA:  MOVLW  20
2EBC:  MOVLB  1
2EBE:  MOVWF  xDB
2EC0:  MOVLB  0
2EC2:  CALL   08BE
....................  
....................          switch (caso_valor) 
2EC6:  MOVF   xF0,W
2EC8:  XORLW  01
2ECA:  BZ    2EEC
2ECC:  XORLW  03
2ECE:  BZ    2F18
2ED0:  XORLW  01
2ED2:  BZ    2F1E
2ED4:  XORLW  07
2ED6:  BZ    2F5C
2ED8:  XORLW  01
2EDA:  BZ    2F62
2EDC:  XORLW  03
2EDE:  BZ    2F8A
2EE0:  XORLW  01
2EE2:  BZ    2FBA
2EE4:  XORLW  0F
2EE6:  BTFSC  FD8.2
2EE8:  BRA    2FDE
2EEA:  BRA    3006
....................          { 
....................          case 1: 
....................          { // Se pone en 0 la cuenta 
....................             limpiar(); 
2EEC:  CALL   0D1A
....................             if (master == 1) 
2EF0:  DECFSZ 45,W
2EF2:  BRA    2F00
....................                fprintf(monitor, "BORRAR_ALL\r"); // 4 
2EF4:  MOVLW  88
2EF6:  MOVWF  FF6
2EF8:  MOVLW  02
2EFA:  MOVWF  FF7
2EFC:  CALL   0E3A
....................             if (solicitud_reset_gps == 1 && master == 1) 
2F00:  DECFSZ xF1,W
2F02:  BRA    2F16
2F04:  DECFSZ 45,W
2F06:  BRA    2F16
....................             { 
....................                solicitud_reset_gps = 0; 
2F08:  CLRF   xF1
....................                fprintf(GPS, "RESET_OK\r\n"); // confirma a gsm 
2F0A:  MOVLW  94
2F0C:  MOVWF  FF6
2F0E:  MOVLW  02
2F10:  MOVWF  FF7
2F12:  CALL   10D2
....................             } 
....................             break; 
2F16:  BRA    3022
....................          } 
....................          case 2: 
....................          { // Se hace solicitud de cuenta del poste trasero 
....................             solicitar(); 
2F18:  CALL   10F2
....................             break; 
2F1C:  BRA    3022
....................          } 
....................          case 3: 
....................          { // Se pone en 0 la cuenta por peticion del GPRS 
....................             if (master == 1) 
2F1E:  DECFSZ 45,W
2F20:  BRA    2F2E
....................                fprintf(GPS, "RESET_OK\r\n"); // confirma a gsm 
2F22:  MOVLW  A0
2F24:  MOVWF  FF6
2F26:  MOVLW  02
2F28:  MOVWF  FF7
2F2A:  CALL   10D2
....................             delay_ms(1000); 
2F2E:  MOVLW  04
2F30:  MOVLB  1
2F32:  MOVWF  xD1
2F34:  MOVLW  FA
2F36:  MOVWF  xDC
2F38:  MOVLB  0
2F3A:  CALL   0408
2F3E:  MOVLB  1
2F40:  DECFSZ xD1,F
2F42:  BRA    2F34
....................             limpiar(); 
2F44:  MOVLB  0
2F46:  CALL   0D1A
....................             if (master == 1) 
2F4A:  DECFSZ 45,W
2F4C:  BRA    2F5A
....................                fprintf(monitor, "BORRAR_ALL\r"); // 4 
2F4E:  MOVLW  AC
2F50:  MOVWF  FF6
2F52:  MOVLW  02
2F54:  MOVWF  FF7
2F56:  CALL   0E3A
....................             break; 
2F5A:  BRA    3022
....................          } 
....................          case 4: 
....................          { // ver pasaje total de este acceso (contador atras) 
....................             envio_master(); 
2F5C:  CALL   110A
....................             break; 
2F60:  BRA    3022
....................          } 
....................          case 5: 
....................          { // envia a GPS pasaje total actual de ambos accesos (recibe cuenta de atras y suma) 
....................             flag_enviar = 0; 
2F62:  CLRF   46
....................             enviop1(); 
2F64:  GOTO   15C8
....................             transmitir = 1; 
2F68:  MOVLW  01
2F6A:  MOVWF  24
....................             lcd_gotoxy(9, 4); 
2F6C:  MOVLW  09
2F6E:  MOVLB  1
2F70:  MOVWF  xDC
2F72:  MOVLW  04
2F74:  MOVWF  xDD
2F76:  MOVLB  0
2F78:  CALL   086C
....................             lcd_putc("C2OK"); 
2F7C:  MOVLW  B8
2F7E:  MOVWF  FF6
2F80:  MOVLW  02
2F82:  MOVWF  FF7
2F84:  CALL   0A42
....................  
....................             break; 
2F88:  BRA    3022
....................          } 
....................          case 6: 
....................          { // TEST DE COMUNICACION SERIAL 
....................             clear_lcd1 = 1; 
2F8A:  MOVLW  01
2F8C:  MOVWF  xAB
....................             time_lcd1 = 0; 
2F8E:  CLRF   xAC
....................             lcd_gotoxy(9, 3); 
2F90:  MOVLW  09
2F92:  MOVLB  1
2F94:  MOVWF  xDC
2F96:  MOVLW  03
2F98:  MOVWF  xDD
2F9A:  MOVLB  0
2F9C:  CALL   086C
....................             lcd_putc("C1OK"); 
2FA0:  MOVLW  BE
2FA2:  MOVWF  FF6
2FA4:  MOVLW  02
2FA6:  MOVWF  FF7
2FA8:  CALL   0A42
....................             fprintf(monitor, "SERIAL_TOK\r"); // 
2FAC:  MOVLW  C4
2FAE:  MOVWF  FF6
2FB0:  MOVLW  02
2FB2:  MOVWF  FF7
2FB4:  CALL   0E3A
....................             break; 
2FB8:  BRA    3022
....................          } 
....................          case 7: 
....................          { // CONFIRMACION DE COMUNICACION SERIAL 
....................             clear_lcd1 = 1; 
2FBA:  MOVLW  01
2FBC:  MOVWF  xAB
....................             time_lcd1 = 0; 
2FBE:  CLRF   xAC
....................             lcd_gotoxy(9, 4); 
2FC0:  MOVLW  09
2FC2:  MOVLB  1
2FC4:  MOVWF  xDC
2FC6:  MOVLW  04
2FC8:  MOVWF  xDD
2FCA:  MOVLB  0
2FCC:  CALL   086C
....................             lcd_putc("C2OK"); 
2FD0:  MOVLW  D0
2FD2:  MOVWF  FF6
2FD4:  MOVLW  02
2FD6:  MOVWF  FF7
2FD8:  CALL   0A42
....................             break; 
2FDC:  BRA    3022
....................          } 
....................          case 8: 
....................          { // Suben por atras 
....................             clear_lcd1 = 1; 
2FDE:  MOVLW  01
2FE0:  MOVWF  xAB
....................             time_lcd1 = 0; 
2FE2:  CLRF   xAC
....................             lcd_gotoxy(9, 4); 
2FE4:  MOVLW  09
2FE6:  MOVLB  1
2FE8:  MOVWF  xDC
2FEA:  MOVLW  04
2FEC:  MOVWF  xDD
2FEE:  MOVLB  0
2FF0:  CALL   086C
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
2FF4:  CALL   1838
....................             lcd_putc("Sub2"); 
2FF8:  MOVLW  D6
2FFA:  MOVWF  FF6
2FFC:  MOVLW  02
2FFE:  MOVWF  FF7
3000:  CALL   0A42
....................             break; 
3004:  BRA    3022
....................          } 
....................          default: 
....................          { 
....................             lcd_gotoxy(9, 2); 
3006:  MOVLW  09
3008:  MOVLB  1
300A:  MOVWF  xDC
300C:  MOVLW  02
300E:  MOVWF  xDD
3010:  MOVLB  0
3012:  CALL   086C
....................             printf(lcd_putc, "c=0"); 
3016:  MOVLW  DC
3018:  MOVWF  FF6
301A:  MOVLW  02
301C:  MOVWF  FF7
301E:  CALL   0A42
....................          } 
....................          } // end switch 
....................  
....................          caso_valor = 0; 
3022:  CLRF   xF0
....................          memset(XX, 0, sizeof(XX)); 
3024:  MOVLW  01
3026:  MOVWF  FEA
3028:  MOVLW  92
302A:  MOVWF  FE9
302C:  CLRF   00
302E:  CLRF   02
3030:  MOVLW  20
3032:  MOVWF  01
3034:  CALL   1160
....................          time_clr = 0; 
3038:  CLRF   3F
303A:  CLRF   3E
....................          f_clr = 1; 
303C:  MOVLW  01
303E:  MOVWF  47
....................          j = 0; 
3040:  CLRF   43
3042:  MOVLB  1
....................       } 
....................       if ((time_envio >= 180) && (master)) 
3044:  MOVLB  0
3046:  MOVF   xAA,F
3048:  BNZ   3050
304A:  MOVF   xA9,W
304C:  SUBLW  B3
304E:  BC    3058
3050:  MOVF   45,F
3052:  BZ    3058
....................       { // Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
....................          solicitar(); 
3054:  CALL   10F2
....................       } 
....................       if ((clear_lcd1) && (time_lcd1 >= 10)) 
3058:  MOVF   xAB,F
305A:  BZ    30B8
305C:  MOVF   xAC,W
305E:  SUBLW  09
3060:  BC    30B8
....................       { // cronometro para limpiar notificaciones LCD 
....................          clear_lcd1 = 0; 
3062:  CLRF   xAB
....................          lcd_gotoxy(9, 1); 
3064:  MOVLW  09
3066:  MOVLB  1
3068:  MOVWF  xDC
306A:  MOVLW  01
306C:  MOVWF  xDD
306E:  MOVLB  0
3070:  CALL   086C
....................          lcd_putc("    "); 
3074:  MOVLW  E0
3076:  MOVWF  FF6
3078:  MOVLW  02
307A:  MOVWF  FF7
307C:  CALL   0A42
....................          lcd_gotoxy(9, 3); 
3080:  MOVLW  09
3082:  MOVLB  1
3084:  MOVWF  xDC
3086:  MOVLW  03
3088:  MOVWF  xDD
308A:  MOVLB  0
308C:  CALL   086C
....................          lcd_putc("    "); 
3090:  MOVLW  E6
3092:  MOVWF  FF6
3094:  MOVLW  02
3096:  MOVWF  FF7
3098:  CALL   0A42
....................          lcd_gotoxy(9, 4); 
309C:  MOVLW  09
309E:  MOVLB  1
30A0:  MOVWF  xDC
30A2:  MOVLW  04
30A4:  MOVWF  xDD
30A6:  MOVLB  0
30A8:  CALL   086C
....................          lcd_putc("    "); 
30AC:  MOVLW  EC
30AE:  MOVWF  FF6
30B0:  MOVLW  02
30B2:  MOVWF  FF7
30B4:  CALL   0A42
....................       } 
....................  
....................       if ((flag_enviar) && (cta_enviar >= 2000) && (master)) 
30B8:  MOVF   46,F
30BA:  BZ    30D4
30BC:  MOVF   4F,W
30BE:  SUBLW  06
30C0:  BC    30D4
30C2:  XORLW  FF
30C4:  BNZ   30CC
30C6:  MOVF   4E,W
30C8:  SUBLW  CF
30CA:  BC    30D4
30CC:  MOVF   45,F
30CE:  BZ    30D4
....................          envia2(); // Si el poste esclavo no contesta enviar sin conexion 
30D0:  GOTO   19BC
....................       if (transmitir) 
30D4:  MOVF   24,F
30D6:  BZ    30DC
....................          envio(); // cuando el esclavo reporto su cuenta, maestro prepara paquete para mandar a la nube 
30D8:  GOTO   1B12
....................  
....................       if ((bloq_p1) && (tim_p1 >= time_bloqueo) && (!en_b1)) 
30DC:  MOVF   x9B,F
30DE:  BZ    314C
30E0:  MOVF   xA2,W
30E2:  SUBLW  00
30E4:  BC    314C
30E6:  XORLW  FF
30E8:  BNZ   30F0
30EA:  MOVF   xA1,W
30EC:  SUBLW  F3
30EE:  BC    314C
30F0:  MOVF   x9E,F
30F2:  BNZ   314C
....................       {               // bloqueo de par 1 por ms de X segundos 
....................          bloq_p1 = 0; // bandera de par de sensores bloqueados detectando, no significa contador bloqueado 
30F4:  CLRF   x9B
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
30F6:  MOVF   x9E,F
30F8:  BNZ   3148
30FA:  MOVF   x9F,F
30FC:  BNZ   3148
30FE:  MOVF   xA0,F
3100:  BNZ   3148
....................          {                     // si no habia un bloqueo antes 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
3102:  MOVLW  0A
3104:  MOVLB  1
3106:  MOVWF  xDC
3108:  MOVLW  01
310A:  MOVWF  xDD
310C:  MOVLB  0
310E:  CALL   086C
....................             lcd_putc("BL"); 
3112:  MOVLW  F2
3114:  MOVWF  FF6
3116:  MOVLW  02
3118:  MOVWF  FF7
311A:  CALL   0A42
....................             cta_bloq1++; 
311E:  INCF   52,F
....................             write_ext_eeprom(9, cta_bloq1); // bloq1 
3120:  MOVLB  1
3122:  CLRF   xD6
3124:  MOVLW  09
3126:  MOVWF  xD5
3128:  MOVFF  52,1D7
312C:  MOVLB  0
312E:  CALL   05B2
....................             if ((master == 1) && (j == 0)) 
3132:  DECFSZ 45,W
3134:  BRA    3140
3136:  MOVF   43,F
3138:  BNZ   3140
....................                solicitar(); 
313A:  CALL   10F2
313E:  BRA    3148
....................             else if (j == 0) 
3140:  MOVF   43,F
3142:  BNZ   3148
....................                envio_master(); 
3144:  CALL   110A
....................          } 
....................          en_b1 = 1; // bandera de bloqueo detectado en par 1 
3148:  MOVLW  01
314A:  MOVWF  x9E
....................       } 
....................       if ((bloq_p2) && (tim_p2 >= time_bloqueo) && (!en_b2)) 
314C:  MOVF   x9C,F
314E:  BZ    31BC
3150:  MOVF   xA4,W
3152:  SUBLW  00
3154:  BC    31BC
3156:  XORLW  FF
3158:  BNZ   3160
315A:  MOVF   xA3,W
315C:  SUBLW  F3
315E:  BC    31BC
3160:  MOVF   x9F,F
3162:  BNZ   31BC
....................       { // bloqueo de par 2 por ms de X segundos 
....................          bloq_p2 = 0; 
3164:  CLRF   x9C
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
3166:  MOVF   x9E,F
3168:  BNZ   31B8
316A:  MOVF   x9F,F
316C:  BNZ   31B8
316E:  MOVF   xA0,F
3170:  BNZ   31B8
....................          { 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
3172:  MOVLW  0A
3174:  MOVLB  1
3176:  MOVWF  xDC
3178:  MOVLW  01
317A:  MOVWF  xDD
317C:  MOVLB  0
317E:  CALL   086C
....................             lcd_putc("BL"); 
3182:  MOVLW  F6
3184:  MOVWF  FF6
3186:  MOVLW  02
3188:  MOVWF  FF7
318A:  CALL   0A42
....................             cta_bloq2++; 
318E:  INCF   53,F
....................             write_ext_eeprom(10, cta_bloq2); // bloq2 
3190:  MOVLB  1
3192:  CLRF   xD6
3194:  MOVLW  0A
3196:  MOVWF  xD5
3198:  MOVFF  53,1D7
319C:  MOVLB  0
319E:  CALL   05B2
....................             if ((master == 1) && (j == 0)) 
31A2:  DECFSZ 45,W
31A4:  BRA    31B0
31A6:  MOVF   43,F
31A8:  BNZ   31B0
....................                solicitar(); 
31AA:  CALL   10F2
31AE:  BRA    31B8
....................             else if (j == 0) 
31B0:  MOVF   43,F
31B2:  BNZ   31B8
....................                envio_master(); 
31B4:  CALL   110A
....................          } 
....................          en_b2 = 1; 
31B8:  MOVLW  01
31BA:  MOVWF  x9F
....................       } 
....................       if ((bloq_p3) && (tim_p3 >= time_bloqueo) && (!en_b3)) 
31BC:  MOVF   x9D,F
31BE:  BZ    322C
31C0:  MOVF   xA6,W
31C2:  SUBLW  00
31C4:  BC    322C
31C6:  XORLW  FF
31C8:  BNZ   31D0
31CA:  MOVF   xA5,W
31CC:  SUBLW  F3
31CE:  BC    322C
31D0:  MOVF   xA0,F
31D2:  BNZ   322C
....................       { // bloqueo de par 3 por ms de X segundos 
....................          bloq_p3 = 0; 
31D4:  CLRF   x9D
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
31D6:  MOVF   x9E,F
31D8:  BNZ   3228
31DA:  MOVF   x9F,F
31DC:  BNZ   3228
31DE:  MOVF   xA0,F
31E0:  BNZ   3228
....................          { 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
31E2:  MOVLW  0A
31E4:  MOVLB  1
31E6:  MOVWF  xDC
31E8:  MOVLW  01
31EA:  MOVWF  xDD
31EC:  MOVLB  0
31EE:  CALL   086C
....................             lcd_putc("BL"); 
31F2:  MOVLW  FA
31F4:  MOVWF  FF6
31F6:  MOVLW  02
31F8:  MOVWF  FF7
31FA:  CALL   0A42
....................             cta_bloq3++; 
31FE:  INCF   54,F
....................             write_ext_eeprom(11, cta_bloq3); // bloq3 
3200:  MOVLB  1
3202:  CLRF   xD6
3204:  MOVLW  0B
3206:  MOVWF  xD5
3208:  MOVFF  54,1D7
320C:  MOVLB  0
320E:  CALL   05B2
....................             if ((master == 1) && (j == 0)) 
3212:  DECFSZ 45,W
3214:  BRA    3220
3216:  MOVF   43,F
3218:  BNZ   3220
....................                solicitar(); 
321A:  CALL   10F2
321E:  BRA    3228
....................             else if (j == 0) 
3220:  MOVF   43,F
3222:  BNZ   3228
....................                envio_master(); 
3224:  CALL   110A
....................          } 
....................          en_b3 = 1; 
3228:  MOVLW  01
322A:  MOVWF  xA0
....................       } // end deteccion 
....................       if ((!bloq_p3) && (!bloq_p2) && (!bloq_p1)) 
322C:  MOVF   x9D,F
322E:  BNZ   3254
3230:  MOVF   x9C,F
3232:  BNZ   3254
3234:  MOVF   x9B,F
3236:  BNZ   3254
....................       { // Si todos los pares estan desbloqueados limpia estado de bloqueo LCD 
....................          lcd_gotoxy(10, 1); 
3238:  MOVLW  0A
323A:  MOVLB  1
323C:  MOVWF  xDC
323E:  MOVLW  01
3240:  MOVWF  xDD
3242:  MOVLB  0
3244:  CALL   086C
....................          lcd_putc("  "); 
3248:  MOVLW  FE
324A:  MOVWF  FF6
324C:  MOVLW  02
324E:  MOVWF  FF7
3250:  CALL   0A42
....................       } 
....................  
....................       if ((time_clr >= 900) && (f_clr)) 
3254:  MOVF   3F,W
3256:  SUBLW  02
3258:  BC    326E
325A:  XORLW  FF
325C:  BNZ   3264
325E:  MOVF   3E,W
3260:  SUBLW  83
3262:  BC    326E
3264:  MOVF   47,F
3266:  BZ    326E
....................       { // refresca LCD 
....................          lcd_cuentas(); 
3268:  CALL   0A62
....................          f_clr = 0; 
326C:  CLRF   47
....................       } 
....................       sensores(); // Revisa estado de los sensores 
326E:  GOTO   275E
....................       ////////////////// verificar si ya conto el pasajero y enviar pulso por relay ////////////////////////////////////////// 
....................       if ((nuevo_pulso) && (time_s3 >= 100)) 
3272:  MOVF   xB1,F
3274:  BZ    328C
3276:  MOVF   xB2,W
3278:  SUBLW  63
327A:  BC    328C
....................       { // Nuevo Pulso de subida para impresion (flanco alto) 
....................          nuevo_pulso = 0; 
327C:  CLRF   xB1
....................          fls3 = 1; 
327E:  MOVLW  01
3280:  MOVWF  xB3
....................          time_s3 = 0; 
3282:  CLRF   xB2
....................          output_high(salida03); 
3284:  BCF    F94.5
3286:  BSF    F8B.5
....................          rev_suben(); 
3288:  CALL   1826
....................       } 
....................       ///////////////apagar pulso de relay///////////////////////////////////////////////////////////////////////////////////// 
....................       if ((time_s3 >= 10) && (fls3)) 
328C:  MOVF   xB2,W
328E:  SUBLW  09
3290:  BC    32A8
3292:  MOVF   xB3,F
3294:  BZ    32A8
....................       { // Pulsos de subida para impresion (flanco bajo) 
....................          output_low(salida03); 
3296:  BCF    F94.5
3298:  BCF    F8B.5
....................          cta_pulsos--; 
329A:  DECF   xB4,F
....................          if (cta_pulsos > 0) 
329C:  MOVF   xB4,F
329E:  BZ    32A4
....................             nuevo_pulso = 1; 
32A0:  MOVLW  01
32A2:  MOVWF  xB1
....................          fls3 = 0; 
32A4:  CLRF   xB3
....................          time_s3 = 0; 
32A6:  CLRF   xB2
....................       } 
....................       ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................       restart_wdt(); 
32A8:  CLRWDT
32AA:  BRA    2E24
....................    } // end true 
.................... } // end main 
....................  
32AC:  SLEEP 
.................... void solicitar() 
.................... {                                    // Solicita cuenta al poste esclavo 
....................    fprintf(monitor, "SOLICITADO\r"); // 4 
*
10F2:  MOVLW  02
10F4:  MOVWF  FF6
10F6:  MOVLW  03
10F8:  MOVWF  FF7
10FA:  RCALL  0E3A
....................    time_envio = 0; 
10FC:  CLRF   xAA
10FE:  CLRF   xA9
....................    flag_enviar = 1; 
1100:  MOVLW  01
1102:  MOVWF  46
....................    cta_enviar = 0; 
1104:  CLRF   4F
1106:  CLRF   4E
1108:  RETURN 0
.................... } 
....................  
.................... void envio_master() 
.................... { // reporta al maestro 
....................    int16 envit; 
....................    envit = (entraront + salieront) / 2; 
110A:  MOVF   x8C,W
110C:  ADDWF  x8A,W
110E:  MOVLB  1
1110:  MOVWF  xD3
1112:  MOVLB  0
1114:  MOVF   x8D,W
1116:  ADDWFC x8B,W
1118:  MOVLB  1
111A:  MOVWF  xD4
111C:  BCF    FD8.0
111E:  RRCF   xD4,W
1120:  MOVWF  xD2
1122:  RRCF   xD3,W
1124:  MOVWF  xD1
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
1126:  MOVF   53,W
1128:  ADDWF  52,W
112A:  ADDWF  54,W
112C:  MOVWF  4C
112E:  CLRF   4D
....................    clear_lcd1 = 1; 
1130:  MOVLW  01
1132:  MOVLB  0
1134:  MOVWF  xAB
....................    time_lcd1 = 0; 
1136:  CLRF   xAC
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
1138:  MOVLW  09
113A:  MOVLB  1
113C:  MOVWF  xDC
113E:  MOVLW  03
1140:  MOVWF  xDD
1142:  MOVLB  0
1144:  CALL   086C
....................    lcd_putc(0xAB); 
1148:  MOVLW  AB
114A:  MOVLB  1
114C:  MOVWF  xDB
114E:  MOVLB  0
1150:  CALL   08BE
....................    // fprintf(monitor,"PASAJEROS:%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
....................    fprintf(monitor, "PASAJEROS:\r"); 
1154:  MOVLW  0E
1156:  MOVWF  FF6
1158:  MOVLW  03
115A:  MOVWF  FF7
115C:  RCALL  0E3A
115E:  RETURN 0
.................... } 
....................  
.................... /* 
.................... int convertir_to_entero(char *cadena) 
.................... { 
....................    int valor = 0; 
....................    if (cadena == '0') 
....................       valor = 0; 
....................    else if (cadena == '1') 
....................       valor = 1; 
....................    else if (cadena == '2') 
....................       valor = 2; 
....................    else if (cadena == '3') 
....................       valor = 3; 
....................    else if (cadena == '4') 
....................       valor = 4; 
....................    else if (cadena == '5') 
....................       valor = 5; 
....................    else if (cadena == '6') 
....................       valor = 6; 
....................    else if (cadena == '7') 
....................       valor = 7; 
....................    else if (cadena == '8') 
....................       valor = 8; 
....................    else if (cadena == '9') 
....................       valor = 9; 
....................    return valor; 
.................... } 
.................... */ 
....................  
.................... void enviop1() 
.................... { // Convierte a enteros la cadena recibida por el poste esclavo 
....................    disable_interrupts(INT_RDA); 
*
15C8:  BCF    F9D.5
....................    entran1 = 0; 
15CA:  CLRF   39
15CC:  CLRF   38
....................    salen1 = 0; 
15CE:  CLRF   3B
15D0:  CLRF   3A
....................    temporal1 = 0; 
15D2:  CLRF   2F
15D4:  CLRF   2E
....................    temporal2 = 0; 
15D6:  CLRF   31
15D8:  CLRF   30
....................    temporal3 = 0; 
15DA:  CLRF   x97
15DC:  CLRF   x96
....................    tempo_tn = 0; 
15DE:  CLRF   33
15E0:  CLRF   32
....................    pasajet = 0; 
15E2:  CLRF   x91
15E4:  CLRF   x90
....................    memset(entran, 0, sizeof(entran));       // entran=0; 
15E6:  MOVLW  01
15E8:  MOVWF  FEA
15EA:  MOVLW  B2
15EC:  MOVWF  FE9
15EE:  CLRF   00
15F0:  CLRF   02
15F2:  MOVLW  05
15F4:  MOVWF  01
15F6:  RCALL  1160
....................    memset(salen, 0, sizeof(salen));         // salen=0; 
15F8:  MOVLW  01
15FA:  MOVWF  FEA
15FC:  MOVLW  B7
15FE:  MOVWF  FE9
1600:  CLRF   00
1602:  CLRF   02
1604:  MOVLW  05
1606:  MOVWF  01
1608:  RCALL  1160
....................    memset(bloqueado, 0, sizeof(bloqueado)); // bloqueado=0; 
160A:  MOVLW  01
160C:  MOVWF  FEA
160E:  MOVLW  BC
1610:  MOVWF  FE9
1612:  CLRF   00
1614:  CLRF   02
1616:  MOVLW  05
1618:  MOVWF  01
161A:  RCALL  1160
....................    memset(bloqueado, 0, sizeof(tempo_tc));  // total 
161C:  MOVLW  01
161E:  MOVWF  FEA
1620:  MOVLW  BC
1622:  MOVWF  FE9
1624:  CLRF   00
1626:  CLRF   02
1628:  MOVLW  05
162A:  MOVWF  01
162C:  RCALL  1160
....................    i = 10; 
162E:  MOVLW  0A
1630:  MOVWF  41
....................    ii = 0; 
1632:  CLRF   42
....................    strcpy(term, ":/"); 
1634:  CLRF   FEA
1636:  MOVLW  B5
1638:  MOVWF  FE9
163A:  MOVLW  00
163C:  CALL   00DA
1640:  TBLRD*-
1642:  TBLRD*+
1644:  MOVF   FF5,W
1646:  MOVWF  FEE
1648:  IORLW  00
164A:  BNZ   1642
....................    ptr = strtok(XX, term); 
164C:  MOVLW  01
164E:  MOVLB  1
1650:  MOVWF  xD3
1652:  MOVLW  92
1654:  MOVWF  xD2
1656:  CLRF   xD5
1658:  MOVLW  B5
165A:  MOVWF  xD4
165C:  MOVLB  0
165E:  RCALL  1284
1660:  MOVFF  02,B9
1664:  MOVFF  01,B8
....................  
....................    int conteo_wl = 0; 
1668:  MOVLB  1
166A:  CLRF   xD1
....................  
....................    strcpy(data1, ptr);                // 1ra Palabra 
166C:  CLRF   FEA
166E:  MOVLW  BA
1670:  MOVWF  FE9
1672:  MOVFF  B9,FE2
1676:  MOVFF  B8,FE1
167A:  MOVF   FE7,F
167C:  MOVFF  FE6,FEE
1680:  BNZ   167A
....................    strcpy(data2, strtok(NULL, term)); // 2ra Palabra 
1682:  CLRF   xD3
1684:  CLRF   xD2
1686:  CLRF   xD5
1688:  MOVLW  B5
168A:  MOVWF  xD4
168C:  MOVLB  0
168E:  RCALL  1284
1690:  MOVFF  02,1D3
1694:  MOVFF  01,1D2
1698:  CLRF   FEA
169A:  MOVLW  C8
169C:  MOVWF  FE9
169E:  MOVFF  02,FE2
16A2:  MOVFF  01,FE1
16A6:  MOVF   FE7,F
16A8:  MOVFF  FE6,FEE
16AC:  BNZ   16A6
....................    strcpy(data3, strtok(NULL, term)); // 3ra Palabra 
16AE:  MOVLB  1
16B0:  CLRF   xD3
16B2:  CLRF   xD2
16B4:  CLRF   xD5
16B6:  MOVLW  B5
16B8:  MOVWF  xD4
16BA:  MOVLB  0
16BC:  RCALL  1284
16BE:  MOVFF  02,1D3
16C2:  MOVFF  01,1D2
16C6:  CLRF   FEA
16C8:  MOVLW  D2
16CA:  MOVWF  FE9
16CC:  MOVFF  02,FE2
16D0:  MOVFF  01,FE1
16D4:  MOVF   FE7,F
16D6:  MOVFF  FE6,FEE
16DA:  BNZ   16D4
....................    strcpy(data4, strtok(NULL, term)); // 4ra Palabra 
16DC:  MOVLB  1
16DE:  CLRF   xD3
16E0:  CLRF   xD2
16E2:  CLRF   xD5
16E4:  MOVLW  B5
16E6:  MOVWF  xD4
16E8:  MOVLB  0
16EA:  RCALL  1284
16EC:  MOVFF  02,1D3
16F0:  MOVFF  01,1D2
16F4:  CLRF   FEA
16F6:  MOVLW  DC
16F8:  MOVWF  FE9
16FA:  MOVFF  02,FE2
16FE:  MOVFF  01,FE1
1702:  MOVF   FE7,F
1704:  MOVFF  FE6,FEE
1708:  BNZ   1702
....................    strcpy(data5, strtok(NULL, term)); // 5ra Palabra 
170A:  MOVLB  1
170C:  CLRF   xD3
170E:  CLRF   xD2
1710:  CLRF   xD5
1712:  MOVLW  B5
1714:  MOVWF  xD4
1716:  MOVLB  0
1718:  RCALL  1284
171A:  MOVFF  02,1D3
171E:  MOVFF  01,1D2
1722:  CLRF   FEA
1724:  MOVLW  E6
1726:  MOVWF  FE9
1728:  MOVFF  02,FE2
172C:  MOVFF  01,FE1
1730:  MOVF   FE7,F
1732:  MOVFF  FE6,FEE
1736:  BNZ   1730
....................    ptr = strtok(0, term); 
1738:  MOVLB  1
173A:  CLRF   xD3
173C:  CLRF   xD2
173E:  CLRF   xD5
1740:  MOVLW  B5
1742:  MOVWF  xD4
1744:  MOVLB  0
1746:  RCALL  1284
1748:  MOVFF  02,B9
174C:  MOVFF  01,B8
....................  
....................    conteo_wl++; 
1750:  MOVLB  1
1752:  INCF   xD1,F
....................    sub_atras = atoi32(data2); 
1754:  CLRF   xD3
1756:  MOVLW  C8
1758:  MOVWF  xD2
175A:  MOVLB  0
175C:  RCALL  1334
175E:  MOVFF  01,35
1762:  MOVFF  00,34
....................    baj_atras = atoi32(data3); 
1766:  MOVLB  1
1768:  CLRF   xD3
176A:  MOVLW  D2
176C:  MOVWF  xD2
176E:  MOVLB  0
1770:  RCALL  1334
1772:  MOVFF  01,37
1776:  MOVFF  00,36
....................    temporal3 = atoi32(data4); 
177A:  MOVLB  1
177C:  CLRF   xD3
177E:  MOVLW  DC
1780:  MOVWF  xD2
1782:  MOVLB  0
1784:  RCALL  1334
1786:  MOVFF  01,97
178A:  MOVFF  00,96
....................    tempo_tn = atoi32(data5); 
178E:  MOVLB  1
1790:  CLRF   xD3
1792:  MOVLW  E6
1794:  MOVWF  xD2
1796:  MOVLB  0
1798:  RCALL  1334
179A:  MOVFF  01,33
179E:  MOVFF  00,32
....................  
....................    lcd_gotoxy(14, 3); 
17A2:  MOVLW  0E
17A4:  MOVLB  1
17A6:  MOVWF  xDC
17A8:  MOVLW  03
17AA:  MOVWF  xDD
17AC:  MOVLB  0
17AE:  CALL   086C
....................    printf(lcd_putc, "S2:%Ld ", sub_atras); 
17B2:  MOVLW  1A
17B4:  MOVWF  FF6
17B6:  MOVLW  03
17B8:  MOVWF  FF7
17BA:  MOVLW  03
17BC:  MOVLB  1
17BE:  MOVWF  xD2
17C0:  MOVLB  0
17C2:  CALL   091E
17C6:  MOVLW  10
17C8:  MOVWF  FE9
17CA:  MOVFF  35,1D3
17CE:  MOVFF  34,1D2
17D2:  CALL   0946
17D6:  MOVLW  20
17D8:  MOVLB  1
17DA:  MOVWF  xDB
17DC:  MOVLB  0
17DE:  CALL   08BE
....................    lcd_gotoxy(14, 4); 
17E2:  MOVLW  0E
17E4:  MOVLB  1
17E6:  MOVWF  xDC
17E8:  MOVLW  04
17EA:  MOVWF  xDD
17EC:  MOVLB  0
17EE:  CALL   086C
....................    printf(lcd_putc, "B2:%Ld ", baj_atras); 
17F2:  MOVLW  22
17F4:  MOVWF  FF6
17F6:  MOVLW  03
17F8:  MOVWF  FF7
17FA:  MOVLW  03
17FC:  MOVLB  1
17FE:  MOVWF  xD2
1800:  MOVLB  0
1802:  CALL   091E
1806:  MOVLW  10
1808:  MOVWF  FE9
180A:  MOVFF  37,1D3
180E:  MOVFF  36,1D2
1812:  CALL   0946
1816:  MOVLW  20
1818:  MOVLB  1
181A:  MOVWF  xDB
181C:  MOVLB  0
181E:  CALL   08BE
1822:  GOTO   2F68 (RETURN)
.................... } 
....................  
.................... void envio() 
.................... { // crea paquete para enviar al modulo GPRS 
....................    ////////////// Detectando envio total 
....................  
....................    temporal1 = sub_atras; 
*
1B12:  MOVFF  35,2F
1B16:  MOVFF  34,2E
....................    temporal2 = baj_atras; 
1B1A:  MOVFF  37,31
1B1E:  MOVFF  36,30
....................    entran1 = (entraront + salieront) / 2; 
1B22:  MOVF   x8C,W
1B24:  ADDWF  x8A,W
1B26:  MOVLB  1
1B28:  MOVWF  xD1
1B2A:  MOVLB  0
1B2C:  MOVF   x8D,W
1B2E:  ADDWFC x8B,W
1B30:  MOVLB  1
1B32:  MOVWF  xD2
1B34:  BCF    FD8.0
1B36:  RRCF   xD2,W
1B38:  MOVWF  39
1B3A:  RRCF   xD1,W
1B3C:  MOVWF  38
....................  
....................    total2_t = (temporal1 + temporal2) / 2; 
1B3E:  MOVF   30,W
1B40:  ADDWF  2E,W
1B42:  MOVWF  xD1
1B44:  MOVF   31,W
1B46:  ADDWFC 2F,W
1B48:  MOVWF  xD2
1B4A:  BCF    FD8.0
1B4C:  RRCF   xD2,W
1B4E:  MOVWF  51
1B50:  RRCF   xD1,W
1B52:  MOVWF  50
....................  
....................    leer_conta2(); 
1B54:  MOVLB  0
1B56:  CALL   081A
....................    if (total2_t == tempo_tn) 
1B5A:  MOVF   32,W
1B5C:  SUBWF  50,W
1B5E:  BNZ   1B7E
1B60:  MOVF   33,W
1B62:  SUBWF  51,W
1B64:  BNZ   1B7E
....................    { // dato recibido correcto 
....................       salian = salen1 = total2_t; 
1B66:  MOVFF  51,3B
1B6A:  MOVFF  50,3A
1B6E:  MOVFF  3B,3D
1B72:  MOVFF  3A,3C
....................       graba_conta2(); 
1B76:  CALL   06B8
....................       error = 0; 
1B7A:  CLRF   23
....................    } 
1B7C:  BRA    1B82
....................    else 
....................       error = 2; 
1B7E:  MOVLW  02
1B80:  MOVWF  23
....................    ///////////// 
....................    pasajet = entran1 + salen1; 
1B82:  MOVF   3A,W
1B84:  ADDWF  38,W
1B86:  MOVWF  x90
1B88:  MOVF   3B,W
1B8A:  ADDWFC 39,W
1B8C:  MOVWF  x91
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
1B8E:  MOVF   53,W
1B90:  ADDWF  52,W
1B92:  ADDWF  54,W
1B94:  MOVWF  4C
1B96:  CLRF   4D
....................    // fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,temporal1,temporal2,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS, "ACC+01:%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n", pasajet, entran1, salen1, cta_bloqueo, temporal3, error); 
1B98:  MOVLW  2A
1B9A:  MOVWF  FF6
1B9C:  MOVLW  03
1B9E:  MOVWF  FF7
1BA0:  MOVLW  07
1BA2:  MOVLB  1
1BA4:  MOVWF  xD1
1BA6:  MOVLB  0
1BA8:  RCALL  1848
1BAA:  MOVLW  09
1BAC:  MOVWF  FE9
1BAE:  MOVFF  91,1D2
1BB2:  MOVFF  90,1D1
1BB6:  RCALL  1870
1BB8:  MOVLW  2C
1BBA:  MOVLB  1
1BBC:  MOVWF  xDA
1BBE:  MOVLB  0
1BC0:  CALL   1084
1BC4:  MOVLW  09
1BC6:  MOVWF  FE9
1BC8:  MOVFF  39,1D2
1BCC:  MOVFF  38,1D1
1BD0:  RCALL  1870
1BD2:  MOVLW  2C
1BD4:  MOVLB  1
1BD6:  MOVWF  xDA
1BD8:  MOVLB  0
1BDA:  CALL   1084
1BDE:  MOVLW  09
1BE0:  MOVWF  FE9
1BE2:  MOVFF  3B,1D2
1BE6:  MOVFF  3A,1D1
1BEA:  RCALL  1870
1BEC:  MOVLW  2C
1BEE:  MOVLB  1
1BF0:  MOVWF  xDA
1BF2:  MOVLB  0
1BF4:  CALL   1084
1BF8:  MOVLW  0A
1BFA:  MOVWF  FE9
1BFC:  MOVFF  4D,1D2
1C00:  MOVFF  4C,1D1
1C04:  RCALL  1870
1C06:  MOVLW  2C
1C08:  MOVLB  1
1C0A:  MOVWF  xDA
1C0C:  MOVLB  0
1C0E:  CALL   1084
1C12:  MOVLW  0A
1C14:  MOVWF  FE9
1C16:  MOVFF  97,1D2
1C1A:  MOVFF  96,1D1
1C1E:  RCALL  1870
1C20:  MOVLW  2C
1C22:  MOVLB  1
1C24:  MOVWF  xDA
1C26:  MOVLB  0
1C28:  CALL   1084
1C2C:  MOVFF  23,1D1
1C30:  MOVLW  01
1C32:  MOVLB  1
1C34:  MOVWF  xD2
1C36:  MOVLB  0
1C38:  RCALL  1936
1C3A:  MOVLW  53
1C3C:  MOVWF  FF6
1C3E:  MOVLW  03
1C40:  MOVWF  FF7
1C42:  MOVLW  03
1C44:  MOVLB  1
1C46:  MOVWF  xD1
1C48:  MOVLB  0
1C4A:  RCALL  1848
....................    lcd_cuentas(); 
1C4C:  CALL   0A62
....................  
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
1C50:  MOVLW  09
1C52:  MOVLB  1
1C54:  MOVWF  xDC
1C56:  MOVLW  03
1C58:  MOVWF  xDD
1C5A:  MOVLB  0
1C5C:  CALL   086C
....................    lcd_putc(0xAB); 
1C60:  MOVLW  AB
1C62:  MOVLB  1
1C64:  MOVWF  xDB
1C66:  MOVLB  0
1C68:  CALL   08BE
....................  
....................    clear_lcd1 = 1; 
1C6C:  MOVLW  01
1C6E:  MOVWF  xAB
....................    time_lcd1 = 0; 
1C70:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio = 0; // reinicia el tiempo para el siguiente envio 
1C72:  CLRF   xAA
1C74:  CLRF   xA9
....................    transmitir = 0; 
1C76:  CLRF   24
....................    enable_interrupts(INT_RDA); 
1C78:  BSF    F9D.5
1C7A:  GOTO   30DC (RETURN)
.................... } 
....................  
.................... void envia2() 
.................... { // Crea paquete para enviar a modulo GPRS cuando no hay conexion con esclavo 
....................    disable_interrupts(INT_RDA); 
*
19BC:  BCF    F9D.5
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
19BE:  MOVF   53,W
19C0:  ADDWF  52,W
19C2:  ADDWF  54,W
19C4:  MOVWF  4C
19C6:  CLRF   4D
....................    memset(entran, 0, sizeof(entran));       // entran=0; 
19C8:  MOVLW  01
19CA:  MOVWF  FEA
19CC:  MOVLW  B2
19CE:  MOVWF  FE9
19D0:  CLRF   00
19D2:  CLRF   02
19D4:  MOVLW  05
19D6:  MOVWF  01
19D8:  CALL   1160
....................    memset(salen, 0, sizeof(salen));         // salen=0; 
19DC:  MOVLW  01
19DE:  MOVWF  FEA
19E0:  MOVLW  B7
19E2:  MOVWF  FE9
19E4:  CLRF   00
19E6:  CLRF   02
19E8:  MOVLW  05
19EA:  MOVWF  01
19EC:  CALL   1160
....................    memset(bloqueado, 0, sizeof(bloqueado)); // bloqueado=0; 
19F0:  MOVLW  01
19F2:  MOVWF  FEA
19F4:  MOVLW  BC
19F6:  MOVWF  FE9
19F8:  CLRF   00
19FA:  CLRF   02
19FC:  MOVLW  05
19FE:  MOVWF  01
1A00:  CALL   1160
....................    i = 10; 
1A04:  MOVLW  0A
1A06:  MOVWF  41
....................    ii = 0; 
1A08:  CLRF   42
....................    entran1 = (entraront + salieront) / 2; 
1A0A:  MOVF   x8C,W
1A0C:  ADDWF  x8A,W
1A0E:  MOVLB  1
1A10:  MOVWF  xD1
1A12:  MOVLB  0
1A14:  MOVF   x8D,W
1A16:  ADDWFC x8B,W
1A18:  MOVLB  1
1A1A:  MOVWF  xD2
1A1C:  BCF    FD8.0
1A1E:  RRCF   xD2,W
1A20:  MOVWF  39
1A22:  RRCF   xD1,W
1A24:  MOVWF  38
....................    leer_conta2(); 
1A26:  MOVLB  0
1A28:  CALL   081A
....................    pasajet = entran1 + salian; 
1A2C:  MOVF   3C,W
1A2E:  ADDWF  38,W
1A30:  MOVWF  x90
1A32:  MOVF   3D,W
1A34:  ADDWFC 39,W
1A36:  MOVWF  x91
....................    error = 1; 
1A38:  MOVLW  01
1A3A:  MOVWF  23
....................    // fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,DESC,DESC,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS, "ACC+01:%04Lu,%04Lu,DESC,%03Lu,000,%02u,\r\n", pasajet, entran1, cta_bloqueo, error); 
1A3C:  MOVLW  58
1A3E:  MOVWF  FF6
1A40:  MOVLW  03
1A42:  MOVWF  FF7
1A44:  MOVLW  07
1A46:  MOVLB  1
1A48:  MOVWF  xD1
1A4A:  MOVLB  0
1A4C:  RCALL  1848
1A4E:  MOVLW  09
1A50:  MOVWF  FE9
1A52:  MOVFF  91,1D2
1A56:  MOVFF  90,1D1
1A5A:  RCALL  1870
1A5C:  MOVLW  2C
1A5E:  MOVLB  1
1A60:  MOVWF  xDA
1A62:  MOVLB  0
1A64:  CALL   1084
1A68:  MOVLW  09
1A6A:  MOVWF  FE9
1A6C:  MOVFF  39,1D2
1A70:  MOVFF  38,1D1
1A74:  RCALL  1870
1A76:  MOVLW  6A
1A78:  MOVWF  FF6
1A7A:  MOVLW  03
1A7C:  MOVWF  FF7
1A7E:  MOVLW  06
1A80:  MOVLB  1
1A82:  MOVWF  xD1
1A84:  MOVLB  0
1A86:  RCALL  1848
1A88:  MOVLW  0A
1A8A:  MOVWF  FE9
1A8C:  MOVFF  4D,1D2
1A90:  MOVFF  4C,1D1
1A94:  RCALL  1870
1A96:  MOVLW  75
1A98:  MOVWF  FF6
1A9A:  MOVLW  03
1A9C:  MOVWF  FF7
1A9E:  MOVLW  05
1AA0:  MOVLB  1
1AA2:  MOVWF  xD1
1AA4:  MOVLB  0
1AA6:  RCALL  1848
1AA8:  MOVFF  23,1D1
1AAC:  MOVLW  01
1AAE:  MOVLB  1
1AB0:  MOVWF  xD2
1AB2:  MOVLB  0
1AB4:  RCALL  1936
1AB6:  MOVLW  7E
1AB8:  MOVWF  FF6
1ABA:  MOVLW  03
1ABC:  MOVWF  FF7
1ABE:  MOVLW  03
1AC0:  MOVLB  1
1AC2:  MOVWF  xD1
1AC4:  MOVLB  0
1AC6:  RCALL  1848
....................    //!   lcd_gotoxy(1,4); 
....................    //!   printf(lcd_putc,"T:%04Lu BS:%03Lu ",pasajet,cta_bloqueo); 
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
1AC8:  MOVLW  09
1ACA:  MOVLB  1
1ACC:  MOVWF  xDC
1ACE:  MOVLW  03
1AD0:  MOVWF  xDD
1AD2:  MOVLB  0
1AD4:  CALL   086C
....................    lcd_putc(0xAB); 
1AD8:  MOVLW  AB
1ADA:  MOVLB  1
1ADC:  MOVWF  xDB
1ADE:  MOVLB  0
1AE0:  CALL   08BE
....................    lcd_gotoxy(9, 4); // cronometro para limpiar 
1AE4:  MOVLW  09
1AE6:  MOVLB  1
1AE8:  MOVWF  xDC
1AEA:  MOVLW  04
1AEC:  MOVWF  xDD
1AEE:  MOVLB  0
1AF0:  CALL   086C
....................    lcd_putc("DESC"); 
1AF4:  MOVLW  82
1AF6:  MOVWF  FF6
1AF8:  MOVLW  03
1AFA:  MOVWF  FF7
1AFC:  CALL   0A42
....................    clear_lcd1 = 1; 
1B00:  MOVLW  01
1B02:  MOVWF  xAB
....................    time_lcd1 = 0; 
1B04:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio = 0; // reinicia el tiempo para el siguiente envio 
1B06:  CLRF   xAA
1B08:  CLRF   xA9
....................    flag_enviar = 0; 
1B0A:  CLRF   46
....................    enable_interrupts(INT_RDA); 
1B0C:  BSF    F9D.5
1B0E:  GOTO   30D4 (RETURN)
.................... } 
....................  
.................... void limpiar() 
.................... { // borra cuentas de subidas, bajadas y bloqueos 
....................    tem_entraront = 0; 
*
0D1A:  CLRF   x93
0D1C:  CLRF   x92
....................    tem_salieront = 0; 
0D1E:  CLRF   x95
0D20:  CLRF   x94
....................    salian = 0; 
0D22:  CLRF   3D
0D24:  CLRF   3C
....................    graba_conta2(); 
0D26:  RCALL  06B8
....................    leer_conta2(); 
0D28:  RCALL  081A
....................    pasaje = 0; 
0D2A:  CLRF   x8F
0D2C:  CLRF   x8E
....................    pasajet = 0; 
0D2E:  CLRF   x91
0D30:  CLRF   x90
....................    salieront = 0; 
0D32:  CLRF   x8D
0D34:  CLRF   x8C
....................    entraront = 0; 
0D36:  CLRF   x8B
0D38:  CLRF   x8A
....................    write_ent(); 
0D3A:  RCALL  0CAE
....................    write_sal(); 
0D3C:  RCALL  0CE4
....................    cta_bloqueo = 0; 
0D3E:  CLRF   4D
0D40:  CLRF   4C
....................    cta_bloq1 = 0; 
0D42:  CLRF   52
....................    cta_bloq2 = 0; 
0D44:  CLRF   53
....................    cta_bloq3 = 0; 
0D46:  CLRF   54
....................    write_ext_eeprom(9, cta_bloq1);  // bloq1 
0D48:  MOVLB  1
0D4A:  CLRF   xD6
0D4C:  MOVLW  09
0D4E:  MOVWF  xD5
0D50:  MOVFF  52,1D7
0D54:  MOVLB  0
0D56:  RCALL  05B2
....................    write_ext_eeprom(10, cta_bloq2); // bloq2 
0D58:  MOVLB  1
0D5A:  CLRF   xD6
0D5C:  MOVLW  0A
0D5E:  MOVWF  xD5
0D60:  MOVFF  53,1D7
0D64:  MOVLB  0
0D66:  RCALL  05B2
....................    write_ext_eeprom(11, cta_bloq3); // bloq3 
0D68:  MOVLB  1
0D6A:  CLRF   xD6
0D6C:  MOVLW  0B
0D6E:  MOVWF  xD5
0D70:  MOVFF  54,1D7
0D74:  MOVLB  0
0D76:  RCALL  05B2
....................    lcd_putc("\f"); 
0D78:  MOVLW  88
0D7A:  MOVWF  FF6
0D7C:  MOVLW  03
0D7E:  MOVWF  FF7
0D80:  RCALL  0A42
....................    lcd_cuentas(); 
0D82:  RCALL  0A62
0D84:  RETURN 0
.................... } 
....................  
.................... void detecta_suma() 
.................... { // Realiza suma de entradas o salidas 
....................    if ((!detec1) && (!detec2) && (!detec3) && (!detec4) && (!detec5) && (!detec6)) 
*
1F4E:  MOVF   x69,F
1F50:  BNZ   1FBE
1F52:  MOVF   x6A,F
1F54:  BNZ   1FBE
1F56:  MOVF   x6B,F
1F58:  BNZ   1FBE
1F5A:  MOVF   x6C,F
1F5C:  BNZ   1FBE
1F5E:  MOVF   x6D,F
1F60:  BNZ   1FBE
1F62:  MOVF   x6E,F
1F64:  BNZ   1FBE
....................    { // suma sin bloqueos 
....................       sumae1 = fse1 + fse2 + fse3; 
1F66:  MOVF   29,W
1F68:  ADDWF  28,W
1F6A:  ADDWF  2A,W
1F6C:  MOVWF  25
....................       sumas1 = fss1 + fss2 + fss3; 
1F6E:  MOVF   2C,W
1F70:  ADDWF  2B,W
1F72:  ADDWF  2D,W
1F74:  MOVWF  26
....................       //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
....................       //!      printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................       if ((sumae1 >= 2) || (sumas1 >= 2)) 
1F76:  MOVF   25,W
1F78:  SUBLW  01
1F7A:  BNC   1F82
1F7C:  MOVF   26,W
1F7E:  SUBLW  01
1F80:  BC    1FA0
....................       { 
....................          if (sumae1 > sumas1) 
1F82:  MOVF   25,W
1F84:  SUBWF  26,W
1F86:  BC    1F96
....................          { 
....................             entraront++; 
1F88:  INCF   x8A,F
1F8A:  BTFSC  FD8.2
1F8C:  INCF   x8B,F
....................             write_ent(); 
1F8E:  CALL   0CAE
....................             /////enciende relay//// 
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
1F92:  RCALL  1838
....................             //////// 
....................          } 
1F94:  BRA    1FA0
....................          else 
....................          { 
....................             salieront++; 
1F96:  INCF   x8C,F
1F98:  BTFSC  FD8.2
1F9A:  INCF   x8D,F
....................             write_sal(); 
1F9C:  CALL   0CE4
....................          } 
....................       } 
....................       sumae1 = fse1 = fse2 = fse3 = 0; 
1FA0:  CLRF   2A
1FA2:  MOVFF  2A,29
1FA6:  MOVFF  29,28
1FAA:  MOVFF  28,25
....................       sumas1 = fss1 = fss2 = fss3 = 0; 
1FAE:  CLRF   2D
1FB0:  MOVFF  2D,2C
1FB4:  MOVFF  2C,2B
1FB8:  MOVFF  2B,26
....................       // envio_PC(); 
....................    } // fin suma sin bloqueos 
1FBC:  BRA    20C8
....................    else if ((en_b1) || (en_b2) || (en_b3)) 
1FBE:  MOVF   x9E,F
1FC0:  BNZ   1FCC
1FC2:  MOVF   x9F,F
1FC4:  BNZ   1FCC
1FC6:  MOVF   xA0,F
1FC8:  BTFSC  FD8.2
1FCA:  BRA    20C8
....................    { // contar con bloqueos 
....................       lim_b = en_b1 + en_b2 + en_b3; 
1FCC:  MOVF   x9F,W
1FCE:  ADDWF  x9E,W
1FD0:  ADDWF  xA0,W
1FD2:  MOVWF  27
....................  
....................       if (lim_b == 1) 
1FD4:  DECFSZ 27,W
1FD6:  BRA    2070
....................       { // un solo bloqueo 
....................          if (en_b1) 
1FD8:  MOVF   x9E,F
1FDA:  BZ    200A
....................          { 
....................             if ((!detec3) && (!detec4) && (!detec5) && (!detec6)) 
1FDC:  MOVF   x6B,F
1FDE:  BNZ   2008
1FE0:  MOVF   x6C,F
1FE2:  BNZ   2008
1FE4:  MOVF   x6D,F
1FE6:  BNZ   2008
1FE8:  MOVF   x6E,F
1FEA:  BNZ   2008
....................             { 
....................                if (sen_ent == 1) 
1FEC:  DECFSZ 5B,W
1FEE:  BRA    1FFE
....................                { 
....................                   entraront++; 
1FF0:  INCF   x8A,F
1FF2:  BTFSC  FD8.2
1FF4:  INCF   x8B,F
....................                   write_ent(); 
1FF6:  CALL   0CAE
....................                   /////enciende relay//// 
....................                   cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
1FFA:  RCALL  1838
....................                   //////// 
....................                } 
1FFC:  BRA    2008
....................                else 
....................                { 
....................                   salieront++; 
1FFE:  INCF   x8C,F
2000:  BTFSC  FD8.2
2002:  INCF   x8D,F
....................                   write_sal(); 
2004:  CALL   0CE4
....................                } 
....................             } // fin sensores 0 
....................          }    // fin bloqueo par 1 
2008:  BRA    206E
....................          else if (en_b2) 
200A:  MOVF   x9F,F
200C:  BZ    203C
....................          { // bloqueo en par 2 
....................             if ((!detec1) && (!detec2) && (!detec5) && (!detec6)) 
200E:  MOVF   x69,F
2010:  BNZ   203A
2012:  MOVF   x6A,F
2014:  BNZ   203A
2016:  MOVF   x6D,F
2018:  BNZ   203A
201A:  MOVF   x6E,F
201C:  BNZ   203A
....................             { 
....................                if (sen_ent) 
201E:  MOVF   5B,F
2020:  BZ    2030
....................                { 
....................                   entraront++; 
2022:  INCF   x8A,F
2024:  BTFSC  FD8.2
2026:  INCF   x8B,F
....................                   write_ent(); 
2028:  CALL   0CAE
....................                   /////enciende relay//// 
....................                   cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
202C:  RCALL  1838
....................                   //////// 
....................                } 
202E:  BRA    203A
....................                else 
....................                { 
....................                   salieront++; 
2030:  INCF   x8C,F
2032:  BTFSC  FD8.2
2034:  INCF   x8D,F
....................                   write_sal(); 
2036:  CALL   0CE4
....................                } 
....................             } // fin sensores 0 
....................          }    // fin par 2 
203A:  BRA    206E
....................          else if (en_b3) 
203C:  MOVF   xA0,F
203E:  BZ    206E
....................          { // bloqueao en par 3 
....................             if ((!detec3) && (!detec4) && (!detec1) && (!detec2)) 
2040:  MOVF   x6B,F
2042:  BNZ   206E
2044:  MOVF   x6C,F
2046:  BNZ   206E
2048:  MOVF   x69,F
204A:  BNZ   206E
204C:  MOVF   x6A,F
204E:  BNZ   206E
....................             { 
....................                if (sen_ent) 
2050:  MOVF   5B,F
2052:  BZ    2064
....................                { 
....................                   entraront++; 
2054:  INCF   x8A,F
2056:  BTFSC  FD8.2
2058:  INCF   x8B,F
....................                   write_ent(); 
205A:  CALL   0CAE
....................                   /////enciende relay//// 
....................                   cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
205E:  CALL   1838
....................                   //////// 
....................                } 
2062:  BRA    206E
....................                else 
....................                { 
....................                   salieront++; 
2064:  INCF   x8C,F
2066:  BTFSC  FD8.2
2068:  INCF   x8D,F
....................                   write_sal(); 
206A:  CALL   0CE4
....................                } 
....................             } 
....................          } // fin par 3 
....................       }    // fin un solo bloqueo 
206E:  BRA    20AC
....................       //----------------------------------------------------------------------------- 
....................       else 
....................       { // mas de un bloqueo 
....................          sumae1 = fse1 + fse2 + fse3; 
2070:  MOVF   29,W
2072:  ADDWF  28,W
2074:  ADDWF  2A,W
2076:  MOVWF  25
....................          sumas1 = fss1 + fss2 + fss3; 
2078:  MOVF   2C,W
207A:  ADDWF  2B,W
207C:  ADDWF  2D,W
207E:  MOVWF  26
....................          // lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
....................          // printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................          if ((sumae1 >= 1) || (sumas1 >= 1)) 
2080:  MOVF   25,W
2082:  SUBLW  00
2084:  BNC   208C
2086:  MOVF   26,W
2088:  SUBLW  00
208A:  BC    20AC
....................          { 
....................             if (sumae1 > sumas1) 
208C:  MOVF   25,W
208E:  SUBWF  26,W
2090:  BC    20A2
....................             { 
....................                entraront++; 
2092:  INCF   x8A,F
2094:  BTFSC  FD8.2
2096:  INCF   x8B,F
....................                write_ent(); 
2098:  CALL   0CAE
....................                /////enciende relay//// 
....................                cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
209C:  CALL   1838
....................                //////// 
....................             } 
20A0:  BRA    20AC
....................             else 
....................             { 
....................                salieront++; 
20A2:  INCF   x8C,F
20A4:  BTFSC  FD8.2
20A6:  INCF   x8D,F
....................                write_sal(); 
20A8:  CALL   0CE4
....................             } 
....................          } 
....................       } // fin mas de un bloqueo 
....................       sumae1 = fse1 = fse2 = fse3 = 0; 
20AC:  CLRF   2A
20AE:  MOVFF  2A,29
20B2:  MOVFF  29,28
20B6:  MOVFF  28,25
....................       sumas1 = fss1 = fss2 = fss3 = 0; 
20BA:  CLRF   2D
20BC:  MOVFF  2D,2C
20C0:  MOVFF  2C,2B
20C4:  MOVFF  2B,26
....................       //----------------------------------------------------------------------------- 
....................    } // end bloqueos 
20C8:  RETURN 0
.................... } 
....................  
.................... void finsuma() 
.................... { // Pinta en LCD la nueva cifra de entrada o salida 
....................  
....................    pasaje = (entraront + salieront) / 2; 
*
0C70:  MOVF   x8C,W
0C72:  ADDWF  x8A,W
0C74:  MOVLB  1
0C76:  MOVWF  xD1
0C78:  MOVLB  0
0C7A:  MOVF   x8D,W
0C7C:  ADDWFC x8B,W
0C7E:  MOVLB  1
0C80:  MOVWF  xD2
0C82:  BCF    FD8.0
0C84:  RRCF   xD2,W
0C86:  MOVLB  0
0C88:  MOVWF  x8F
0C8A:  MOVLB  1
0C8C:  RRCF   xD1,W
0C8E:  MOVLB  0
0C90:  MOVWF  x8E
....................    lcd_cuentas(); 
0C92:  RCALL  0A62
....................    sen_ent = 0; 
0C94:  CLRF   5B
....................    sen_sal = 0; 
0C96:  CLRF   5C
....................    fse1 = fse2 = fse3 = 0; 
0C98:  CLRF   2A
0C9A:  MOVFF  2A,29
0C9E:  MOVFF  29,28
....................    fss1 = fss2 = fss3 = 0; 
0CA2:  CLRF   2D
0CA4:  MOVFF  2D,2C
0CA8:  MOVFF  2C,2B
0CAC:  RETURN 0
.................... } 
....................  
.................... void contando1() 
.................... { // Revisa maquina de estados para par 1 
....................    if (entra_temp1 != edo1) 
*
20CA:  MOVF   x76,W
20CC:  SUBWF  x7B,W
20CE:  BZ    20D8
....................    { 
....................       entra_temp1 = edo1; 
20D0:  MOVFF  76,7B
....................       enable1 = 1; 
20D4:  MOVLW  01
20D6:  MOVWF  x7A
....................    } 
....................    if (enable1 == 1) 
20D8:  DECFSZ x7A,W
20DA:  BRA    2118
....................    { 
....................       switch (edo1) 
20DC:  MOVLW  01
20DE:  SUBWF  x76,W
20E0:  ADDLW  F4
20E2:  BC    2114
20E4:  ADDLW  0C
20E6:  GOTO   211A
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
20EA:  BRA    2114
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss1) 
20EC:  MOVF   2B,F
20EE:  BNZ   20F6
....................             fse1 = 1; // si no ha salido antes 
20F0:  MOVLW  01
20F2:  MOVWF  28
20F4:  BRA    20F8
....................          else 
....................             fss1 = 0; 
20F6:  CLRF   2B
....................          detecta_suma(); 
20F8:  RCALL  1F4E
....................          break; 
20FA:  BRA    2114
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
20FC:  RCALL  1F4E
....................          break; 
20FE:  BRA    2114
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
2100:  BRA    2114
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse1) 
2102:  MOVF   28,F
2104:  BNZ   210C
....................             fss1 = 1; // si no ha entrado antes 
2106:  MOVLW  01
2108:  MOVWF  2B
210A:  BRA    210E
....................          else 
....................             fse1 = 0; 
210C:  CLRF   28
....................          detecta_suma(); 
210E:  RCALL  1F4E
....................          break; 
2110:  BRA    2114
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
2112:  RCALL  1F4E
....................          break; 
....................       } 
....................       } 
....................       enable1 = 0; 
2114:  CLRF   x7A
....................       entra_act1 = 0; 
2116:  CLRF   x75
....................    } 
2118:  RETURN 0
.................... } 
....................  
.................... void contando2() 
.................... { // Revisa maquina de estados para par 2 
....................    if (entra_temp2 != edo2) 
*
23D2:  MOVF   x7D,W
23D4:  SUBWF  x82,W
23D6:  BZ    23E0
....................    { 
....................       entra_temp2 = edo2; 
23D8:  MOVFF  7D,82
....................       enable2 = 1; 
23DC:  MOVLW  01
23DE:  MOVWF  x81
....................    } 
....................    if (enable2 == 1) 
23E0:  DECFSZ x81,W
23E2:  BRA    2420
....................    { 
....................       switch (edo2) 
23E4:  MOVLW  01
23E6:  SUBWF  x7D,W
23E8:  ADDLW  F4
23EA:  BC    241C
23EC:  ADDLW  0C
23EE:  GOTO   2422
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
23F2:  BRA    241C
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss2) 
23F4:  MOVF   2C,F
23F6:  BNZ   23FE
....................             fse2 = 1; 
23F8:  MOVLW  01
23FA:  MOVWF  29
23FC:  BRA    2400
....................          else 
....................             fss2 = 0; 
23FE:  CLRF   2C
....................          detecta_suma(); 
2400:  RCALL  1F4E
....................          break; 
2402:  BRA    241C
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
2404:  RCALL  1F4E
....................          break; 
2406:  BRA    241C
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
2408:  BRA    241C
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse2) 
240A:  MOVF   29,F
240C:  BNZ   2414
....................             fss2 = 1; 
240E:  MOVLW  01
2410:  MOVWF  2C
2412:  BRA    2416
....................          else 
....................             fse2 = 0; 
2414:  CLRF   29
....................          detecta_suma(); 
2416:  RCALL  1F4E
....................          break; 
2418:  BRA    241C
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
241A:  RCALL  1F4E
....................          break; 
....................       } 
....................       } 
....................       enable2 = 0; 
241C:  CLRF   x81
....................       entra_act2 = 0; 
241E:  CLRF   x7C
....................    } 
2420:  RETURN 0
.................... } 
....................  
.................... void contando3() 
.................... { // Revisa maquina de estados para par 3 
....................    if (entra_temp3 != edo3) 
*
26DC:  MOVF   x84,W
26DE:  SUBWF  x89,W
26E0:  BZ    26EA
....................    { 
....................       entra_temp3 = edo3; 
26E2:  MOVFF  84,89
....................       enable3 = 1; 
26E6:  MOVLW  01
26E8:  MOVWF  x88
....................    } 
....................    if (enable3 == 1) 
26EA:  DECFSZ x88,W
26EC:  BRA    272A
....................    { 
....................       switch (edo3) 
26EE:  MOVLW  01
26F0:  SUBWF  x84,W
26F2:  ADDLW  F4
26F4:  BC    2726
26F6:  ADDLW  0C
26F8:  GOTO   272C
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
26FC:  BRA    2726
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss3) 
26FE:  MOVF   2D,F
2700:  BNZ   2708
....................             fse3 = 1; 
2702:  MOVLW  01
2704:  MOVWF  2A
2706:  BRA    270A
....................          else 
....................             fss3 = 0; 
2708:  CLRF   2D
....................          detecta_suma(); 
270A:  RCALL  1F4E
....................          break; 
270C:  BRA    2726
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
270E:  RCALL  1F4E
....................          break; 
2710:  BRA    2726
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
2712:  BRA    2726
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse3) 
2714:  MOVF   2A,F
2716:  BNZ   271E
....................             fss3 = 1; 
2718:  MOVLW  01
271A:  MOVWF  2D
271C:  BRA    2720
....................          else 
....................             fse3 = 0; 
271E:  CLRF   2A
....................          detecta_suma(); 
2720:  RCALL  1F4E
....................          break; 
2722:  BRA    2726
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
2724:  RCALL  1F4E
....................          break; 
....................       } 
....................       } 
....................       enable3 = 0; 
2726:  CLRF   x88
....................       entra_act3 = 0; 
2728:  CLRF   x83
....................    } 
272A:  RETURN 0
.................... } 
....................  
.................... void sensando1() 
.................... { // Define estados para la maquina de estados del par 1 
....................    /////normal/////// 
....................    if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 0) && (sale1 == 0)) 
*
1CC8:  MOVF   x75,F
1CCA:  BNZ   1D10
1CCC:  DECFSZ x69,W
1CCE:  BRA    1D10
1CD0:  MOVF   x6A,F
1CD2:  BNZ   1D10
1CD4:  MOVF   x77,F
1CD6:  BNZ   1D10
1CD8:  MOVF   x78,F
1CDA:  BNZ   1D10
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
1CDC:  MOVF   5B,F
1CDE:  BNZ   1CE6
1CE0:  MOVF   5C,F
1CE2:  BNZ   1CE6
....................          sentidos(); 
1CE4:  RCALL  1C7E
....................       lcd_gotoxy(8, 2); 
1CE6:  MOVLW  08
1CE8:  MOVLB  1
1CEA:  MOVWF  xDC
1CEC:  MOVLW  02
1CEE:  MOVWF  xDD
1CF0:  MOVLB  0
1CF2:  CALL   086C
....................       lcd_putc(0x7F); // flecha del sentido 
1CF6:  MOVLW  7F
1CF8:  MOVLB  1
1CFA:  MOVWF  xDB
1CFC:  MOVLB  0
1CFE:  CALL   08BE
....................       des1 = 1; 
1D02:  MOVLW  01
1D04:  MOVWF  x98
....................       //// 
....................       edo1 = 1; 
1D06:  MOVWF  x76
....................       entra1 = 1; 
1D08:  MOVWF  x77
....................       edoa1 = 1; 
1D0A:  MOVWF  x79
....................       entra_act1 = 1; 
1D0C:  MOVWF  x75
....................    } 
1D0E:  BRA    1F4C
....................    /// prioridad 
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 1) && (entra1 == 1) && (sale1 == 0)) 
1D10:  MOVF   x75,F
1D12:  BNZ   1D30
1D14:  DECFSZ x69,W
1D16:  BRA    1D30
1D18:  DECFSZ x6A,W
1D1A:  BRA    1D30
1D1C:  DECFSZ x77,W
1D1E:  BRA    1D30
1D20:  MOVF   x78,F
1D22:  BNZ   1D30
....................    { // PERSONA ENTRANDO 
....................       edo1 = 3; 
1D24:  MOVLW  03
1D26:  MOVWF  x76
....................       edoa1 = 0; 
1D28:  CLRF   x79
....................       entra_act1 = 1; 
1D2A:  MOVLW  01
1D2C:  MOVWF  x75
....................    } 
1D2E:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 1) && (sale1 == 0)) 
1D30:  MOVF   x75,F
1D32:  BNZ   1D4E
1D34:  MOVF   x69,F
1D36:  BNZ   1D4E
1D38:  DECFSZ x6A,W
1D3A:  BRA    1D4E
1D3C:  DECFSZ x77,W
1D3E:  BRA    1D4E
1D40:  MOVF   x78,F
1D42:  BNZ   1D4E
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo1 = 4; 
1D44:  MOVLW  04
1D46:  MOVWF  x76
....................       entra_act1 = 1; 
1D48:  MOVLW  01
1D4A:  MOVWF  x75
....................    } 
1D4C:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 0) && (entra1 == 1) && (sale1 == 0)) 
1D4E:  MOVF   x75,F
1D50:  BNZ   1DA6
1D52:  MOVF   x69,F
1D54:  BNZ   1DA6
1D56:  MOVF   x6A,F
1D58:  BNZ   1DA6
1D5A:  MOVF   x79,F
1D5C:  BNZ   1DA6
1D5E:  DECFSZ x77,W
1D60:  BRA    1DA6
1D62:  MOVF   x78,F
1D64:  BNZ   1DA6
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 2); 
1D66:  MOVLW  08
1D68:  MOVLB  1
1D6A:  MOVWF  xDC
1D6C:  MOVLW  02
1D6E:  MOVWF  xDD
1D70:  MOVLB  0
1D72:  CALL   086C
....................       lcd_putc(" "); 
1D76:  MOVLW  8A
1D78:  MOVWF  FF6
1D7A:  MOVLW  03
1D7C:  MOVWF  FF7
1D7E:  CALL   0A42
....................       des1 = 0; 
1D82:  CLRF   x98
....................       if (entra_temp1 == 4) 
1D84:  MOVF   x7B,W
1D86:  SUBLW  04
1D88:  BNZ   1D96
....................       { 
....................          edo1 = 5; 
1D8A:  MOVLW  05
1D8C:  MOVWF  x76
....................          entra1 = 0; 
1D8E:  CLRF   x77
....................          entra_act1 = 1; 
1D90:  MOVLW  01
1D92:  MOVWF  x75
....................       } 
1D94:  BRA    1DA4
....................       else 
....................       { // entraba y se regresa 
....................          des1 = 0; 
1D96:  CLRF   x98
....................          edo1 = 6; 
1D98:  MOVLW  06
1D9A:  MOVWF  x76
....................          entra1 = 0; 
1D9C:  CLRF   x77
....................          edoa1 = 0; 
1D9E:  CLRF   x79
....................          entra_act1 = 1; 
1DA0:  MOVLW  01
1DA2:  MOVWF  x75
....................       } 
....................    } 
1DA4:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 1) && (entra1 == 1) && (sale1 == 0)) 
1DA6:  MOVF   x75,F
1DA8:  BNZ   1DEA
1DAA:  MOVF   x69,F
1DAC:  BNZ   1DEA
1DAE:  MOVF   x6A,F
1DB0:  BNZ   1DEA
1DB2:  DECFSZ x79,W
1DB4:  BRA    1DEA
1DB6:  DECFSZ x77,W
1DB8:  BRA    1DEA
1DBA:  MOVF   x78,F
1DBC:  BNZ   1DEA
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 2); 
1DBE:  MOVLW  08
1DC0:  MOVLB  1
1DC2:  MOVWF  xDC
1DC4:  MOVLW  02
1DC6:  MOVWF  xDD
1DC8:  MOVLB  0
1DCA:  CALL   086C
....................       lcd_putc(" "); 
1DCE:  MOVLW  8C
1DD0:  MOVWF  FF6
1DD2:  MOVLW  03
1DD4:  MOVWF  FF7
1DD6:  CALL   0A42
....................       des1 = 0; 
1DDA:  CLRF   x98
....................       edo1 = 6; 
1DDC:  MOVLW  06
1DDE:  MOVWF  x76
....................       entra1 = 0; 
1DE0:  CLRF   x77
....................       edoa1 = 0; 
1DE2:  CLRF   x79
....................       entra_act1 = 1; 
1DE4:  MOVLW  01
1DE6:  MOVWF  x75
....................    } 
1DE8:  BRA    1F4C
....................    ///// 
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 1) && (sale1 == 0)) 
1DEA:  MOVF   x75,F
1DEC:  BNZ   1E0A
1DEE:  DECFSZ x69,W
1DF0:  BRA    1E0A
1DF2:  MOVF   x6A,F
1DF4:  BNZ   1E0A
1DF6:  DECFSZ x77,W
1DF8:  BRA    1E0A
1DFA:  MOVF   x78,F
1DFC:  BNZ   1E0A
....................    { 
....................       edo1 = 2; 
1DFE:  MOVLW  02
1E00:  MOVWF  x76
....................       edoa1 = 1; 
1E02:  MOVLW  01
1E04:  MOVWF  x79
....................       entra_act1 = 1; 
1E06:  MOVWF  x75
....................    } // checar prioridad 
1E08:  BRA    1F4C
....................    //////sentido inverso/// 
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 0) && (sale1 == 0)) 
1E0A:  MOVF   x75,F
1E0C:  BNZ   1E54
1E0E:  MOVF   x69,F
1E10:  BNZ   1E54
1E12:  DECFSZ x6A,W
1E14:  BRA    1E54
1E16:  MOVF   x77,F
1E18:  BNZ   1E54
1E1A:  MOVF   x78,F
1E1C:  BNZ   1E54
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
1E1E:  MOVF   5B,F
1E20:  BNZ   1E28
1E22:  MOVF   5C,F
1E24:  BNZ   1E28
....................          sentidos(); 
1E26:  RCALL  1C7E
....................       lcd_gotoxy(8, 2); 
1E28:  MOVLW  08
1E2A:  MOVLB  1
1E2C:  MOVWF  xDC
1E2E:  MOVLW  02
1E30:  MOVWF  xDD
1E32:  MOVLB  0
1E34:  CALL   086C
....................       lcd_putc(0x7E); // flecha del sentido 
1E38:  MOVLW  7E
1E3A:  MOVLB  1
1E3C:  MOVWF  xDB
1E3E:  MOVLB  0
1E40:  CALL   08BE
....................       des1 = 1; 
1E44:  MOVLW  01
1E46:  MOVWF  x98
....................       edo1 = 7; 
1E48:  MOVLW  07
1E4A:  MOVWF  x76
....................       sale1 = 1; 
1E4C:  MOVLW  01
1E4E:  MOVWF  x78
....................       entra_act1 = 1; 
1E50:  MOVWF  x75
....................    } 
1E52:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 0) && (sale1 == 1)) 
1E54:  MOVF   x75,F
1E56:  BNZ   1E74
1E58:  MOVF   x69,F
1E5A:  BNZ   1E74
1E5C:  DECFSZ x6A,W
1E5E:  BRA    1E74
1E60:  MOVF   x77,F
1E62:  BNZ   1E74
1E64:  DECFSZ x78,W
1E66:  BRA    1E74
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo1 = 8; 
1E68:  MOVLW  08
1E6A:  MOVWF  x76
....................       edoa1 = 1; 
1E6C:  MOVLW  01
1E6E:  MOVWF  x79
....................       entra_act1 = 1; 
1E70:  MOVWF  x75
....................    } 
1E72:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 1) && (entra1 == 0) && (sale1 == 1)) 
1E74:  MOVF   x75,F
1E76:  BNZ   1E94
1E78:  DECFSZ x69,W
1E7A:  BRA    1E94
1E7C:  DECFSZ x6A,W
1E7E:  BRA    1E94
1E80:  MOVF   x77,F
1E82:  BNZ   1E94
1E84:  DECFSZ x78,W
1E86:  BRA    1E94
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo1 = 9; 
1E88:  MOVLW  09
1E8A:  MOVWF  x76
....................       edoa1 = 0; 
1E8C:  CLRF   x79
....................       entra_act1 = 1; 
1E8E:  MOVLW  01
1E90:  MOVWF  x75
....................    } 
1E92:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 0) && (sale1 == 1)) 
1E94:  MOVF   x75,F
1E96:  BNZ   1EB2
1E98:  DECFSZ x69,W
1E9A:  BRA    1EB2
1E9C:  MOVF   x6A,F
1E9E:  BNZ   1EB2
1EA0:  MOVF   x77,F
1EA2:  BNZ   1EB2
1EA4:  DECFSZ x78,W
1EA6:  BRA    1EB2
....................    { // CASI TERMINA DE SALIR 
....................       edo1 = 10; 
1EA8:  MOVLW  0A
1EAA:  MOVWF  x76
....................       entra_act1 = 1; 
1EAC:  MOVLW  01
1EAE:  MOVWF  x75
....................    } 
1EB0:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 0) && (entra1 == 0) && (sale1 == 1)) 
1EB2:  MOVF   x75,F
1EB4:  BNZ   1F0A
1EB6:  MOVF   x69,F
1EB8:  BNZ   1F0A
1EBA:  MOVF   x6A,F
1EBC:  BNZ   1F0A
1EBE:  MOVF   x79,F
1EC0:  BNZ   1F0A
1EC2:  MOVF   x77,F
1EC4:  BNZ   1F0A
1EC6:  DECFSZ x78,W
1EC8:  BRA    1F0A
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 2); 
1ECA:  MOVLW  08
1ECC:  MOVLB  1
1ECE:  MOVWF  xDC
1ED0:  MOVLW  02
1ED2:  MOVWF  xDD
1ED4:  MOVLB  0
1ED6:  CALL   086C
....................       lcd_putc(" "); 
1EDA:  MOVLW  8E
1EDC:  MOVWF  FF6
1EDE:  MOVLW  03
1EE0:  MOVWF  FF7
1EE2:  CALL   0A42
....................       if (entra_temp1 == 10) 
1EE6:  MOVF   x7B,W
1EE8:  SUBLW  0A
1EEA:  BNZ   1EFA
....................       { 
....................          des1 = 0; 
1EEC:  CLRF   x98
....................          edo1 = 11; 
1EEE:  MOVLW  0B
1EF0:  MOVWF  x76
....................          sale1 = 0; 
1EF2:  CLRF   x78
....................          entra_act1 = 1; 
1EF4:  MOVLW  01
1EF6:  MOVWF  x75
....................       } 
1EF8:  BRA    1F08
....................       else 
....................       { 
....................          des1 = 0; 
1EFA:  CLRF   x98
....................          edo1 = 12; 
1EFC:  MOVLW  0C
1EFE:  MOVWF  x76
....................          sale1 = 0; 
1F00:  CLRF   x78
....................          edoa1 = 0; 
1F02:  CLRF   x79
....................          entra_act1 = 1; 
1F04:  MOVLW  01
1F06:  MOVWF  x75
....................       } 
....................    } 
1F08:  BRA    1F4C
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 1) && (entra1 == 0) && (sale1 == 1)) 
1F0A:  MOVF   x75,F
1F0C:  BNZ   1F4C
1F0E:  MOVF   x69,F
1F10:  BNZ   1F4C
1F12:  MOVF   x6A,F
1F14:  BNZ   1F4C
1F16:  DECFSZ x79,W
1F18:  BRA    1F4C
1F1A:  MOVF   x77,F
1F1C:  BNZ   1F4C
1F1E:  DECFSZ x78,W
1F20:  BRA    1F4C
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 2); 
1F22:  MOVLW  08
1F24:  MOVLB  1
1F26:  MOVWF  xDC
1F28:  MOVLW  02
1F2A:  MOVWF  xDD
1F2C:  MOVLB  0
1F2E:  CALL   086C
....................       lcd_putc(" "); 
1F32:  MOVLW  90
1F34:  MOVWF  FF6
1F36:  MOVLW  03
1F38:  MOVWF  FF7
1F3A:  CALL   0A42
....................       des1 = 0; 
1F3E:  CLRF   x98
....................       edo1 = 12; 
1F40:  MOVLW  0C
1F42:  MOVWF  x76
....................       sale1 = 0; 
1F44:  CLRF   x78
....................       edoa1 = 0; 
1F46:  CLRF   x79
....................       entra_act1 = 1; 
1F48:  MOVLW  01
1F4A:  MOVWF  x75
....................    } 
1F4C:  RETURN 0
.................... } 
....................  
.................... void sensando2() 
.................... { // Define estados para la maquina de estados del par 2 
....................    /////normal/////// 
....................    if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 0) && (sale2 == 0)) 
*
214C:  MOVF   x7C,F
214E:  BNZ   2194
2150:  DECFSZ x6B,W
2152:  BRA    2194
2154:  MOVF   x6C,F
2156:  BNZ   2194
2158:  MOVF   x7E,F
215A:  BNZ   2194
215C:  MOVF   x7F,F
215E:  BNZ   2194
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
2160:  MOVF   5B,F
2162:  BNZ   216A
2164:  MOVF   5C,F
2166:  BNZ   216A
....................          sentidos(); 
2168:  RCALL  1C7E
....................       lcd_gotoxy(8, 3); 
216A:  MOVLW  08
216C:  MOVLB  1
216E:  MOVWF  xDC
2170:  MOVLW  03
2172:  MOVWF  xDD
2174:  MOVLB  0
2176:  CALL   086C
....................       lcd_putc(0x7F); 
217A:  MOVLW  7F
217C:  MOVLB  1
217E:  MOVWF  xDB
2180:  MOVLB  0
2182:  CALL   08BE
....................       des2 = 1; 
2186:  MOVLW  01
2188:  MOVWF  x99
....................       edo2 = 1; 
218A:  MOVWF  x7D
....................       entra2 = 1; 
218C:  MOVWF  x7E
....................       edoa2 = 1; 
218E:  MOVWF  x80
....................       entra_act2 = 1; 
2190:  MOVWF  x7C
....................    } 
2192:  BRA    23D0
....................    /// prioridad 
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 1) && (entra2 == 1) && (sale2 == 0)) 
2194:  MOVF   x7C,F
2196:  BNZ   21B4
2198:  DECFSZ x6B,W
219A:  BRA    21B4
219C:  DECFSZ x6C,W
219E:  BRA    21B4
21A0:  DECFSZ x7E,W
21A2:  BRA    21B4
21A4:  MOVF   x7F,F
21A6:  BNZ   21B4
....................    { // PERSONA ENTRANDO 
....................       edo2 = 3; 
21A8:  MOVLW  03
21AA:  MOVWF  x7D
....................       edoa2 = 0; 
21AC:  CLRF   x80
....................       entra_act2 = 1; 
21AE:  MOVLW  01
21B0:  MOVWF  x7C
....................    } 
21B2:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 1) && (sale2 == 0)) 
21B4:  MOVF   x7C,F
21B6:  BNZ   21D2
21B8:  MOVF   x6B,F
21BA:  BNZ   21D2
21BC:  DECFSZ x6C,W
21BE:  BRA    21D2
21C0:  DECFSZ x7E,W
21C2:  BRA    21D2
21C4:  MOVF   x7F,F
21C6:  BNZ   21D2
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo2 = 4; 
21C8:  MOVLW  04
21CA:  MOVWF  x7D
....................       entra_act2 = 1; 
21CC:  MOVLW  01
21CE:  MOVWF  x7C
....................    } 
21D0:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 0) && (entra2 == 1) && (sale2 == 0)) 
21D2:  MOVF   x7C,F
21D4:  BNZ   222A
21D6:  MOVF   x6B,F
21D8:  BNZ   222A
21DA:  MOVF   x6C,F
21DC:  BNZ   222A
21DE:  MOVF   x80,F
21E0:  BNZ   222A
21E2:  DECFSZ x7E,W
21E4:  BRA    222A
21E6:  MOVF   x7F,F
21E8:  BNZ   222A
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 3); 
21EA:  MOVLW  08
21EC:  MOVLB  1
21EE:  MOVWF  xDC
21F0:  MOVLW  03
21F2:  MOVWF  xDD
21F4:  MOVLB  0
21F6:  CALL   086C
....................       lcd_putc(" "); 
21FA:  MOVLW  92
21FC:  MOVWF  FF6
21FE:  MOVLW  03
2200:  MOVWF  FF7
2202:  CALL   0A42
....................       if (entra_temp2 == 4) 
2206:  MOVF   x82,W
2208:  SUBLW  04
220A:  BNZ   221A
....................       { 
....................          des2 = 0; 
220C:  CLRF   x99
....................          edo2 = 5; 
220E:  MOVLW  05
2210:  MOVWF  x7D
....................          entra2 = 0; 
2212:  CLRF   x7E
....................          entra_act2 = 1; 
2214:  MOVLW  01
2216:  MOVWF  x7C
....................       } 
2218:  BRA    2228
....................       else 
....................       { 
....................          des2 = 0; 
221A:  CLRF   x99
....................          edo2 = 6; 
221C:  MOVLW  06
221E:  MOVWF  x7D
....................          entra2 = 0; 
2220:  CLRF   x7E
....................          edoa2 = 0; 
2222:  CLRF   x80
....................          entra_act2 = 1; 
2224:  MOVLW  01
2226:  MOVWF  x7C
....................       } 
....................    } 
2228:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 1) && (entra2 == 1) && (sale2 == 0)) 
222A:  MOVF   x7C,F
222C:  BNZ   226E
222E:  MOVF   x6B,F
2230:  BNZ   226E
2232:  MOVF   x6C,F
2234:  BNZ   226E
2236:  DECFSZ x80,W
2238:  BRA    226E
223A:  DECFSZ x7E,W
223C:  BRA    226E
223E:  MOVF   x7F,F
2240:  BNZ   226E
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 3); 
2242:  MOVLW  08
2244:  MOVLB  1
2246:  MOVWF  xDC
2248:  MOVLW  03
224A:  MOVWF  xDD
224C:  MOVLB  0
224E:  CALL   086C
....................       lcd_putc(" "); 
2252:  MOVLW  94
2254:  MOVWF  FF6
2256:  MOVLW  03
2258:  MOVWF  FF7
225A:  CALL   0A42
....................       des2 = 0; 
225E:  CLRF   x99
....................       edo2 = 6; 
2260:  MOVLW  06
2262:  MOVWF  x7D
....................       entra2 = 0; 
2264:  CLRF   x7E
....................       edoa2 = 0; 
2266:  CLRF   x80
....................       entra_act2 = 1; 
2268:  MOVLW  01
226A:  MOVWF  x7C
....................    } 
226C:  BRA    23D0
....................    ///// 
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 1) && (sale2 == 0)) 
226E:  MOVF   x7C,F
2270:  BNZ   228E
2272:  DECFSZ x6B,W
2274:  BRA    228E
2276:  MOVF   x6C,F
2278:  BNZ   228E
227A:  DECFSZ x7E,W
227C:  BRA    228E
227E:  MOVF   x7F,F
2280:  BNZ   228E
....................    { 
....................       edo2 = 2; 
2282:  MOVLW  02
2284:  MOVWF  x7D
....................       edoa2 = 1; 
2286:  MOVLW  01
2288:  MOVWF  x80
....................       entra_act2 = 1; 
228A:  MOVWF  x7C
....................    } // checar prioridad 
228C:  BRA    23D0
....................    //////sentido inverso/// 
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 0) && (sale2 == 0)) 
228E:  MOVF   x7C,F
2290:  BNZ   22D8
2292:  MOVF   x6B,F
2294:  BNZ   22D8
2296:  DECFSZ x6C,W
2298:  BRA    22D8
229A:  MOVF   x7E,F
229C:  BNZ   22D8
229E:  MOVF   x7F,F
22A0:  BNZ   22D8
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
22A2:  MOVF   5B,F
22A4:  BNZ   22AC
22A6:  MOVF   5C,F
22A8:  BNZ   22AC
....................          sentidos(); 
22AA:  RCALL  1C7E
....................       lcd_gotoxy(8, 3); 
22AC:  MOVLW  08
22AE:  MOVLB  1
22B0:  MOVWF  xDC
22B2:  MOVLW  03
22B4:  MOVWF  xDD
22B6:  MOVLB  0
22B8:  CALL   086C
....................       lcd_putc(0x7E); // flecha del sentido 
22BC:  MOVLW  7E
22BE:  MOVLB  1
22C0:  MOVWF  xDB
22C2:  MOVLB  0
22C4:  CALL   08BE
....................       des2 = 1; 
22C8:  MOVLW  01
22CA:  MOVWF  x99
....................       edo2 = 7; 
22CC:  MOVLW  07
22CE:  MOVWF  x7D
....................       sale2 = 1; 
22D0:  MOVLW  01
22D2:  MOVWF  x7F
....................       entra_act2 = 1; 
22D4:  MOVWF  x7C
....................    } 
22D6:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 0) && (sale2 == 1)) 
22D8:  MOVF   x7C,F
22DA:  BNZ   22F8
22DC:  MOVF   x6B,F
22DE:  BNZ   22F8
22E0:  DECFSZ x6C,W
22E2:  BRA    22F8
22E4:  MOVF   x7E,F
22E6:  BNZ   22F8
22E8:  DECFSZ x7F,W
22EA:  BRA    22F8
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo2 = 8; 
22EC:  MOVLW  08
22EE:  MOVWF  x7D
....................       edoa2 = 1; 
22F0:  MOVLW  01
22F2:  MOVWF  x80
....................       entra_act2 = 1; 
22F4:  MOVWF  x7C
....................    } 
22F6:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 1) && (entra2 == 0) && (sale2 == 1)) 
22F8:  MOVF   x7C,F
22FA:  BNZ   2318
22FC:  DECFSZ x6B,W
22FE:  BRA    2318
2300:  DECFSZ x6C,W
2302:  BRA    2318
2304:  MOVF   x7E,F
2306:  BNZ   2318
2308:  DECFSZ x7F,W
230A:  BRA    2318
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo2 = 9; 
230C:  MOVLW  09
230E:  MOVWF  x7D
....................       edoa2 = 0; 
2310:  CLRF   x80
....................       entra_act2 = 1; 
2312:  MOVLW  01
2314:  MOVWF  x7C
....................    } 
2316:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 0) && (sale2 == 1)) 
2318:  MOVF   x7C,F
231A:  BNZ   2336
231C:  DECFSZ x6B,W
231E:  BRA    2336
2320:  MOVF   x6C,F
2322:  BNZ   2336
2324:  MOVF   x7E,F
2326:  BNZ   2336
2328:  DECFSZ x7F,W
232A:  BRA    2336
....................    { // CASI TERMINA DE SALIR 
....................       edo2 = 10; 
232C:  MOVLW  0A
232E:  MOVWF  x7D
....................       entra_act2 = 1; 
2330:  MOVLW  01
2332:  MOVWF  x7C
....................    } 
2334:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 0) && (entra2 == 0) && (sale2 == 1)) 
2336:  MOVF   x7C,F
2338:  BNZ   238E
233A:  MOVF   x6B,F
233C:  BNZ   238E
233E:  MOVF   x6C,F
2340:  BNZ   238E
2342:  MOVF   x80,F
2344:  BNZ   238E
2346:  MOVF   x7E,F
2348:  BNZ   238E
234A:  DECFSZ x7F,W
234C:  BRA    238E
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 3); 
234E:  MOVLW  08
2350:  MOVLB  1
2352:  MOVWF  xDC
2354:  MOVLW  03
2356:  MOVWF  xDD
2358:  MOVLB  0
235A:  CALL   086C
....................       lcd_putc(" "); 
235E:  MOVLW  96
2360:  MOVWF  FF6
2362:  MOVLW  03
2364:  MOVWF  FF7
2366:  CALL   0A42
....................       if (entra_temp2 == 10) 
236A:  MOVF   x82,W
236C:  SUBLW  0A
236E:  BNZ   237E
....................       { 
....................          des2 = 0; 
2370:  CLRF   x99
....................          edo2 = 11; 
2372:  MOVLW  0B
2374:  MOVWF  x7D
....................          sale2 = 0; 
2376:  CLRF   x7F
....................          entra_act2 = 1; 
2378:  MOVLW  01
237A:  MOVWF  x7C
....................       } 
237C:  BRA    238C
....................       else 
....................       { 
....................          des2 = 0; 
237E:  CLRF   x99
....................          edo2 = 12; 
2380:  MOVLW  0C
2382:  MOVWF  x7D
....................          sale2 = 0; 
2384:  CLRF   x7F
....................          edoa2 = 0; 
2386:  CLRF   x80
....................          entra_act2 = 1; 
2388:  MOVLW  01
238A:  MOVWF  x7C
....................       } 
....................    } 
238C:  BRA    23D0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 1) && (entra2 == 0) && (sale2 == 1)) 
238E:  MOVF   x7C,F
2390:  BNZ   23D0
2392:  MOVF   x6B,F
2394:  BNZ   23D0
2396:  MOVF   x6C,F
2398:  BNZ   23D0
239A:  DECFSZ x80,W
239C:  BRA    23D0
239E:  MOVF   x7E,F
23A0:  BNZ   23D0
23A2:  DECFSZ x7F,W
23A4:  BRA    23D0
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 3); 
23A6:  MOVLW  08
23A8:  MOVLB  1
23AA:  MOVWF  xDC
23AC:  MOVLW  03
23AE:  MOVWF  xDD
23B0:  MOVLB  0
23B2:  CALL   086C
....................       lcd_putc(" "); 
23B6:  MOVLW  98
23B8:  MOVWF  FF6
23BA:  MOVLW  03
23BC:  MOVWF  FF7
23BE:  CALL   0A42
....................       des2 = 0; 
23C2:  CLRF   x99
....................       edo2 = 12; 
23C4:  MOVLW  0C
23C6:  MOVWF  x7D
....................       sale2 = 0; 
23C8:  CLRF   x7F
....................       edoa2 = 0; 
23CA:  CLRF   x80
....................       entra_act2 = 1; 
23CC:  MOVLW  01
23CE:  MOVWF  x7C
....................    } 
23D0:  RETURN 0
.................... } 
....................  
.................... void sensando3() 
.................... { // Define estados para la maquina de estados del par 3 
....................    /////normal/////// 
....................    if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 0) && (sale3 == 0)) 
*
2454:  MOVF   x83,F
2456:  BNZ   249C
2458:  DECFSZ x6D,W
245A:  BRA    249C
245C:  MOVF   x6E,F
245E:  BNZ   249C
2460:  MOVF   x85,F
2462:  BNZ   249C
2464:  MOVF   x86,F
2466:  BNZ   249C
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
2468:  MOVF   5B,F
246A:  BNZ   2472
246C:  MOVF   5C,F
246E:  BNZ   2472
....................          sentidos(); 
2470:  RCALL  1C7E
....................       lcd_gotoxy(8, 4); 
2472:  MOVLW  08
2474:  MOVLB  1
2476:  MOVWF  xDC
2478:  MOVLW  04
247A:  MOVWF  xDD
247C:  MOVLB  0
247E:  CALL   086C
....................       lcd_putc(0x7F); 
2482:  MOVLW  7F
2484:  MOVLB  1
2486:  MOVWF  xDB
2488:  MOVLB  0
248A:  CALL   08BE
....................       des3 = 1; 
248E:  MOVLW  01
2490:  MOVWF  x9A
....................       edo3 = 1; 
2492:  MOVWF  x84
....................       entra3 = 1; 
2494:  MOVWF  x85
....................       edoa3 = 1; 
2496:  MOVWF  x87
....................       entra_act3 = 1; 
2498:  MOVWF  x83
....................    } 
249A:  BRA    26DA
....................    /// prioridad 
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 1) && (entra3 == 1) && (sale3 == 0)) 
249C:  MOVF   x83,F
249E:  BNZ   24BC
24A0:  DECFSZ x6D,W
24A2:  BRA    24BC
24A4:  DECFSZ x6E,W
24A6:  BRA    24BC
24A8:  DECFSZ x85,W
24AA:  BRA    24BC
24AC:  MOVF   x86,F
24AE:  BNZ   24BC
....................    { // PERSONA ENTRANDO 
....................       edo3 = 3; 
24B0:  MOVLW  03
24B2:  MOVWF  x84
....................       edoa3 = 0; 
24B4:  CLRF   x87
....................       entra_act3 = 1; 
24B6:  MOVLW  01
24B8:  MOVWF  x83
....................    } 
24BA:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 1) && (sale3 == 0)) 
24BC:  MOVF   x83,F
24BE:  BNZ   24DA
24C0:  MOVF   x6D,F
24C2:  BNZ   24DA
24C4:  DECFSZ x6E,W
24C6:  BRA    24DA
24C8:  DECFSZ x85,W
24CA:  BRA    24DA
24CC:  MOVF   x86,F
24CE:  BNZ   24DA
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo3 = 4; 
24D0:  MOVLW  04
24D2:  MOVWF  x84
....................       entra_act3 = 1; 
24D4:  MOVLW  01
24D6:  MOVWF  x83
....................    } 
24D8:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 0) && (entra3 == 1) && (sale3 == 0)) 
24DA:  MOVF   x83,F
24DC:  BNZ   2532
24DE:  MOVF   x6D,F
24E0:  BNZ   2532
24E2:  MOVF   x6E,F
24E4:  BNZ   2532
24E6:  MOVF   x87,F
24E8:  BNZ   2532
24EA:  DECFSZ x85,W
24EC:  BRA    2532
24EE:  MOVF   x86,F
24F0:  BNZ   2532
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 4); 
24F2:  MOVLW  08
24F4:  MOVLB  1
24F6:  MOVWF  xDC
24F8:  MOVLW  04
24FA:  MOVWF  xDD
24FC:  MOVLB  0
24FE:  CALL   086C
....................       lcd_putc(" "); 
2502:  MOVLW  9A
2504:  MOVWF  FF6
2506:  MOVLW  03
2508:  MOVWF  FF7
250A:  CALL   0A42
....................       if (entra_temp3 == 4) 
250E:  MOVF   x89,W
2510:  SUBLW  04
2512:  BNZ   2522
....................       { 
....................          des3 = 0; 
2514:  CLRF   x9A
....................          edo3 = 5; 
2516:  MOVLW  05
2518:  MOVWF  x84
....................          entra3 = 0; 
251A:  CLRF   x85
....................          entra_act3 = 1; 
251C:  MOVLW  01
251E:  MOVWF  x83
....................       } 
2520:  BRA    2530
....................       else 
....................       { 
....................          des3 = 0; 
2522:  CLRF   x9A
....................          edo3 = 6; 
2524:  MOVLW  06
2526:  MOVWF  x84
....................          entra3 = 0; 
2528:  CLRF   x85
....................          edoa3 = 0; 
252A:  CLRF   x87
....................          entra_act3 = 1; 
252C:  MOVLW  01
252E:  MOVWF  x83
....................       } 
....................    } 
2530:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 1) && (entra3 == 1) && (sale3 == 0)) 
2532:  MOVF   x83,F
2534:  BNZ   2576
2536:  MOVF   x6D,F
2538:  BNZ   2576
253A:  MOVF   x6E,F
253C:  BNZ   2576
253E:  DECFSZ x87,W
2540:  BRA    2576
2542:  DECFSZ x85,W
2544:  BRA    2576
2546:  MOVF   x86,F
2548:  BNZ   2576
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 4); 
254A:  MOVLW  08
254C:  MOVLB  1
254E:  MOVWF  xDC
2550:  MOVLW  04
2552:  MOVWF  xDD
2554:  MOVLB  0
2556:  CALL   086C
....................       lcd_putc(" "); 
255A:  MOVLW  9C
255C:  MOVWF  FF6
255E:  MOVLW  03
2560:  MOVWF  FF7
2562:  CALL   0A42
....................       des3 = 0; 
2566:  CLRF   x9A
....................       edo3 = 6; 
2568:  MOVLW  06
256A:  MOVWF  x84
....................       entra3 = 0; 
256C:  CLRF   x85
....................       edoa3 = 0; 
256E:  CLRF   x87
....................       entra_act3 = 1; 
2570:  MOVLW  01
2572:  MOVWF  x83
....................    } 
2574:  BRA    26DA
....................    ///// 
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 1) && (sale3 == 0)) 
2576:  MOVF   x83,F
2578:  BNZ   2596
257A:  DECFSZ x6D,W
257C:  BRA    2596
257E:  MOVF   x6E,F
2580:  BNZ   2596
2582:  DECFSZ x85,W
2584:  BRA    2596
2586:  MOVF   x86,F
2588:  BNZ   2596
....................    { 
....................       // sentidos(); 
....................       edo3 = 2; 
258A:  MOVLW  02
258C:  MOVWF  x84
....................       edoa3 = 1; 
258E:  MOVLW  01
2590:  MOVWF  x87
....................       entra_act3 = 1; 
2592:  MOVWF  x83
....................    } // checar prioridad 
2594:  BRA    26DA
....................    //////sentido inverso/// 
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 0) && (sale3 == 0)) 
2596:  MOVF   x83,F
2598:  BNZ   25E2
259A:  MOVF   x6D,F
259C:  BNZ   25E2
259E:  DECFSZ x6E,W
25A0:  BRA    25E2
25A2:  MOVF   x85,F
25A4:  BNZ   25E2
25A6:  MOVF   x86,F
25A8:  BNZ   25E2
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
25AA:  MOVF   5B,F
25AC:  BNZ   25B6
25AE:  MOVF   5C,F
25B0:  BNZ   25B6
....................          sentidos(); 
25B2:  CALL   1C7E
....................       lcd_gotoxy(8, 4); 
25B6:  MOVLW  08
25B8:  MOVLB  1
25BA:  MOVWF  xDC
25BC:  MOVLW  04
25BE:  MOVWF  xDD
25C0:  MOVLB  0
25C2:  CALL   086C
....................       lcd_putc(0x7E); // flecha del sentido 
25C6:  MOVLW  7E
25C8:  MOVLB  1
25CA:  MOVWF  xDB
25CC:  MOVLB  0
25CE:  CALL   08BE
....................       des3 = 1; 
25D2:  MOVLW  01
25D4:  MOVWF  x9A
....................       edo3 = 7; 
25D6:  MOVLW  07
25D8:  MOVWF  x84
....................       sale3 = 1; 
25DA:  MOVLW  01
25DC:  MOVWF  x86
....................       entra_act3 = 1; 
25DE:  MOVWF  x83
....................    } 
25E0:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 0) && (sale3 == 1)) 
25E2:  MOVF   x83,F
25E4:  BNZ   2602
25E6:  MOVF   x6D,F
25E8:  BNZ   2602
25EA:  DECFSZ x6E,W
25EC:  BRA    2602
25EE:  MOVF   x85,F
25F0:  BNZ   2602
25F2:  DECFSZ x86,W
25F4:  BRA    2602
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo3 = 8; 
25F6:  MOVLW  08
25F8:  MOVWF  x84
....................       edoa3 = 1; 
25FA:  MOVLW  01
25FC:  MOVWF  x87
....................       entra_act3 = 1; 
25FE:  MOVWF  x83
....................    } 
2600:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 1) && (entra3 == 0) && (sale3 == 1)) 
2602:  MOVF   x83,F
2604:  BNZ   2622
2606:  DECFSZ x6D,W
2608:  BRA    2622
260A:  DECFSZ x6E,W
260C:  BRA    2622
260E:  MOVF   x85,F
2610:  BNZ   2622
2612:  DECFSZ x86,W
2614:  BRA    2622
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo3 = 9; 
2616:  MOVLW  09
2618:  MOVWF  x84
....................       edoa3 = 0; 
261A:  CLRF   x87
....................       entra_act3 = 1; 
261C:  MOVLW  01
261E:  MOVWF  x83
....................    } 
2620:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 0) && (sale3 == 1)) 
2622:  MOVF   x83,F
2624:  BNZ   2640
2626:  DECFSZ x6D,W
2628:  BRA    2640
262A:  MOVF   x6E,F
262C:  BNZ   2640
262E:  MOVF   x85,F
2630:  BNZ   2640
2632:  DECFSZ x86,W
2634:  BRA    2640
....................    { // CASI TERMINA DE SALIR 
....................       edo3 = 10; 
2636:  MOVLW  0A
2638:  MOVWF  x84
....................       entra_act3 = 1; 
263A:  MOVLW  01
263C:  MOVWF  x83
....................    } 
263E:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 0) && (entra3 == 0) && (sale3 == 1)) 
2640:  MOVF   x83,F
2642:  BNZ   2698
2644:  MOVF   x6D,F
2646:  BNZ   2698
2648:  MOVF   x6E,F
264A:  BNZ   2698
264C:  MOVF   x87,F
264E:  BNZ   2698
2650:  MOVF   x85,F
2652:  BNZ   2698
2654:  DECFSZ x86,W
2656:  BRA    2698
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 4); 
2658:  MOVLW  08
265A:  MOVLB  1
265C:  MOVWF  xDC
265E:  MOVLW  04
2660:  MOVWF  xDD
2662:  MOVLB  0
2664:  CALL   086C
....................       lcd_putc(" "); 
2668:  MOVLW  9E
266A:  MOVWF  FF6
266C:  MOVLW  03
266E:  MOVWF  FF7
2670:  CALL   0A42
....................       if (entra_temp3 == 10) 
2674:  MOVF   x89,W
2676:  SUBLW  0A
2678:  BNZ   2688
....................       { 
....................          des3 = 0; 
267A:  CLRF   x9A
....................          edo3 = 11; 
267C:  MOVLW  0B
267E:  MOVWF  x84
....................          sale3 = 0; 
2680:  CLRF   x86
....................          entra_act3 = 1; 
2682:  MOVLW  01
2684:  MOVWF  x83
....................       } 
2686:  BRA    2696
....................       else 
....................       { 
....................          des3 = 0; 
2688:  CLRF   x9A
....................          edo3 = 12; 
268A:  MOVLW  0C
268C:  MOVWF  x84
....................          sale3 = 0; 
268E:  CLRF   x86
....................          edoa3 = 0; 
2690:  CLRF   x87
....................          entra_act3 = 1; 
2692:  MOVLW  01
2694:  MOVWF  x83
....................       } 
....................    } 
2696:  BRA    26DA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 1) && (entra3 == 0) && (sale3 == 1)) 
2698:  MOVF   x83,F
269A:  BNZ   26DA
269C:  MOVF   x6D,F
269E:  BNZ   26DA
26A0:  MOVF   x6E,F
26A2:  BNZ   26DA
26A4:  DECFSZ x87,W
26A6:  BRA    26DA
26A8:  MOVF   x85,F
26AA:  BNZ   26DA
26AC:  DECFSZ x86,W
26AE:  BRA    26DA
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 4); 
26B0:  MOVLW  08
26B2:  MOVLB  1
26B4:  MOVWF  xDC
26B6:  MOVLW  04
26B8:  MOVWF  xDD
26BA:  MOVLB  0
26BC:  CALL   086C
....................       lcd_putc(" "); 
26C0:  MOVLW  A0
26C2:  MOVWF  FF6
26C4:  MOVLW  03
26C6:  MOVWF  FF7
26C8:  CALL   0A42
....................       des3 = 0; 
26CC:  CLRF   x9A
....................       edo3 = 12; 
26CE:  MOVLW  0C
26D0:  MOVWF  x84
....................       sale3 = 0; 
26D2:  CLRF   x86
....................       edoa3 = 0; 
26D4:  CLRF   x87
....................       entra_act3 = 1; 
26D6:  MOVLW  01
26D8:  MOVWF  x83
....................    } 
26DA:  RETURN 0
.................... } 
....................  
.................... void sensores() 
.................... { // Detecta estado (bloqueado o libre) de los sensores 
....................    // sensor1 
....................    ent1 = input(entrada01); 
*
275E:  BSF    F93.4
2760:  CLRF   55
2762:  BTFSC  F81.4
2764:  INCF   55,F
....................    if (ent1 == 1) 
2766:  DECFSZ 55,W
2768:  BRA    2782
....................    { 
....................       sub_cta1 = 0; 
276A:  CLRF   5E
276C:  CLRF   5D
....................       detec1 = 0; 
276E:  CLRF   x69
....................       bloq_p1 = 0; // deshabilita bloqueo par1 
2770:  CLRF   x9B
....................       tim_p1 = 0; 
2772:  CLRF   xA2
2774:  CLRF   xA1
....................       if (en_b1) 
2776:  MOVF   x9E,F
2778:  BZ    2780
....................       {                        // pregunta si esta sonando el par1 
....................          output_low(salida01); // apaga alarma bloqueo 
277A:  BCF    F94.3
277C:  BCF    F8B.3
....................          en_b1 = 0; 
277E:  CLRF   x9E
....................       } 
....................    } 
2780:  BRA    27DC
....................    else 
....................    { 
....................       if (sub_cta1 >= s_cta) 
2782:  MOVF   5E,F
2784:  BNZ   278C
2786:  MOVF   5D,W
2788:  SUBLW  04
278A:  BC    2790
....................          detec1 = 1; // revisa si se interumpio la luz en (5ms*4) 
278C:  MOVLW  01
278E:  MOVWF  x69
....................       if (sub_d1 != detec1) 
2790:  MOVF   x69,W
2792:  SUBWF  x6F,W
2794:  BZ    27DC
....................       { // si, cambia de estado el sensor 
....................          sub_d1 = detec1; 
2796:  MOVFF  69,6F
....................          enable1 = 1; 
279A:  MOVLW  01
279C:  MOVWF  x7A
....................          lcd_gotoxy(5, 2); 
279E:  MOVLW  05
27A0:  MOVLB  1
27A2:  MOVWF  xDC
27A4:  MOVLW  02
27A6:  MOVWF  xDD
27A8:  MOVLB  0
27AA:  CALL   086C
....................          printf(lcd_putc, "1:%d", sub_d1); 
27AE:  MOVLW  31
27B0:  MOVLB  1
27B2:  MOVWF  xDB
27B4:  MOVLB  0
27B6:  CALL   08BE
27BA:  MOVLW  3A
27BC:  MOVLB  1
27BE:  MOVWF  xDB
27C0:  MOVLB  0
27C2:  CALL   08BE
27C6:  MOVFF  6F,1D1
27CA:  MOVLW  18
27CC:  MOVLB  1
27CE:  MOVWF  xD2
27D0:  MOVLB  0
27D2:  CALL   0FC8
....................          sensando1(); 
27D6:  CALL   1CC8
....................          contando1(); 
27DA:  RCALL  20CA
....................       } 
....................    } 
....................    // sensor2 
....................    ent2 = input(entrada02); 
27DC:  BSF    F95.4
27DE:  CLRF   56
27E0:  BTFSC  F83.4
27E2:  INCF   56,F
....................    if (ent2 == 1) 
27E4:  DECFSZ 56,W
27E6:  BRA    2804
....................    { 
....................       output_high(salida02); // 
27E8:  BCF    F94.4
27EA:  BSF    F8B.4
....................       sub_cta2 = 0; 
27EC:  CLRF   x60
27EE:  CLRF   5F
....................       detec2 = 0; 
27F0:  CLRF   x6A
....................       bloq_p1 = 0; // deshabilita bloqueo 
27F2:  CLRF   x9B
....................       tim_p1 = 0; 
27F4:  CLRF   xA2
27F6:  CLRF   xA1
....................       if (en_b1) 
27F8:  MOVF   x9E,F
27FA:  BZ    2802
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
27FC:  BCF    F94.3
27FE:  BCF    F8B.3
....................          en_b1 = 0; 
2800:  CLRF   x9E
....................       } 
....................    } 
2802:  BRA    286C
....................    else 
....................    { 
....................       output_low(salida02); 
2804:  BCF    F94.4
2806:  BCF    F8B.4
....................       if (sub_cta2 >= s_cta) 
2808:  MOVF   x60,F
280A:  BNZ   2812
280C:  MOVF   5F,W
280E:  SUBLW  04
2810:  BC    2816
....................          detec2 = 1; 
2812:  MOVLW  01
2814:  MOVWF  x6A
....................       if (sub_d2 != detec2) 
2816:  MOVF   x6A,W
2818:  SUBWF  x70,W
281A:  BZ    286C
....................       { 
....................          sub_d2 = detec2; 
281C:  MOVFF  6A,70
....................          enable1 = 1; 
2820:  MOVLW  01
2822:  MOVWF  x7A
....................          lcd_gotoxy(1, 2); 
2824:  MOVLB  1
2826:  MOVWF  xDC
2828:  MOVLW  02
282A:  MOVWF  xDD
282C:  MOVLB  0
282E:  CALL   086C
....................          printf(lcd_putc, "2:%d ", sub_d2); 
2832:  MOVLW  32
2834:  MOVLB  1
2836:  MOVWF  xDB
2838:  MOVLB  0
283A:  CALL   08BE
283E:  MOVLW  3A
2840:  MOVLB  1
2842:  MOVWF  xDB
2844:  MOVLB  0
2846:  CALL   08BE
284A:  MOVFF  70,1D1
284E:  MOVLW  18
2850:  MOVLB  1
2852:  MOVWF  xD2
2854:  MOVLB  0
2856:  CALL   0FC8
285A:  MOVLW  20
285C:  MOVLB  1
285E:  MOVWF  xDB
2860:  MOVLB  0
2862:  CALL   08BE
....................          sensando1(); 
2866:  CALL   1CC8
....................          contando1(); 
286A:  RCALL  20CA
....................       } 
....................    } 
....................    // sensor3 
....................    ent3 = input(entrada03); 
286C:  BSF    F93.2
286E:  CLRF   57
2870:  BTFSC  F81.2
2872:  INCF   57,F
....................    if (ent3 == 1) 
2874:  DECFSZ 57,W
2876:  BRA    2890
....................    { 
....................       sub_cta3 = 0; 
2878:  CLRF   x62
287A:  CLRF   x61
....................       detec3 = 0; 
287C:  CLRF   x6B
....................       bloq_p2 = 0; // deshabilita bloqueo 
287E:  CLRF   x9C
....................       tim_p2 = 0; 
2880:  CLRF   xA4
2882:  CLRF   xA3
....................       if (en_b2) 
2884:  MOVF   x9F,F
2886:  BZ    288E
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2888:  BCF    F94.3
288A:  BCF    F8B.3
....................          en_b2 = 0; 
288C:  CLRF   x9F
....................       } 
....................    } 
288E:  BRA    28E8
....................    else 
....................    { 
....................       if (sub_cta3 >= s_cta) 
2890:  MOVF   x62,F
2892:  BNZ   289A
2894:  MOVF   x61,W
2896:  SUBLW  04
2898:  BC    289E
....................          detec3 = 1; 
289A:  MOVLW  01
289C:  MOVWF  x6B
....................       if (sub_d3 != detec3) 
289E:  MOVF   x6B,W
28A0:  SUBWF  x71,W
28A2:  BZ    28E8
....................       { 
....................          sub_d3 = detec3; 
28A4:  MOVFF  6B,71
....................          enable2 = 1; 
28A8:  MOVLW  01
28AA:  MOVWF  x81
....................          lcd_gotoxy(5, 3); 
28AC:  MOVLW  05
28AE:  MOVLB  1
28B0:  MOVWF  xDC
28B2:  MOVLW  03
28B4:  MOVWF  xDD
28B6:  MOVLB  0
28B8:  CALL   086C
....................          printf(lcd_putc, "3:%d", sub_d3); 
28BC:  MOVLW  33
28BE:  MOVLB  1
28C0:  MOVWF  xDB
28C2:  MOVLB  0
28C4:  CALL   08BE
28C8:  MOVLW  3A
28CA:  MOVLB  1
28CC:  MOVWF  xDB
28CE:  MOVLB  0
28D0:  CALL   08BE
28D4:  MOVFF  71,1D1
28D8:  MOVLW  18
28DA:  MOVLB  1
28DC:  MOVWF  xD2
28DE:  MOVLB  0
28E0:  CALL   0FC8
....................          sensando2(); 
28E4:  RCALL  214C
....................          contando2(); 
28E6:  RCALL  23D2
....................       } 
....................    } 
....................    // sensor4 
....................    ent4 = input(entrada04); 
28E8:  BSF    F93.3
28EA:  CLRF   58
28EC:  BTFSC  F81.3
28EE:  INCF   58,F
....................    if (ent4 == 1) 
28F0:  DECFSZ 58,W
28F2:  BRA    2910
....................    { 
....................       output_high(salida02); // 
28F4:  BCF    F94.4
28F6:  BSF    F8B.4
....................       sub_cta4 = 0; 
28F8:  CLRF   x64
28FA:  CLRF   x63
....................       detec4 = 0; 
28FC:  CLRF   x6C
....................       bloq_p2 = 0; // deshabilita bloqueo 
28FE:  CLRF   x9C
....................       tim_p2 = 0; 
2900:  CLRF   xA4
2902:  CLRF   xA3
....................       if (en_b2) 
2904:  MOVF   x9F,F
2906:  BZ    290E
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2908:  BCF    F94.3
290A:  BCF    F8B.3
....................          en_b2 = 0; 
290C:  CLRF   x9F
....................       } 
....................    } 
290E:  BRA    2978
....................    else 
....................    { 
....................       output_low(salida02); 
2910:  BCF    F94.4
2912:  BCF    F8B.4
....................       if (sub_cta4 >= s_cta) 
2914:  MOVF   x64,F
2916:  BNZ   291E
2918:  MOVF   x63,W
291A:  SUBLW  04
291C:  BC    2922
....................          detec4 = 1; 
291E:  MOVLW  01
2920:  MOVWF  x6C
....................       if (sub_d4 != detec4) 
2922:  MOVF   x6C,W
2924:  SUBWF  x72,W
2926:  BZ    2978
....................       { 
....................          sub_d4 = detec4; 
2928:  MOVFF  6C,72
....................          enable2 = 1; 
292C:  MOVLW  01
292E:  MOVWF  x81
....................          lcd_gotoxy(1, 3); 
2930:  MOVLB  1
2932:  MOVWF  xDC
2934:  MOVLW  03
2936:  MOVWF  xDD
2938:  MOVLB  0
293A:  CALL   086C
....................          printf(lcd_putc, "4:%d ", sub_d4); 
293E:  MOVLW  34
2940:  MOVLB  1
2942:  MOVWF  xDB
2944:  MOVLB  0
2946:  CALL   08BE
294A:  MOVLW  3A
294C:  MOVLB  1
294E:  MOVWF  xDB
2950:  MOVLB  0
2952:  CALL   08BE
2956:  MOVFF  72,1D1
295A:  MOVLW  18
295C:  MOVLB  1
295E:  MOVWF  xD2
2960:  MOVLB  0
2962:  CALL   0FC8
2966:  MOVLW  20
2968:  MOVLB  1
296A:  MOVWF  xDB
296C:  MOVLB  0
296E:  CALL   08BE
....................          sensando2(); 
2972:  CALL   214C
....................          contando2(); 
2976:  RCALL  23D2
....................       } 
....................    } 
....................    // sensor5 
....................    ent5 = input(entrada05); 
2978:  BSF    F93.0
297A:  CLRF   59
297C:  BTFSC  F81.0
297E:  INCF   59,F
....................    if (ent5 == 1) 
2980:  DECFSZ 59,W
2982:  BRA    299C
....................    { 
....................       sub_cta5 = 0; 
2984:  CLRF   x66
2986:  CLRF   x65
....................       detec5 = 0; 
2988:  CLRF   x6D
....................       bloq_p3 = 0; // deshabilita bloqueo 
298A:  CLRF   x9D
....................       tim_p3 = 0; 
298C:  CLRF   xA6
298E:  CLRF   xA5
....................       if (en_b3) 
2990:  MOVF   xA0,F
2992:  BZ    299A
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2994:  BCF    F94.3
2996:  BCF    F8B.3
....................          en_b3 = 0; 
2998:  CLRF   xA0
....................       } 
....................    } 
299A:  BRA    29F4
....................    else 
....................    { 
....................       if (sub_cta5 >= s_cta) 
299C:  MOVF   x66,F
299E:  BNZ   29A6
29A0:  MOVF   x65,W
29A2:  SUBLW  04
29A4:  BC    29AA
....................          detec5 = 1; 
29A6:  MOVLW  01
29A8:  MOVWF  x6D
....................       if (sub_d5 != detec5) 
29AA:  MOVF   x6D,W
29AC:  SUBWF  x73,W
29AE:  BZ    29F4
....................       { 
....................          sub_d5 = detec5; 
29B0:  MOVFF  6D,73
....................          enable3 = 1; 
29B4:  MOVLW  01
29B6:  MOVWF  x88
....................          lcd_gotoxy(5, 4); 
29B8:  MOVLW  05
29BA:  MOVLB  1
29BC:  MOVWF  xDC
29BE:  MOVLW  04
29C0:  MOVWF  xDD
29C2:  MOVLB  0
29C4:  CALL   086C
....................          printf(lcd_putc, "5:%d", sub_d5); 
29C8:  MOVLW  35
29CA:  MOVLB  1
29CC:  MOVWF  xDB
29CE:  MOVLB  0
29D0:  CALL   08BE
29D4:  MOVLW  3A
29D6:  MOVLB  1
29D8:  MOVWF  xDB
29DA:  MOVLB  0
29DC:  CALL   08BE
29E0:  MOVFF  73,1D1
29E4:  MOVLW  18
29E6:  MOVLB  1
29E8:  MOVWF  xD2
29EA:  MOVLB  0
29EC:  CALL   0FC8
....................          sensando3(); 
29F0:  RCALL  2454
....................          contando3(); 
29F2:  RCALL  26DC
....................       } 
....................    } 
....................    // sensor6 
....................    ent6 = input(entrada06); 
29F4:  BSF    F93.1
29F6:  CLRF   5A
29F8:  BTFSC  F81.1
29FA:  INCF   5A,F
....................    if (ent6 == 1) 
29FC:  DECFSZ 5A,W
29FE:  BRA    2A1C
....................    { 
....................       output_high(salida02); // 
2A00:  BCF    F94.4
2A02:  BSF    F8B.4
....................       sub_cta6 = 0; 
2A04:  CLRF   x68
2A06:  CLRF   x67
....................       detec6 = 0; 
2A08:  CLRF   x6E
....................       bloq_p3 = 0; // deshabilita bloqueo 
2A0A:  CLRF   x9D
....................       tim_p3 = 0; 
2A0C:  CLRF   xA6
2A0E:  CLRF   xA5
....................       if (en_b3) 
2A10:  MOVF   xA0,F
2A12:  BZ    2A1A
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2A14:  BCF    F94.3
2A16:  BCF    F8B.3
....................          en_b3 = 0; 
2A18:  CLRF   xA0
....................       } 
....................    } 
2A1A:  BRA    2A82
....................    else 
....................    { 
....................       output_low(salida02); // 
2A1C:  BCF    F94.4
2A1E:  BCF    F8B.4
....................       if (sub_cta6 >= s_cta) 
2A20:  MOVF   x68,F
2A22:  BNZ   2A2A
2A24:  MOVF   x67,W
2A26:  SUBLW  04
2A28:  BC    2A2E
....................          detec6 = 1; 
2A2A:  MOVLW  01
2A2C:  MOVWF  x6E
....................       if (sub_d6 != detec6) 
2A2E:  MOVF   x6E,W
2A30:  SUBWF  x74,W
2A32:  BZ    2A82
....................       { 
....................          sub_d6 = detec6; 
2A34:  MOVFF  6E,74
....................          enable3 = 1; 
2A38:  MOVLW  01
2A3A:  MOVWF  x88
....................          lcd_gotoxy(1, 4); 
2A3C:  MOVLB  1
2A3E:  MOVWF  xDC
2A40:  MOVLW  04
2A42:  MOVWF  xDD
2A44:  MOVLB  0
2A46:  CALL   086C
....................          printf(lcd_putc, "6:%d ", sub_d6); 
2A4A:  MOVLW  36
2A4C:  MOVLB  1
2A4E:  MOVWF  xDB
2A50:  MOVLB  0
2A52:  CALL   08BE
2A56:  MOVLW  3A
2A58:  MOVLB  1
2A5A:  MOVWF  xDB
2A5C:  MOVLB  0
2A5E:  CALL   08BE
2A62:  MOVFF  74,1D1
2A66:  MOVLW  18
2A68:  MOVLB  1
2A6A:  MOVWF  xD2
2A6C:  MOVLB  0
2A6E:  CALL   0FC8
2A72:  MOVLW  20
2A74:  MOVLB  1
2A76:  MOVWF  xDB
2A78:  MOVLB  0
2A7A:  CALL   08BE
....................          sensando3(); 
2A7E:  RCALL  2454
....................          contando3(); 
2A80:  RCALL  26DC
....................       } 
....................    } 
....................    ////////////////////////// 
....................    if ((detec1 == 1) && (detec2 == 1) && (bloq_p1 == 0)) 
2A82:  DECFSZ x69,W
2A84:  BRA    2A96
2A86:  DECFSZ x6A,W
2A88:  BRA    2A96
2A8A:  MOVF   x9B,F
2A8C:  BNZ   2A96
....................    { 
....................       bloq_p1 = 1; 
2A8E:  MOVLW  01
2A90:  MOVWF  x9B
....................       tim_p1 = 0; 
2A92:  CLRF   xA2
2A94:  CLRF   xA1
....................    } 
....................    if ((detec3 == 1) && (detec4 == 1) && (bloq_p2 == 0)) 
2A96:  DECFSZ x6B,W
2A98:  BRA    2AAA
2A9A:  DECFSZ x6C,W
2A9C:  BRA    2AAA
2A9E:  MOVF   x9C,F
2AA0:  BNZ   2AAA
....................    { 
....................       bloq_p2 = 1; 
2AA2:  MOVLW  01
2AA4:  MOVWF  x9C
....................       tim_p2 = 0; 
2AA6:  CLRF   xA4
2AA8:  CLRF   xA3
....................    } 
....................    if ((detec5 == 1) && (detec6 == 1) && (bloq_p3 == 0)) 
2AAA:  DECFSZ x6D,W
2AAC:  BRA    2ABE
2AAE:  DECFSZ x6E,W
2AB0:  BRA    2ABE
2AB2:  MOVF   x9D,F
2AB4:  BNZ   2ABE
....................    { 
....................       bloq_p3 = 1; 
2AB6:  MOVLW  01
2AB8:  MOVWF  x9D
....................       tim_p3 = 0; 
2ABA:  CLRF   xA6
2ABC:  CLRF   xA5
....................    } 
2ABE:  GOTO   3272 (RETURN)
.................... } // end sensores 
....................  
.................... void sentidos() 
.................... { // Define si la persona esta entrando o saliendo 
....................    if ((!sen_ent) && (!sen_sal)) 
*
1C7E:  MOVF   5B,F
1C80:  BNZ   1CC6
1C82:  MOVF   5C,F
1C84:  BNZ   1CC6
....................    { 
....................       if (((detec1 == 1) && (detec3 == 1)) || ((detec1 == 1) && (detec5 == 1)) || ((detec3 == 1) && (detec5 == 1))) 
1C86:  DECFSZ x69,W
1C88:  BRA    1C90
1C8A:  DECFSZ x6B,W
1C8C:  BRA    1C90
1C8E:  BRA    1CA2
1C90:  DECFSZ x69,W
1C92:  BRA    1C9A
1C94:  DECFSZ x6D,W
1C96:  BRA    1C9A
1C98:  BRA    1CA2
1C9A:  DECFSZ x6B,W
1C9C:  BRA    1CA6
1C9E:  DECFSZ x6D,W
1CA0:  BRA    1CA6
....................       { 
....................          sen_ent = 1; 
1CA2:  MOVLW  01
1CA4:  MOVWF  5B
....................          //!      lcd_gotoxy(17,4); 
....................          //!      lcd_putc("Sub"); 
....................       } 
....................       if (((detec2 == 1) && (detec4 == 1)) || ((detec2 == 1) && (detec6 == 1)) || ((detec4 == 1) && (detec6 == 1))) 
1CA6:  DECFSZ x6A,W
1CA8:  BRA    1CB0
1CAA:  DECFSZ x6C,W
1CAC:  BRA    1CB0
1CAE:  BRA    1CC2
1CB0:  DECFSZ x6A,W
1CB2:  BRA    1CBA
1CB4:  DECFSZ x6E,W
1CB6:  BRA    1CBA
1CB8:  BRA    1CC2
1CBA:  DECFSZ x6C,W
1CBC:  BRA    1CC6
1CBE:  DECFSZ x6E,W
1CC0:  BRA    1CC6
....................       { 
....................          sen_sal = 1; 
1CC2:  MOVLW  01
1CC4:  MOVWF  5C
....................          //!      lcd_gotoxy(17,4); 
....................          //!      lcd_putc("Baj"); 
....................       } 
....................    } 
1CC6:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void rd_eeprom() 
.................... { // Revisa si cadena recibida es un instruccion 
....................    a = b = 0; 
....................    n = word_size; // 
....................    // i=0; 
....................    // i=2; 
....................    while ((b <= data_set) && (a == 0)) 
....................    { // NUMERO TOTAL DE INSTRUCCIONES 
....................       i = 0; 
....................       b++; 
....................       while (i < word_size) 
....................       { // word_size=10 
....................          memory[i] = read_eeprom(n + i); 
....................  
....................          if (memory[i] != XX[i]) 
....................             break; 
....................          i++; 
....................          if (i == word_size) 
....................             a = 1; 
....................       } 
....................       // fprintf(monitor,"memory:%s\r",memory); 
....................       n = n + word_size; // WORD_SIZE=30 
....................       restart_wdt(); 
....................    } 
.................... } 
.................... */ 
....................  
.................... void rd_eeprom_inicio() 
.................... { // 
....................    a = b = 0; 
....................    n = word_size; // 
....................  
....................    while (b <= data_set) 
....................    { // NUMERO TOTAL DE INSTRUCCIONES 
....................       i = 0; 
....................       b++; 
....................       while (i < word_size) 
....................       { // word_size=10 
....................          memory[i] = read_eeprom(n + i); 
....................          i++; 
....................          if (i == word_size) 
....................             a = 1; 
....................       } 
....................       fprintf(monitor, "memory:%s\r", memory); 
....................       n = n + word_size; // WORD_SIZE=30 
....................    } 
.................... } 
....................  
.................... void lcd_cuentas() 
.................... { // Escribe las cuenta en LCD 
....................    lcd_gotoxy(1, 1); 
*
0A62:  MOVLW  01
0A64:  MOVLB  1
0A66:  MOVWF  xDC
0A68:  MOVWF  xDD
0A6A:  MOVLB  0
0A6C:  RCALL  086C
....................    if (master) 
0A6E:  MOVF   45,F
0A70:  BTFSC  FD8.2
0A72:  BRA    0B92
....................    { 
....................       printf(lcd_putc, "1 %c%c%c%c%c ", version[0], version[1], version[2], version[3], version[4]); 
0A74:  MOVLW  31
0A76:  MOVLB  1
0A78:  MOVWF  xDB
0A7A:  MOVLB  0
0A7C:  RCALL  08BE
0A7E:  MOVLW  20
0A80:  MOVLB  1
0A82:  MOVWF  xDB
0A84:  MOVLB  0
0A86:  RCALL  08BE
0A88:  MOVFF  18C,1DB
0A8C:  RCALL  08BE
0A8E:  MOVFF  18D,1DB
0A92:  RCALL  08BE
0A94:  MOVFF  18E,1DB
0A98:  RCALL  08BE
0A9A:  MOVFF  18F,1DB
0A9E:  RCALL  08BE
0AA0:  MOVFF  190,1DB
0AA4:  RCALL  08BE
0AA6:  MOVLW  20
0AA8:  MOVLB  1
0AAA:  MOVWF  xDB
0AAC:  MOVLB  0
0AAE:  RCALL  08BE
....................       lcd_gotoxy(14, 1); 
0AB0:  MOVLW  0E
0AB2:  MOVLB  1
0AB4:  MOVWF  xDC
0AB6:  MOVLW  01
0AB8:  MOVWF  xDD
0ABA:  MOVLB  0
0ABC:  RCALL  086C
....................       printf(lcd_putc, "S1:%Ld ", entraront); 
0ABE:  MOVLW  AE
0AC0:  MOVWF  FF6
0AC2:  MOVLW  03
0AC4:  MOVWF  FF7
0AC6:  MOVLW  03
0AC8:  MOVLB  1
0ACA:  MOVWF  xD2
0ACC:  MOVLB  0
0ACE:  RCALL  091E
0AD0:  MOVLW  10
0AD2:  MOVWF  FE9
0AD4:  MOVFF  8B,1D3
0AD8:  MOVFF  8A,1D2
0ADC:  RCALL  0946
0ADE:  MOVLW  20
0AE0:  MOVLB  1
0AE2:  MOVWF  xDB
0AE4:  MOVLB  0
0AE6:  RCALL  08BE
....................       lcd_gotoxy(14, 2); 
0AE8:  MOVLW  0E
0AEA:  MOVLB  1
0AEC:  MOVWF  xDC
0AEE:  MOVLW  02
0AF0:  MOVWF  xDD
0AF2:  MOVLB  0
0AF4:  RCALL  086C
....................       printf(lcd_putc, "B1:%Ld ", salieront); 
0AF6:  MOVLW  B6
0AF8:  MOVWF  FF6
0AFA:  MOVLW  03
0AFC:  MOVWF  FF7
0AFE:  MOVLW  03
0B00:  MOVLB  1
0B02:  MOVWF  xD2
0B04:  MOVLB  0
0B06:  RCALL  091E
0B08:  MOVLW  10
0B0A:  MOVWF  FE9
0B0C:  MOVFF  8D,1D3
0B10:  MOVFF  8C,1D2
0B14:  RCALL  0946
0B16:  MOVLW  20
0B18:  MOVLB  1
0B1A:  MOVWF  xDB
0B1C:  MOVLB  0
0B1E:  RCALL  08BE
....................       lcd_gotoxy(14, 3); 
0B20:  MOVLW  0E
0B22:  MOVLB  1
0B24:  MOVWF  xDC
0B26:  MOVLW  03
0B28:  MOVWF  xDD
0B2A:  MOVLB  0
0B2C:  RCALL  086C
....................       printf(lcd_putc, "S2:%Ld ", sub_atras); 
0B2E:  MOVLW  BE
0B30:  MOVWF  FF6
0B32:  MOVLW  03
0B34:  MOVWF  FF7
0B36:  MOVLW  03
0B38:  MOVLB  1
0B3A:  MOVWF  xD2
0B3C:  MOVLB  0
0B3E:  RCALL  091E
0B40:  MOVLW  10
0B42:  MOVWF  FE9
0B44:  MOVFF  35,1D3
0B48:  MOVFF  34,1D2
0B4C:  RCALL  0946
0B4E:  MOVLW  20
0B50:  MOVLB  1
0B52:  MOVWF  xDB
0B54:  MOVLB  0
0B56:  RCALL  08BE
....................       lcd_gotoxy(14, 4); 
0B58:  MOVLW  0E
0B5A:  MOVLB  1
0B5C:  MOVWF  xDC
0B5E:  MOVLW  04
0B60:  MOVWF  xDD
0B62:  MOVLB  0
0B64:  RCALL  086C
....................       printf(lcd_putc, "B2:%Ld ", baj_atras); 
0B66:  MOVLW  C6
0B68:  MOVWF  FF6
0B6A:  MOVLW  03
0B6C:  MOVWF  FF7
0B6E:  MOVLW  03
0B70:  MOVLB  1
0B72:  MOVWF  xD2
0B74:  MOVLB  0
0B76:  RCALL  091E
0B78:  MOVLW  10
0B7A:  MOVWF  FE9
0B7C:  MOVFF  37,1D3
0B80:  MOVFF  36,1D2
0B84:  RCALL  0946
0B86:  MOVLW  20
0B88:  MOVLB  1
0B8A:  MOVWF  xDB
0B8C:  MOVLB  0
0B8E:  RCALL  08BE
....................    } 
0B90:  BRA    0C6E
....................    else 
....................    { 
....................       printf(lcd_putc, "2 %c%c%c%c%c ", version[0], version[1], version[2], version[3], version[4]); 
0B92:  MOVLW  32
0B94:  MOVLB  1
0B96:  MOVWF  xDB
0B98:  MOVLB  0
0B9A:  RCALL  08BE
0B9C:  MOVLW  20
0B9E:  MOVLB  1
0BA0:  MOVWF  xDB
0BA2:  MOVLB  0
0BA4:  RCALL  08BE
0BA6:  MOVFF  18C,1DB
0BAA:  RCALL  08BE
0BAC:  MOVFF  18D,1DB
0BB0:  RCALL  08BE
0BB2:  MOVFF  18E,1DB
0BB6:  RCALL  08BE
0BB8:  MOVFF  18F,1DB
0BBC:  RCALL  08BE
0BBE:  MOVFF  190,1DB
0BC2:  RCALL  08BE
0BC4:  MOVLW  20
0BC6:  MOVLB  1
0BC8:  MOVWF  xDB
0BCA:  MOVLB  0
0BCC:  RCALL  08BE
....................       lcd_gotoxy(14, 1); 
0BCE:  MOVLW  0E
0BD0:  MOVLB  1
0BD2:  MOVWF  xDC
0BD4:  MOVLW  01
0BD6:  MOVWF  xDD
0BD8:  MOVLB  0
0BDA:  RCALL  086C
....................       lcd_putc("S1:    "); 
0BDC:  MOVLW  CE
0BDE:  MOVWF  FF6
0BE0:  MOVLW  03
0BE2:  MOVWF  FF7
0BE4:  RCALL  0A42
....................       lcd_gotoxy(14, 2); 
0BE6:  MOVLW  0E
0BE8:  MOVLB  1
0BEA:  MOVWF  xDC
0BEC:  MOVLW  02
0BEE:  MOVWF  xDD
0BF0:  MOVLB  0
0BF2:  RCALL  086C
....................       lcd_putc("B1:    "); 
0BF4:  MOVLW  D6
0BF6:  MOVWF  FF6
0BF8:  MOVLW  03
0BFA:  MOVWF  FF7
0BFC:  RCALL  0A42
....................       lcd_gotoxy(14, 3); 
0BFE:  MOVLW  0E
0C00:  MOVLB  1
0C02:  MOVWF  xDC
0C04:  MOVLW  03
0C06:  MOVWF  xDD
0C08:  MOVLB  0
0C0A:  RCALL  086C
....................       printf(lcd_putc, "S2:%Ld ", entraront); 
0C0C:  MOVLW  DE
0C0E:  MOVWF  FF6
0C10:  MOVLW  03
0C12:  MOVWF  FF7
0C14:  MOVLW  03
0C16:  MOVLB  1
0C18:  MOVWF  xD2
0C1A:  MOVLB  0
0C1C:  RCALL  091E
0C1E:  MOVLW  10
0C20:  MOVWF  FE9
0C22:  MOVFF  8B,1D3
0C26:  MOVFF  8A,1D2
0C2A:  RCALL  0946
0C2C:  MOVLW  20
0C2E:  MOVLB  1
0C30:  MOVWF  xDB
0C32:  MOVLB  0
0C34:  RCALL  08BE
....................       lcd_gotoxy(14, 4); 
0C36:  MOVLW  0E
0C38:  MOVLB  1
0C3A:  MOVWF  xDC
0C3C:  MOVLW  04
0C3E:  MOVWF  xDD
0C40:  MOVLB  0
0C42:  RCALL  086C
....................       printf(lcd_putc, "B2:%Ld ", salieront); 
0C44:  MOVLW  E6
0C46:  MOVWF  FF6
0C48:  MOVLW  03
0C4A:  MOVWF  FF7
0C4C:  MOVLW  03
0C4E:  MOVLB  1
0C50:  MOVWF  xD2
0C52:  MOVLB  0
0C54:  RCALL  091E
0C56:  MOVLW  10
0C58:  MOVWF  FE9
0C5A:  MOVFF  8D,1D3
0C5E:  MOVFF  8C,1D2
0C62:  RCALL  0946
0C64:  MOVLW  20
0C66:  MOVLB  1
0C68:  MOVWF  xDB
0C6A:  MOVLB  0
0C6C:  RCALL  08BE
....................    } 
0C6E:  RETURN 0
.................... } 
....................  
.................... void write_ent() 
.................... { // Graba en eeprom las subidas del poste 
....................    disable_interrupts(GLOBAL); 
*
0CAE:  BCF    FF2.6
0CB0:  BCF    FF2.7
0CB2:  BTFSC  FF2.7
0CB4:  BRA    0CB0
....................    write_ext_eeprom(2, entraront);        // parte baja 
0CB6:  MOVLB  1
0CB8:  CLRF   xD6
0CBA:  MOVLW  02
0CBC:  MOVWF  xD5
0CBE:  MOVFF  8A,1D7
0CC2:  MOVLB  0
0CC4:  RCALL  05B2
....................    write_ext_eeprom(1, (entraront >> 8)); // parte alta 
0CC6:  MOVFF  8B,1D1
0CCA:  MOVLB  1
0CCC:  CLRF   xD2
0CCE:  CLRF   xD6
0CD0:  MOVLW  01
0CD2:  MOVWF  xD5
0CD4:  MOVFF  8B,1D7
0CD8:  MOVLB  0
0CDA:  RCALL  05B2
....................    enable_interrupts(GLOBAL); 
0CDC:  MOVLW  C0
0CDE:  IORWF  FF2,F
....................    finsuma(); 
0CE0:  RCALL  0C70
0CE2:  RETURN 0
.................... } 
....................  
.................... void write_sal() 
.................... { // Graba en eeprom las bajadas del poste 
....................    disable_interrupts(GLOBAL); 
0CE4:  BCF    FF2.6
0CE6:  BCF    FF2.7
0CE8:  BTFSC  FF2.7
0CEA:  BRA    0CE6
....................    write_ext_eeprom(4, salieront);        // parte baja 
0CEC:  MOVLB  1
0CEE:  CLRF   xD6
0CF0:  MOVLW  04
0CF2:  MOVWF  xD5
0CF4:  MOVFF  8C,1D7
0CF8:  MOVLB  0
0CFA:  RCALL  05B2
....................    write_ext_eeprom(3, (salieront >> 8)); // parte alta 
0CFC:  MOVFF  8D,1D1
0D00:  MOVLB  1
0D02:  CLRF   xD2
0D04:  CLRF   xD6
0D06:  MOVLW  03
0D08:  MOVWF  xD5
0D0A:  MOVFF  8D,1D7
0D0E:  MOVLB  0
0D10:  RCALL  05B2
....................    enable_interrupts(GLOBAL); 
0D12:  MOVLW  C0
0D14:  IORWF  FF2,F
....................    finsuma(); 
0D16:  RCALL  0C70
0D18:  RETURN 0
.................... } 
....................  
.................... void entraron_total() 
.................... { // Graba en eeprom el total de subidas 
....................    disable_interrupts(GLOBAL); 
*
0D86:  BCF    FF2.6
0D88:  BCF    FF2.7
0D8A:  BTFSC  FF2.7
0D8C:  BRA    0D88
....................    unsigned int reg_h = 0, reg_l = 0; 
....................    unsigned int16 total = 0; 
0D8E:  MOVLB  1
0D90:  CLRF   xD1
0D92:  CLRF   xD2
0D94:  CLRF   xD4
0D96:  CLRF   xD3
....................  
....................    reg_h = read_ext_eeprom(1); 
0D98:  CLRF   xD6
0D9A:  MOVLW  01
0D9C:  MOVWF  xD5
0D9E:  MOVLB  0
0DA0:  RCALL  0772
0DA2:  MOVFF  01,1D1
....................    reg_l = read_ext_eeprom(2); 
0DA6:  MOVLB  1
0DA8:  CLRF   xD6
0DAA:  MOVLW  02
0DAC:  MOVWF  xD5
0DAE:  MOVLB  0
0DB0:  RCALL  0772
0DB2:  MOVFF  01,1D2
....................    total = reg_h; 
0DB6:  MOVLB  1
0DB8:  CLRF   xD4
0DBA:  MOVFF  1D1,1D3
....................    total = (total << 8) | reg_l; 
0DBE:  MOVFF  1D3,1D6
0DC2:  CLRF   xD5
0DC4:  MOVF   xD5,W
0DC6:  IORWF  xD2,W
0DC8:  MOVWF  xD3
0DCA:  MOVFF  1D6,1D4
....................    entraront = total; 
0DCE:  MOVFF  1D4,8B
0DD2:  MOVFF  1D3,8A
....................    enable_interrupts(GLOBAL); 
0DD6:  MOVLW  C0
0DD8:  IORWF  FF2,F
0DDA:  MOVLB  0
0DDC:  GOTO   2D20 (RETURN)
.................... } 
....................  
.................... void salieron_total() 
.................... { // Graba en eeprom el total de bajadas 
....................    disable_interrupts(GLOBAL); 
0DE0:  BCF    FF2.6
0DE2:  BCF    FF2.7
0DE4:  BTFSC  FF2.7
0DE6:  BRA    0DE2
....................    unsigned int reg_h = 0, reg_l = 0; 
....................    unsigned int16 total = 0; 
0DE8:  MOVLB  1
0DEA:  CLRF   xD1
0DEC:  CLRF   xD2
0DEE:  CLRF   xD4
0DF0:  CLRF   xD3
....................  
....................    reg_h = read_ext_eeprom(3); 
0DF2:  CLRF   xD6
0DF4:  MOVLW  03
0DF6:  MOVWF  xD5
0DF8:  MOVLB  0
0DFA:  RCALL  0772
0DFC:  MOVFF  01,1D1
....................    reg_l = read_ext_eeprom(4); 
0E00:  MOVLB  1
0E02:  CLRF   xD6
0E04:  MOVLW  04
0E06:  MOVWF  xD5
0E08:  MOVLB  0
0E0A:  RCALL  0772
0E0C:  MOVFF  01,1D2
....................    total = reg_h; 
0E10:  MOVLB  1
0E12:  CLRF   xD4
0E14:  MOVFF  1D1,1D3
....................    total = (total << 8) | reg_l; 
0E18:  MOVFF  1D3,1D6
0E1C:  CLRF   xD5
0E1E:  MOVF   xD5,W
0E20:  IORWF  xD2,W
0E22:  MOVWF  xD3
0E24:  MOVFF  1D6,1D4
....................    salieront = total; 
0E28:  MOVFF  1D4,8D
0E2C:  MOVFF  1D3,8C
....................    enable_interrupts(GLOBAL); 
0E30:  MOVLW  C0
0E32:  IORWF  FF2,F
0E34:  MOVLB  0
0E36:  GOTO   2D24 (RETURN)
.................... } 
....................  
.................... void graba_conta2() 
.................... { // Graba en eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
06B8:  BCF    FF2.6
06BA:  BCF    FF2.7
06BC:  BTFSC  FF2.7
06BE:  BRA    06BA
....................    unsigned int reg_hc = 0, reg_lc = 0; 
....................    unsigned int16 totalc = 0; 
06C0:  MOVLB  1
06C2:  CLRF   xD1
06C4:  CLRF   xD2
06C6:  CLRF   xD4
06C8:  CLRF   xD3
....................    totalc = 0; 
06CA:  CLRF   xD4
06CC:  CLRF   xD3
....................    reg_lc = 0; 
06CE:  CLRF   xD2
....................    reg_hc = 0; 
06D0:  CLRF   xD1
....................  
....................    totalc = salian; 
06D2:  MOVFF  3D,1D4
06D6:  MOVFF  3C,1D3
....................    reg_lc = totalc; 
06DA:  MOVFF  1D3,1D2
....................    reg_hc = totalc >> 8; 
06DE:  MOVFF  1D4,1D1
....................    write_ext_eeprom(20, reg_hc); 
06E2:  CLRF   xD6
06E4:  MOVLW  14
06E6:  MOVWF  xD5
06E8:  MOVFF  1D1,1D7
06EC:  MOVLB  0
06EE:  RCALL  05B2
....................    write_ext_eeprom(21, reg_lc); 
06F0:  MOVLB  1
06F2:  CLRF   xD6
06F4:  MOVLW  15
06F6:  MOVWF  xD5
06F8:  MOVFF  1D2,1D7
06FC:  MOVLB  0
06FE:  RCALL  05B2
....................    enable_interrupts(GLOBAL); 
0700:  MOVLW  C0
0702:  IORWF  FF2,F
0704:  RETURN 0
.................... } 
....................  
.................... void leer_conta2() 
.................... { // Carga de eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
081A:  BCF    FF2.6
081C:  BCF    FF2.7
081E:  BTFSC  FF2.7
0820:  BRA    081C
....................    unsigned int reg_hc = 0, reg_lc = 0; 
....................    unsigned int16 totalc = 0; 
0822:  MOVLB  1
0824:  CLRF   xD1
0826:  CLRF   xD2
0828:  CLRF   xD4
082A:  CLRF   xD3
....................  
....................    reg_hc = read_ext_eeprom(20); 
082C:  CLRF   xD6
082E:  MOVLW  14
0830:  MOVWF  xD5
0832:  MOVLB  0
0834:  RCALL  0772
0836:  MOVFF  01,1D1
....................    reg_lc = read_ext_eeprom(21); 
083A:  MOVLB  1
083C:  CLRF   xD6
083E:  MOVLW  15
0840:  MOVWF  xD5
0842:  MOVLB  0
0844:  RCALL  0772
0846:  MOVFF  01,1D2
....................    totalc = reg_hc; 
084A:  MOVLB  1
084C:  CLRF   xD4
084E:  MOVFF  1D1,1D3
....................    totalc = totalc << 8; 
0852:  MOVFF  1D3,1D4
0856:  CLRF   xD3
....................    totalc = totalc | reg_lc; 
0858:  MOVF   xD2,W
085A:  IORWF  xD3,F
....................    salian = totalc; 
085C:  MOVFF  1D4,3D
0860:  MOVFF  1D3,3C
....................    enable_interrupts(GLOBAL); 
0864:  MOVLW  C0
0866:  IORWF  FF2,F
0868:  MOVLB  0
086A:  RETURN 0
.................... } 
....................  
.................... void reset() 
.................... { 
....................    switch (restart_cause()) 
*
0E5C:  MOVF   FD0,W
0E5E:  ANDLW  0F
0E60:  BTFSS  FD0.4
0E62:  MOVLW  00
0E64:  BSF    FD0.0
0E66:  BSF    FD0.1
0E68:  BSF    FD0.4
0E6A:  BSF    FD8.3
0E6C:  BSF    FD8.4
0E6E:  XORLW  07
0E70:  BZ    0E80
0E72:  XORLW  08
0E74:  BZ    0E82
0E76:  XORLW  01
0E78:  BZ    0E8E
0E7A:  XORLW  02
0E7C:  BZ    0E90
0E7E:  BRA    0E90
....................    { 
....................    case WDT_TIMEOUT: 
....................    { // lcd_putc("REINICIO-WD");// 
....................       break; 
0E80:  BRA    0E90
....................    } 
....................    case MCLR_FROM_RUN: // avisa que reinicio por master clear 
....................    { 
....................       fprintf(monitor, "SERIALTEST\r\n"); 
0E82:  MOVLW  EE
0E84:  MOVWF  FF6
0E86:  MOVLW  03
0E88:  MOVWF  FF7
0E8A:  RCALL  0E3A
....................       break; 
0E8C:  BRA    0E90
....................    } 
....................    case BROWNOUT_RESTART: // avisa que el pic reinicio por un voltaje menor a 4v 
....................    { 
....................       break; 
0E8E:  BRA    0E90
....................    } 
....................    case NORMAL_POWER_UP: 
....................    { 
....................       break; 
....................    } // END MODO 
....................    } 
0E90:  GOTO   2E02 (RETURN)
.................... } 
....................  
.................... //// evalua el comando obetenido del serial nato /////////////////// 
.................... int evaluar_string(char *command[]) 
*
0F0E:  MOVLB  1
0F10:  CLRF   xD3
.................... { 
....................    int conteo_command = 0; 
....................    int iresult; 
....................    //// recorremos los 11 comandos definidos en textosearxch[] //////// 
....................    while (conteo_command <= 10) 
0F12:  MOVF   xD3,W
0F14:  SUBLW  0A
0F16:  BNC   0F5E
....................    { 
....................       iresult = strcoll(textosearch[conteo_command], command); 
0F18:  CLRF   03
0F1A:  MOVFF  1D3,02
0F1E:  BCF    FD8.0
0F20:  RLCF   02,F
0F22:  RLCF   03,F
0F24:  MOVF   02,W
0F26:  ADDLW  F2
0F28:  MOVWF  FE9
0F2A:  MOVLW  00
0F2C:  ADDWFC 03,W
0F2E:  MOVWF  FEA
0F30:  MOVFF  FEC,1D6
0F34:  MOVF   FED,F
0F36:  MOVFF  FEF,1D5
0F3A:  MOVFF  1D6,1D8
0F3E:  MOVFF  1D5,1D7
0F42:  MOVFF  1D2,1DA
0F46:  MOVFF  1D1,1D9
0F4A:  MOVLB  0
0F4C:  BRA    0E94
0F4E:  MOVFF  01,1D4
....................       //// si se encontr el comando en la lista entonces deja de buscar // 
....................       if (iresult == 0) 
0F52:  MOVLB  1
0F54:  MOVF   xD4,F
0F56:  BNZ   0F5A
....................       { 
....................          break; 
0F58:  BRA    0F5E
....................       } 
....................       conteo_command++; 
0F5A:  INCF   xD3,F
0F5C:  BRA    0F12
....................    } 
....................  
....................    //// si parte del comando es o empieza con "ASAJEROS" entra caso 5 // 
....................    if (XX[1] == 'A' && XX[2] == 'S' && XX[3] == 'A' && XX[4] == 'J' && XX[5] == 'E' && XX[6] == 'R' && XX[7] == 'O' && XX[8] == 'S') 
0F5E:  MOVF   x93,W
0F60:  SUBLW  41
0F62:  BNZ   0F92
0F64:  MOVF   x94,W
0F66:  SUBLW  53
0F68:  BNZ   0F92
0F6A:  MOVF   x95,W
0F6C:  SUBLW  41
0F6E:  BNZ   0F92
0F70:  MOVF   x96,W
0F72:  SUBLW  4A
0F74:  BNZ   0F92
0F76:  MOVF   x97,W
0F78:  SUBLW  45
0F7A:  BNZ   0F92
0F7C:  MOVF   x98,W
0F7E:  SUBLW  52
0F80:  BNZ   0F92
0F82:  MOVF   x99,W
0F84:  SUBLW  4F
0F86:  BNZ   0F92
0F88:  MOVF   x9A,W
0F8A:  SUBLW  53
0F8C:  BNZ   0F92
....................    { 
....................       conteo_command = 5; 
0F8E:  MOVLW  05
0F90:  MOVWF  xD3
....................    } 
....................    /// retorna valor de comando para validar /////////////////////////// 
....................    return conteo_command; 
0F92:  MOVFF  1D3,01
0F96:  MOVLB  0
0F98:  GOTO   2E96 (RETURN)
.................... } 
....................  
.................... void cuenta_pulsos() 
.................... { // Pulsos de subida para impresion (flanco alto) 
....................    output_high(salida03); 
*
1838:  BCF    F94.5
183A:  BSF    F8B.5
....................    rev_suben(); 
183C:  RCALL  1826
....................    time_s3 = 0; 
183E:  CLRF   xB2
....................    fls3 = 1; 
1840:  MOVLW  01
1842:  MOVWF  xB3
....................    cta_pulsos++; 
1844:  INCF   xB4,F
1846:  RETURN 0
.................... } 
....................  
.................... void rev_suben() 
.................... { 
....................    if (!master) 
*
1826:  MOVF   45,F
1828:  BNZ   1836
....................    { 
....................       fprintf(monitor, "SUBIENDOC2"); // 
182A:  MOVLW  FC
182C:  MOVWF  FF6
182E:  MOVLW  03
1830:  MOVWF  FF7
1832:  CALL   0E3A
....................    } 
1836:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 181E   PUT BROWNOUT BORV21 NOWDT WDT4096
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
