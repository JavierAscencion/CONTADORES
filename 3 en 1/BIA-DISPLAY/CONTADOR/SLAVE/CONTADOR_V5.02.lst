CCS PCH C Compiler, Version 5.025, 24934               30-may.-22 11:50

               Filename:   D:\PROYECTOS\TRANSPORTE\CONTADORES\3 en 1\BIA-DISPLAY\CONTADOR\SLAVE\CONTADOR_V5.02.lst

               ROM used:   13074 bytes (40%)
                           Largest free fragment is 19690
               RAM used:   396 (26%) at main() level
                           419 (27%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2AB2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   01E2
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   00CE
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F4580.h> 
.................... //////////// Standard Header file for the PIC18F4580 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4580 
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 28,0C
00CC:  DATA 01,06
*
023C:  DATA 42,4F
023E:  DATA 52,52
0240:  DATA 41,52
0242:  DATA 5F,41
0244:  DATA 4C,4C
0246:  DATA 0D,00
0248:  DATA 0C,42
024A:  DATA 4F,52
024C:  DATA 52,41
024E:  DATA 52,5F
0250:  DATA 41,4C
0252:  DATA 4C,00
0254:  DATA 42,4F
0256:  DATA 52,52
0258:  DATA 41,52
025A:  DATA 5F,41
025C:  DATA 4C,4C
025E:  DATA 0D,00
0260:  DATA 52,45
0262:  DATA 53,45
0264:  DATA 54,5F
0266:  DATA 4F,4B
0268:  DATA 0D,0A
026A:  DATA 00,00
026C:  DATA 42,4F
026E:  DATA 52,52
0270:  DATA 41,52
0272:  DATA 5F,41
0274:  DATA 4C,4C
0276:  DATA 0D,00
0278:  DATA 43,32
027A:  DATA 4F,4B
027C:  DATA 00,00
027E:  DATA 43,31
0280:  DATA 4F,4B
0282:  DATA 00,00
0284:  DATA 53,45
0286:  DATA 52,49
0288:  DATA 41,4C
028A:  DATA 5F,54
028C:  DATA 4F,4B
028E:  DATA 0D,00
0290:  DATA 43,32
0292:  DATA 4F,4B
0294:  DATA 00,00
0296:  DATA 53,75
0298:  DATA 62,32
029A:  DATA 00,00
029C:  DATA 20,20
029E:  DATA 20,20
02A0:  DATA 00,00
02A2:  DATA 20,20
02A4:  DATA 20,20
02A6:  DATA 00,00
02A8:  DATA 20,20
02AA:  DATA 20,20
02AC:  DATA 00,00
02AE:  DATA 42,4C
02B0:  DATA 00,00
02B2:  DATA 42,4C
02B4:  DATA 00,00
02B6:  DATA 42,4C
02B8:  DATA 00,00
02BA:  DATA 20,20
02BC:  DATA 00,00
02BE:  DATA 53,4F
02C0:  DATA 4C,49
02C2:  DATA 43,49
02C4:  DATA 54,41
02C6:  DATA 44,4F
02C8:  DATA 0D,00
02CA:  DATA 50,41
02CC:  DATA 53,41
02CE:  DATA 4A,45
02D0:  DATA 52,4F
02D2:  DATA 53,3A
02D4:  DATA 25,30
02D6:  DATA 34,4C
02D8:  DATA 64,2F
02DA:  DATA 25,30
02DC:  DATA 34,4C
02DE:  DATA 64,2F
02E0:  DATA 25,30
02E2:  DATA 33,4C
02E4:  DATA 64,2F
02E6:  DATA 25,30
02E8:  DATA 34,4C
02EA:  DATA 75,2F
02EC:  DATA 0D,00
02EE:  DATA 41,43
02F0:  DATA 43,2B
02F2:  DATA 30,31
02F4:  DATA 3A,25
02F6:  DATA 30,34
02F8:  DATA 4C,75
02FA:  DATA 2C,25
02FC:  DATA 30,34
02FE:  DATA 4C,75
0300:  DATA 2C,25
0302:  DATA 30,34
0304:  DATA 4C,75
0306:  DATA 2C,25
0308:  DATA 30,33
030A:  DATA 4C,75
030C:  DATA 2C,25
030E:  DATA 30,33
0310:  DATA 4C,75
0312:  DATA 2C,25
0314:  DATA 30,32
0316:  DATA 75,2C
0318:  DATA 0D,0A
031A:  DATA 00,00
031C:  DATA 41,43
031E:  DATA 43,2B
0320:  DATA 30,31
0322:  DATA 3A,25
0324:  DATA 30,34
0326:  DATA 4C,75
0328:  DATA 2C,25
032A:  DATA 30,34
032C:  DATA 4C,75
032E:  DATA 2C,44
0330:  DATA 45,53
0332:  DATA 43,2C
0334:  DATA 25,30
0336:  DATA 33,4C
0338:  DATA 75,2C
033A:  DATA 30,30
033C:  DATA 30,2C
033E:  DATA 25,30
0340:  DATA 32,75
0342:  DATA 2C,0D
0344:  DATA 0A,00
0346:  DATA 44,45
0348:  DATA 53,43
034A:  DATA 00,00
034C:  DATA 0C,00
034E:  DATA 20,00
0350:  DATA 20,00
0352:  DATA 20,00
0354:  DATA 20,00
0356:  DATA 20,00
0358:  DATA 20,00
035A:  DATA 20,00
035C:  DATA 20,00
035E:  DATA 20,00
0360:  DATA 20,00
0362:  DATA 20,00
0364:  DATA 20,00
0366:  DATA 6D,65
0368:  DATA 6D,6F
036A:  DATA 72,79
036C:  DATA 3A,25
036E:  DATA 73,0D
0370:  DATA 00,00
0372:  DATA 53,31
0374:  DATA 3A,25
0376:  DATA 4C,64
0378:  DATA 20,00
037A:  DATA 42,31
037C:  DATA 3A,25
037E:  DATA 4C,64
0380:  DATA 20,00
0382:  DATA 53,32
0384:  DATA 3A,25
0386:  DATA 4C,64
0388:  DATA 20,00
038A:  DATA 42,32
038C:  DATA 3A,25
038E:  DATA 4C,64
0390:  DATA 20,00
0392:  DATA 53,31
0394:  DATA 3A,20
0396:  DATA 20,20
0398:  DATA 20,00
039A:  DATA 42,31
039C:  DATA 3A,20
039E:  DATA 20,20
03A0:  DATA 20,00
03A2:  DATA 53,32
03A4:  DATA 3A,25
03A6:  DATA 4C,64
03A8:  DATA 20,00
03AA:  DATA 42,32
03AC:  DATA 3A,25
03AE:  DATA 4C,64
03B0:  DATA 20,00
03B2:  DATA 53,45
03B4:  DATA 52,49
03B6:  DATA 41,4C
03B8:  DATA 54,45
03BA:  DATA 53,54
03BC:  DATA 0D,00
*
08D4:  TBLRD*+
08D6:  MOVFF  FF6,18B
08DA:  MOVFF  FF7,18C
08DE:  MOVFF  FF5,193
08E2:  RCALL  0874
08E4:  MOVFF  18B,FF6
08E8:  MOVFF  18C,FF7
08EC:  MOVLB  1
08EE:  DECFSZ x8A,F
08F0:  BRA    08F4
08F2:  BRA    08F8
08F4:  MOVLB  0
08F6:  BRA    08D4
08F8:  MOVLB  0
08FA:  RETURN 0
08FC:  MOVFF  FEA,192
0900:  MOVFF  FE9,191
0904:  MOVLB  1
0906:  BTFSS  x8B.7
0908:  BRA    091A
090A:  BSF    x91.7
090C:  BTFSS  x91.4
090E:  INCF   x91,F
0910:  COMF   x8A,F
0912:  COMF   x8B,F
0914:  INCF   x8A,F
0916:  BTFSC  FD8.2
0918:  INCF   x8B,F
091A:  SWAPF  x8B,W
091C:  IORLW  F0
091E:  MOVWF  x8D
0920:  ADDWF  x8D,F
0922:  ADDLW  E2
0924:  MOVWF  x8E
0926:  ADDLW  32
0928:  MOVWF  x90
092A:  MOVF   x8B,W
092C:  ANDLW  0F
092E:  ADDWF  x8E,F
0930:  ADDWF  x8E,F
0932:  ADDWF  x90,F
0934:  ADDLW  E9
0936:  MOVWF  x8F
0938:  ADDWF  x8F,F
093A:  ADDWF  x8F,F
093C:  SWAPF  x8A,W
093E:  ANDLW  0F
0940:  ADDWF  x8F,F
0942:  ADDWF  x90,F
0944:  RLCF   x8F,F
0946:  RLCF   x90,F
0948:  COMF   x90,F
094A:  RLCF   x90,F
094C:  MOVF   x8A,W
094E:  ANDLW  0F
0950:  ADDWF  x90,F
0952:  RLCF   x8D,F
0954:  MOVLW  07
0956:  MOVWF  x8C
0958:  MOVLW  0A
095A:  DECF   x8F,F
095C:  ADDWF  x90,F
095E:  BNC   095A
0960:  DECF   x8E,F
0962:  ADDWF  x8F,F
0964:  BNC   0960
0966:  DECF   x8D,F
0968:  ADDWF  x8E,F
096A:  BNC   0966
096C:  DECF   x8C,F
096E:  ADDWF  x8D,F
0970:  BNC   096C
0972:  MOVLW  01
0974:  MOVWF  FEA
0976:  MOVLW  8C
0978:  MOVWF  FE9
097A:  MOVLW  07
097C:  ANDWF  x91,W
097E:  BCF    x91.6
0980:  MOVF   FED,F
0982:  ANDWF  x91,W
0984:  BNZ   0994
0986:  BTFSC  x91.4
0988:  MOVF   FEE,F
098A:  BTFSC  x91.4
098C:  BRA    0994
098E:  MOVLW  20
0990:  MOVWF  00
0992:  BRA    09D4
0994:  ADDWF  FE9,F
0996:  MOVLW  00
0998:  ADDWFC FEA,F
099A:  MOVF   FE9,W
099C:  SUBLW  90
099E:  BNZ   09A6
09A0:  DECFSZ FEA,W
09A2:  BRA    09A6
09A4:  BSF    x91.6
09A6:  MOVF   FEF,W
09A8:  MOVWF  00
09AA:  BNZ   09BC
09AC:  BTFSC  x91.6
09AE:  BRA    09BC
09B0:  BTFSC  x91.4
09B2:  BRA    09EE
09B4:  BTFSC  x91.3
09B6:  BRA    09BC
09B8:  MOVLW  20
09BA:  BRA    09D2
09BC:  BTFSS  x91.7
09BE:  BRA    09CC
09C0:  MOVLW  2D
09C2:  MOVWF  00
09C4:  MOVF   FED,W
09C6:  BCF    x91.6
09C8:  BCF    x91.7
09CA:  BRA    09D4
09CC:  BSF    x91.3
09CE:  BCF    x91.4
09D0:  MOVLW  30
09D2:  ADDWF  00,F
09D4:  MOVFF  FEA,18B
09D8:  MOVFF  FE9,18A
09DC:  MOVFF  00,193
09E0:  MOVLB  0
09E2:  RCALL  0874
09E4:  MOVFF  18B,FEA
09E8:  MOVFF  18A,FE9
09EC:  MOVLB  1
09EE:  MOVF   FEE,W
09F0:  BTFSS  x91.6
09F2:  BRA    099A
09F4:  MOVLB  0
09F6:  RETURN 0
09F8:  TBLRD*+
09FA:  MOVF   FF5,F
09FC:  BZ    0A16
09FE:  MOVFF  FF6,18A
0A02:  MOVFF  FF7,18B
0A06:  MOVFF  FF5,193
0A0A:  RCALL  0874
0A0C:  MOVFF  18A,FF6
0A10:  MOVFF  18B,FF7
0A14:  BRA    09F8
0A16:  RETURN 0
*
0DF0:  TBLRD*+
0DF2:  MOVF   FF5,F
0DF4:  BZ    0E10
0DF6:  MOVFF  FF6,18A
0DFA:  MOVFF  FF7,18B
0DFE:  MOVF   FF5,W
0E00:  BTFSS  F9E.4
0E02:  BRA    0E00
0E04:  MOVWF  FAD
0E06:  MOVFF  18A,FF6
0E0A:  MOVFF  18B,FF7
0E0E:  BRA    0DF0
0E10:  RETURN 0
*
0F94:  MOVLB  1
0F96:  MOVF   x91,W
0F98:  CLRF   01
0F9A:  SUBWF  x90,W
0F9C:  BC    0FA4
0F9E:  MOVFF  190,00
0FA2:  BRA    0FBC
0FA4:  CLRF   00
0FA6:  MOVLW  08
0FA8:  MOVWF  x92
0FAA:  RLCF   x90,F
0FAC:  RLCF   00,F
0FAE:  MOVF   x91,W
0FB0:  SUBWF  00,W
0FB2:  BTFSC  FD8.0
0FB4:  MOVWF  00
0FB6:  RLCF   01,F
0FB8:  DECFSZ x92,F
0FBA:  BRA    0FAA
0FBC:  MOVLB  0
0FBE:  RETURN 0
0FC0:  MOVLW  20
0FC2:  MOVLB  1
0FC4:  BTFSS  x8B.4
0FC6:  MOVLW  30
0FC8:  MOVWF  x8C
0FCA:  MOVFF  18A,00
0FCE:  BTFSS  x8A.7
0FD0:  BRA    0FE2
0FD2:  COMF   00,F
0FD4:  INCF   00,F
0FD6:  MOVFF  00,18A
0FDA:  MOVLW  2D
0FDC:  MOVWF  x8C
0FDE:  BSF    x8B.7
0FE0:  BSF    x8B.0
0FE2:  MOVF   01,W
0FE4:  MOVFF  18A,190
0FE8:  MOVLW  64
0FEA:  MOVWF  x91
0FEC:  MOVLB  0
0FEE:  RCALL  0F94
0FF0:  MOVFF  00,18A
0FF4:  MOVLW  30
0FF6:  ADDWF  01,W
0FF8:  MOVLB  1
0FFA:  MOVWF  x8D
0FFC:  MOVFF  18A,190
1000:  MOVLW  0A
1002:  MOVWF  x91
1004:  MOVLB  0
1006:  RCALL  0F94
1008:  MOVLW  30
100A:  ADDWF  00,W
100C:  MOVLB  1
100E:  MOVWF  x8F
1010:  MOVLW  30
1012:  ADDWF  01,W
1014:  MOVWF  x8E
1016:  MOVFF  18C,00
101A:  MOVLW  30
101C:  SUBWF  x8D,W
101E:  BZ    1028
1020:  BSF    x8B.1
1022:  BTFSC  x8B.7
1024:  BSF    x8B.2
1026:  BRA    104C
1028:  MOVFF  18C,18D
102C:  MOVLW  20
102E:  MOVWF  x8C
1030:  MOVLW  30
1032:  SUBWF  x8E,W
1034:  BZ    103E
1036:  BSF    x8B.0
1038:  BTFSC  x8B.7
103A:  BSF    x8B.1
103C:  BRA    104C
103E:  BTFSS  FD8.2
1040:  BSF    x8B.0
1042:  BNZ   104C
1044:  MOVFF  18D,18E
1048:  MOVLW  20
104A:  MOVWF  x8D
104C:  BTFSC  x8B.2
104E:  BRA    105A
1050:  BTFSC  x8B.1
1052:  BRA    1062
1054:  BTFSC  x8B.0
1056:  BRA    106A
1058:  BRA    1072
105A:  MOVFF  18C,193
105E:  MOVLB  0
1060:  RCALL  0874
1062:  MOVFF  18D,193
1066:  MOVLB  0
1068:  RCALL  0874
106A:  MOVFF  18E,193
106E:  MOVLB  0
1070:  RCALL  0874
1072:  MOVFF  18F,193
1076:  MOVLB  0
1078:  CALL   0874
107C:  RETURN 0
*
10E4:  TBLRD*+
10E6:  MOVF   FF5,F
10E8:  BZ    1102
10EA:  MOVFF  FF6,18A
10EE:  MOVFF  FF7,18B
10F2:  MOVFF  FF5,193
10F6:  RCALL  1096
10F8:  MOVFF  18A,FF6
10FC:  MOVFF  18B,FF7
1100:  BRA    10E4
1102:  GOTO   2F6E (RETURN)
1106:  TBLRD*+
1108:  MOVFF  FF6,18D
110C:  MOVFF  FF7,18E
1110:  MOVF   FF5,W
1112:  BTFSS  F9E.4
1114:  BRA    1112
1116:  MOVWF  FAD
1118:  MOVFF  18D,FF6
111C:  MOVFF  18E,FF7
1120:  MOVLB  1
1122:  DECFSZ x8C,F
1124:  BRA    1128
1126:  BRA    112C
1128:  MOVLB  0
112A:  BRA    1106
112C:  MOVLB  0
112E:  GOTO   132C (RETURN)
1132:  MOVFF  FEA,194
1136:  MOVFF  FE9,193
113A:  MOVLB  1
113C:  BTFSS  x8D.7
113E:  BRA    1150
1140:  BSF    x93.7
1142:  BTFSS  x93.4
1144:  INCF   x93,F
1146:  COMF   x8C,F
1148:  COMF   x8D,F
114A:  INCF   x8C,F
114C:  BTFSC  FD8.2
114E:  INCF   x8D,F
1150:  SWAPF  x8D,W
1152:  IORLW  F0
1154:  MOVWF  x8F
1156:  ADDWF  x8F,F
1158:  ADDLW  E2
115A:  MOVWF  x90
115C:  ADDLW  32
115E:  MOVWF  x92
1160:  MOVF   x8D,W
1162:  ANDLW  0F
1164:  ADDWF  x90,F
1166:  ADDWF  x90,F
1168:  ADDWF  x92,F
116A:  ADDLW  E9
116C:  MOVWF  x91
116E:  ADDWF  x91,F
1170:  ADDWF  x91,F
1172:  SWAPF  x8C,W
1174:  ANDLW  0F
1176:  ADDWF  x91,F
1178:  ADDWF  x92,F
117A:  RLCF   x91,F
117C:  RLCF   x92,F
117E:  COMF   x92,F
1180:  RLCF   x92,F
1182:  MOVF   x8C,W
1184:  ANDLW  0F
1186:  ADDWF  x92,F
1188:  RLCF   x8F,F
118A:  MOVLW  07
118C:  MOVWF  x8E
118E:  MOVLW  0A
1190:  DECF   x91,F
1192:  ADDWF  x92,F
1194:  BNC   1190
1196:  DECF   x90,F
1198:  ADDWF  x91,F
119A:  BNC   1196
119C:  DECF   x8F,F
119E:  ADDWF  x90,F
11A0:  BNC   119C
11A2:  DECF   x8E,F
11A4:  ADDWF  x8F,F
11A6:  BNC   11A2
11A8:  MOVLW  01
11AA:  MOVWF  FEA
11AC:  MOVLW  8E
11AE:  MOVWF  FE9
11B0:  MOVLW  07
11B2:  ANDWF  x93,W
11B4:  BCF    x93.6
11B6:  MOVF   FED,F
11B8:  ANDWF  x93,W
11BA:  BNZ   11CA
11BC:  BTFSC  x93.4
11BE:  MOVF   FEE,F
11C0:  BTFSC  x93.4
11C2:  BRA    11CA
11C4:  MOVLW  20
11C6:  MOVWF  00
11C8:  BRA    120A
11CA:  ADDWF  FE9,F
11CC:  MOVLW  00
11CE:  ADDWFC FEA,F
11D0:  MOVF   FE9,W
11D2:  SUBLW  92
11D4:  BNZ   11DC
11D6:  DECFSZ FEA,W
11D8:  BRA    11DC
11DA:  BSF    x93.6
11DC:  MOVF   FEF,W
11DE:  MOVWF  00
11E0:  BNZ   11F2
11E2:  BTFSC  x93.6
11E4:  BRA    11F2
11E6:  BTFSC  x93.4
11E8:  BRA    1212
11EA:  BTFSC  x93.3
11EC:  BRA    11F2
11EE:  MOVLW  20
11F0:  BRA    1208
11F2:  BTFSS  x93.7
11F4:  BRA    1202
11F6:  MOVLW  2D
11F8:  MOVWF  00
11FA:  MOVF   FED,W
11FC:  BCF    x93.6
11FE:  BCF    x93.7
1200:  BRA    120A
1202:  BSF    x93.3
1204:  BCF    x93.4
1206:  MOVLW  30
1208:  ADDWF  00,F
120A:  MOVF   00,W
120C:  BTFSS  F9E.4
120E:  BRA    120C
1210:  MOVWF  FAD
1212:  MOVF   FEE,W
1214:  BTFSS  x93.6
1216:  BRA    11D0
1218:  MOVLB  0
121A:  RETURN 0
121C:  MOVFF  FEA,194
1220:  MOVFF  FE9,193
1224:  MOVLB  1
1226:  SWAPF  x8D,W
1228:  IORLW  F0
122A:  MOVWF  x8F
122C:  ADDWF  x8F,F
122E:  ADDLW  E2
1230:  MOVWF  x90
1232:  ADDLW  32
1234:  MOVWF  x92
1236:  MOVF   x8D,W
1238:  ANDLW  0F
123A:  ADDWF  x90,F
123C:  ADDWF  x90,F
123E:  ADDWF  x92,F
1240:  ADDLW  E9
1242:  MOVWF  x91
1244:  ADDWF  x91,F
1246:  ADDWF  x91,F
1248:  SWAPF  x8C,W
124A:  ANDLW  0F
124C:  ADDWF  x91,F
124E:  ADDWF  x92,F
1250:  RLCF   x91,F
1252:  RLCF   x92,F
1254:  COMF   x92,F
1256:  RLCF   x92,F
1258:  MOVF   x8C,W
125A:  ANDLW  0F
125C:  ADDWF  x92,F
125E:  RLCF   x8F,F
1260:  MOVLW  07
1262:  MOVWF  x8E
1264:  MOVLW  0A
1266:  DECF   x91,F
1268:  ADDWF  x92,F
126A:  BNC   1266
126C:  DECF   x90,F
126E:  ADDWF  x91,F
1270:  BNC   126C
1272:  DECF   x8F,F
1274:  ADDWF  x90,F
1276:  BNC   1272
1278:  DECF   x8E,F
127A:  ADDWF  x8F,F
127C:  BNC   1278
127E:  MOVLW  01
1280:  MOVWF  FEA
1282:  MOVLW  8E
1284:  MOVWF  FE9
1286:  MOVLW  07
1288:  ANDWF  x93,W
128A:  BCF    x93.6
128C:  ADDWF  FE9,F
128E:  MOVLW  00
1290:  ADDWFC FEA,F
1292:  MOVF   FE9,W
1294:  SUBLW  92
1296:  BNZ   129E
1298:  DECFSZ FEA,W
129A:  BRA    129E
129C:  BSF    x93.6
129E:  MOVF   FEF,W
12A0:  MOVWF  00
12A2:  BNZ   12B4
12A4:  BTFSC  x93.6
12A6:  BRA    12B4
12A8:  BTFSC  x93.4
12AA:  BRA    12C4
12AC:  BTFSC  x93.3
12AE:  BRA    12B4
12B0:  MOVLW  20
12B2:  BRA    12BA
12B4:  BSF    x93.3
12B6:  BCF    x93.4
12B8:  MOVLW  30
12BA:  ADDWF  00,F
12BC:  MOVF   00,W
12BE:  BTFSS  F9E.4
12C0:  BRA    12BE
12C2:  MOVWF  FAD
12C4:  MOVF   FEE,W
12C6:  BTFSS  x93.6
12C8:  BRA    1292
12CA:  MOVLB  0
12CC:  GOTO   137C (RETURN)
*
138E:  TSTFSZ 01
1390:  BRA    1398
1392:  TSTFSZ 02
1394:  BRA    139A
1396:  BRA    13A6
1398:  INCF   02,F
139A:  MOVFF  00,FEE
139E:  DECFSZ 01,F
13A0:  BRA    139A
13A2:  DECFSZ 02,F
13A4:  BRA    139A
13A6:  RETURN 0
*
153E:  TBLRD*+
1540:  MOVFF  FF6,18B
1544:  MOVFF  FF7,18C
1548:  MOVFF  FF5,193
154C:  RCALL  1096
154E:  MOVFF  18B,FF6
1552:  MOVFF  18C,FF7
1556:  MOVLB  1
1558:  DECFSZ x8A,F
155A:  BRA    155E
155C:  BRA    1562
155E:  MOVLB  0
1560:  BRA    153E
1562:  MOVLB  0
1564:  RETURN 0
1566:  MOVFF  FEA,192
156A:  MOVFF  FE9,191
156E:  MOVLB  1
1570:  SWAPF  x8B,W
1572:  IORLW  F0
1574:  MOVWF  x8D
1576:  ADDWF  x8D,F
1578:  ADDLW  E2
157A:  MOVWF  x8E
157C:  ADDLW  32
157E:  MOVWF  x90
1580:  MOVF   x8B,W
1582:  ANDLW  0F
1584:  ADDWF  x8E,F
1586:  ADDWF  x8E,F
1588:  ADDWF  x90,F
158A:  ADDLW  E9
158C:  MOVWF  x8F
158E:  ADDWF  x8F,F
1590:  ADDWF  x8F,F
1592:  SWAPF  x8A,W
1594:  ANDLW  0F
1596:  ADDWF  x8F,F
1598:  ADDWF  x90,F
159A:  RLCF   x8F,F
159C:  RLCF   x90,F
159E:  COMF   x90,F
15A0:  RLCF   x90,F
15A2:  MOVF   x8A,W
15A4:  ANDLW  0F
15A6:  ADDWF  x90,F
15A8:  RLCF   x8D,F
15AA:  MOVLW  07
15AC:  MOVWF  x8C
15AE:  MOVLW  0A
15B0:  DECF   x8F,F
15B2:  ADDWF  x90,F
15B4:  BNC   15B0
15B6:  DECF   x8E,F
15B8:  ADDWF  x8F,F
15BA:  BNC   15B6
15BC:  DECF   x8D,F
15BE:  ADDWF  x8E,F
15C0:  BNC   15BC
15C2:  DECF   x8C,F
15C4:  ADDWF  x8D,F
15C6:  BNC   15C2
15C8:  MOVLW  01
15CA:  MOVWF  FEA
15CC:  MOVLW  8C
15CE:  MOVWF  FE9
15D0:  MOVLW  07
15D2:  ANDWF  x91,W
15D4:  BCF    x91.6
15D6:  ADDWF  FE9,F
15D8:  MOVLW  00
15DA:  ADDWFC FEA,F
15DC:  MOVF   FE9,W
15DE:  SUBLW  90
15E0:  BNZ   15E8
15E2:  DECFSZ FEA,W
15E4:  BRA    15E8
15E6:  BSF    x91.6
15E8:  MOVF   FEF,W
15EA:  MOVWF  00
15EC:  BNZ   15FE
15EE:  BTFSC  x91.6
15F0:  BRA    15FE
15F2:  BTFSC  x91.4
15F4:  BRA    1620
15F6:  BTFSC  x91.3
15F8:  BRA    15FE
15FA:  MOVLW  20
15FC:  BRA    1604
15FE:  BSF    x91.3
1600:  BCF    x91.4
1602:  MOVLW  30
1604:  ADDWF  00,F
1606:  MOVFF  FEA,18B
160A:  MOVFF  FE9,18A
160E:  MOVFF  00,193
1612:  MOVLB  0
1614:  RCALL  1096
1616:  MOVFF  18B,FEA
161A:  MOVFF  18A,FE9
161E:  MOVLB  1
1620:  MOVF   FEE,W
1622:  BTFSS  x91.6
1624:  BRA    15DC
1626:  MOVLB  0
1628:  RETURN 0
162A:  MOVF   01,W
162C:  MOVFF  18A,190
1630:  MOVLW  64
1632:  MOVLB  1
1634:  MOVWF  x91
1636:  MOVLB  0
1638:  RCALL  0F94
163A:  MOVFF  00,18A
163E:  MOVF   01,W
1640:  MOVLW  30
1642:  BNZ   1654
1644:  MOVLB  1
1646:  BTFSS  x8B.1
1648:  BRA    1668
164A:  BTFSC  x8B.3
164C:  BRA    1668
164E:  BTFSC  x8B.4
1650:  MOVLW  20
1652:  BRA    165C
1654:  MOVLB  1
1656:  BCF    x8B.3
1658:  BCF    x8B.4
165A:  BSF    x8B.0
165C:  ADDWF  01,F
165E:  MOVFF  01,193
1662:  MOVLB  0
1664:  RCALL  1096
1666:  MOVLB  1
1668:  MOVFF  18A,190
166C:  MOVLW  0A
166E:  MOVWF  x91
1670:  MOVLB  0
1672:  RCALL  0F94
1674:  MOVFF  00,18A
1678:  MOVF   01,W
167A:  MOVLW  30
167C:  BNZ   168E
167E:  MOVLB  1
1680:  BTFSC  x8B.3
1682:  BRA    1698
1684:  BTFSS  x8B.0
1686:  BRA    1698
1688:  BTFSC  x8B.4
168A:  MOVLW  20
168C:  MOVLB  0
168E:  ADDWF  01,F
1690:  MOVFF  01,193
1694:  RCALL  1096
1696:  MOVLB  1
1698:  MOVLW  30
169A:  ADDWF  x8A,F
169C:  MOVFF  18A,193
16A0:  MOVLB  0
16A2:  RCALL  1096
16A4:  RETURN 0
*
210A:  ADDWF  FE8,W
210C:  CLRF   FF7
210E:  RLCF   FF7,F
2110:  ADDLW  25
2112:  MOVWF  FF6
2114:  MOVLW  21
2116:  ADDWFC FF7,F
2118:  TBLRD*-
211A:  MOVF   FF5,W
211C:  MOVWF  FFA
211E:  TBLRD*
2120:  MOVF   FF5,W
2122:  MOVWF  FF9
2124:  DATA DA,20
2126:  DATA 04,21
2128:  DATA 04,21
212A:  DATA 04,21
212C:  DATA DC,20
212E:  DATA EC,20
2130:  DATA F0,20
2132:  DATA 04,21
2134:  DATA 04,21
2136:  DATA 04,21
2138:  DATA F2,20
213A:  DATA 02,21
*
2412:  ADDWF  FE8,W
2414:  CLRF   FF7
2416:  RLCF   FF7,F
2418:  ADDLW  2D
241A:  MOVWF  FF6
241C:  MOVLW  24
241E:  ADDWFC FF7,F
2420:  TBLRD*-
2422:  MOVF   FF5,W
2424:  MOVWF  FFA
2426:  TBLRD*
2428:  MOVF   FF5,W
242A:  MOVWF  FF9
242C:  DATA E2,23
242E:  DATA 0C,24
2430:  DATA 0C,24
2432:  DATA 0C,24
2434:  DATA E4,23
2436:  DATA F4,23
2438:  DATA F8,23
243A:  DATA 0C,24
243C:  DATA 0C,24
243E:  DATA 0C,24
2440:  DATA FA,23
2442:  DATA 0A,24
*
271C:  ADDWF  FE8,W
271E:  CLRF   FF7
2720:  RLCF   FF7,F
2722:  ADDLW  37
2724:  MOVWF  FF6
2726:  MOVLW  27
2728:  ADDWFC FF7,F
272A:  TBLRD*-
272C:  MOVF   FF5,W
272E:  MOVWF  FFA
2730:  TBLRD*
2732:  MOVF   FF5,W
2734:  MOVWF  FF9
2736:  DATA EC,26
2738:  DATA 16,27
273A:  DATA 16,27
273C:  DATA 16,27
273E:  DATA EE,26
2740:  DATA FE,26
2742:  DATA 02,27
2744:  DATA 16,27
2746:  DATA 16,27
2748:  DATA 16,27
274A:  DATA 04,27
274C:  DATA 14,27
*
32EC:  ADDWF  FE8,W
32EE:  CLRF   FF7
32F0:  RLCF   FF7,F
32F2:  ADDLW  07
32F4:  MOVWF  FF6
32F6:  MOVLW  33
32F8:  ADDWFC FF7,F
32FA:  TBLRD*-
32FC:  MOVF   FF5,W
32FE:  MOVWF  FFA
3300:  TBLRD*
3302:  MOVF   FF5,W
3304:  MOVWF  FF9
3306:  DATA 3A,2F
3308:  DATA 54,2F
330A:  DATA 5E,2F
330C:  DATA A0,2F
330E:  DATA AA,2F
3310:  DATA D6,2F
3312:  DATA 0A,30
3314:  DATA 32,30
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0EC0:  MOVLB  1
0EC2:  MOVFF  190,FE9
0EC6:  MOVFF  191,FEA
0ECA:  MOVFF  FEF,194
0ECE:  MOVFF  193,03
0ED2:  MOVFF  192,FE9
0ED6:  MOVFF  193,FEA
0EDA:  MOVF   FEF,W
0EDC:  SUBWF  x94,W
0EDE:  BNZ   0F0A
....................       if (*s1 == '\0') 
0EE0:  MOVFF  191,03
0EE4:  MOVFF  190,FE9
0EE8:  MOVFF  03,FEA
0EEC:  MOVF   FEF,F
0EEE:  BNZ   0EF6
....................          return(0); 
0EF0:  MOVLW  00
0EF2:  MOVWF  01
0EF4:  BRA    0F34
0EF6:  MOVFF  191,03
0EFA:  MOVF   x90,W
0EFC:  INCF   x90,F
0EFE:  BTFSC  FD8.2
0F00:  INCF   x91,F
0F02:  INCF   x92,F
0F04:  BTFSC  FD8.2
0F06:  INCF   x93,F
0F08:  BRA    0EC2
....................    return((*s1 < *s2) ? -1: 1); 
0F0A:  MOVFF  191,03
0F0E:  MOVFF  190,FE9
0F12:  MOVFF  191,FEA
0F16:  MOVFF  FEF,194
0F1A:  MOVFF  193,03
0F1E:  MOVFF  192,FE9
0F22:  MOVFF  193,FEA
0F26:  MOVF   FEF,W
0F28:  SUBWF  x94,W
0F2A:  BC    0F30
0F2C:  MOVLW  FF
0F2E:  BRA    0F32
0F30:  MOVLW  01
0F32:  MOVWF  01
0F34:  MOVLB  0
0F36:  GOTO   0F7A (RETURN)
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock = 20000000) 
*
0184:  MOVLW  03
0186:  MOVLB  1
0188:  SUBWF  xA2,F
018A:  BNC   01A0
018C:  MOVLW  01
018E:  MOVWF  FEA
0190:  MOVLW  A2
0192:  MOVWF  FE9
0194:  MOVF   FEF,W
0196:  BZ    01A0
0198:  BRA    019C
019A:  BRA    019C
019C:  DECFSZ FEF,F
019E:  BRA    019A
01A0:  MOVLB  0
01A2:  GOTO   01B8 (RETURN)
*
03BE:  MOVLW  01
03C0:  MOVWF  FEA
03C2:  MOVLW  94
03C4:  MOVWF  FE9
03C6:  MOVF   FEF,W
03C8:  BZ    03E4
03CA:  MOVLW  06
03CC:  MOVWF  01
03CE:  CLRF   00
03D0:  DECFSZ 00,F
03D2:  BRA    03D0
03D4:  DECFSZ 01,F
03D6:  BRA    03CE
03D8:  MOVLW  7B
03DA:  MOVWF  00
03DC:  DECFSZ 00,F
03DE:  BRA    03DC
03E0:  DECFSZ FEF,F
03E2:  BRA    03CA
03E4:  RETURN 0
.................... #use rs232(uart1, baud = 9600, TIMEOUT = 10, stream = monitor)                                                       // pic to pic 
*
01A6:  MOVLW  20
01A8:  MOVLB  1
01AA:  MOVWF  xA0
01AC:  MOVLW  02
01AE:  MOVWF  xA1
01B0:  MOVLW  9B
01B2:  MOVWF  xA2
01B4:  MOVLB  0
01B6:  BRA    0184
01B8:  MOVLB  1
01BA:  DECFSZ xA1,F
01BC:  BRA    01B0
01BE:  DECFSZ xA0,F
01C0:  BRA    01C8
01C2:  CLRF   1F
01C4:  CLRF   01
01C6:  BRA    01DC
01C8:  BTFSS  F9E.5
01CA:  BRA    01AC
01CC:  MOVF   FAB,W
01CE:  MOVWF  1F
01D0:  MOVF   FAE,W
01D2:  MOVWF  01
01D4:  BTFSS  1F.1
01D6:  BRA    01DC
01D8:  BCF    FAB.4
01DA:  BSF    FAB.4
01DC:  MOVLB  0
01DE:  GOTO   020A (RETURN)
.................... #use rs232(BAUD = 9600, BITS = 8, PARITY = N, XMIT = PIN_C0, rcv = PIN_C1, TIMEOUT = 40, stream = GPS, DISABLE_INTS) // 
*
0E4A:  MOVLW  10
0E4C:  MOVLB  1
0E4E:  MOVWF  x8F
0E50:  MOVLW  01
0E52:  MOVWF  x8E
0E54:  BSF    20.6
0E56:  BSF    F94.1
0E58:  MOVLW  10
0E5A:  MOVWF  00
0E5C:  DECFSZ 00,F
0E5E:  BRA    0E5C
0E60:  NOP   
0E62:  DECFSZ x8E,F
0E64:  BRA    0E70
0E66:  DECFSZ x8F,F
0E68:  BRA    0E70
0E6A:  CLRF   20
0E6C:  CLRF   01
0E6E:  BRA    0EB8
0E70:  BTFSC  F82.1
0E72:  BRA    0E58
0E74:  MOVLW  08
0E76:  MOVWF  00
0E78:  CLRF   x90
0E7A:  MOVFF  FF2,191
0E7E:  BCF    FF2.7
0E80:  BSF    00.7
0E82:  BRA    0EA0
0E84:  BCF    00.7
0E86:  BRA    0EA0
0E88:  BCF    FD8.0
0E8A:  BTFSC  F82.1
0E8C:  BSF    FD8.0
0E8E:  RRCF   x90,F
0E90:  BSF    00.6
0E92:  BRA    0EA0
0E94:  BCF    00.6
0E96:  DECFSZ 00,F
0E98:  BRA    0E88
0E9A:  MOVF   x90,W
0E9C:  MOVWF  01
0E9E:  BRA    0EB8
0EA0:  MOVLW  A7
0EA2:  BTFSC  00.7
0EA4:  MOVLW  2D
0EA6:  MOVWF  01
0EA8:  DECFSZ 01,F
0EAA:  BRA    0EA8
0EAC:  NOP   
0EAE:  BTFSC  00.7
0EB0:  BRA    0E84
0EB2:  BTFSC  00.6
0EB4:  BRA    0E94
0EB6:  BRA    0E88
0EB8:  BTFSC  x91.7
0EBA:  BSF    FF2.7
0EBC:  MOVLB  0
0EBE:  RETURN 0
*
1096:  MOVFF  FF2,03
109A:  BCF    FF2.7
109C:  BCF    F94.0
109E:  BCF    F8B.0
10A0:  MOVLW  08
10A2:  MOVWF  01
10A4:  BRA    10A6
10A6:  NOP   
10A8:  BSF    01.7
10AA:  BRA    10CC
10AC:  BCF    01.7
10AE:  MOVLB  1
10B0:  RRCF   x93,F
10B2:  MOVLB  0
10B4:  BTFSC  FD8.0
10B6:  BSF    F8B.0
10B8:  BTFSS  FD8.0
10BA:  BCF    F8B.0
10BC:  BSF    01.6
10BE:  BRA    10CC
10C0:  BCF    01.6
10C2:  DECFSZ 01,F
10C4:  BRA    10AE
10C6:  BRA    10C8
10C8:  NOP   
10CA:  BSF    F8B.0
10CC:  MOVLW  A7
10CE:  MOVWF  FE9
10D0:  DECFSZ FE9,F
10D2:  BRA    10D0
10D4:  BRA    10D6
10D6:  BTFSC  01.7
10D8:  BRA    10AC
10DA:  BTFSC  01.6
10DC:  BRA    10C0
10DE:  BTFSC  03.7
10E0:  BSF    FF2.7
10E2:  RETURN 0
.................... #fuses HS, NOLVP, PUT, PROTECT, NODEBUG, NOWDT, WDT4096                                                              // pin D5 rx, tx_d0 
.................... #priority int_rda 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
03E6:  MOVLB  1
03E8:  BTFSC  x9B.0
03EA:  BRA    03F0
03EC:  BCF    F89.4
03EE:  BRA    03F2
03F0:  BSF    F89.4
03F2:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
03F4:  BTFSC  x9B.1
03F6:  BRA    03FC
03F8:  BCF    F89.2
03FA:  BRA    03FE
03FC:  BSF    F89.2
03FE:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0400:  BTFSC  x9B.2
0402:  BRA    0408
0404:  BCF    F89.1
0406:  BRA    040A
0408:  BSF    F89.1
040A:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
040C:  BTFSC  x9B.3
040E:  BRA    0414
0410:  BCF    F89.0
0412:  BRA    0416
0414:  BSF    F89.0
0416:  BCF    F92.0
....................  
....................  delay_cycles(1);  
0418:  NOP   
....................  output_high(LCD_E);  
041A:  BCF    F92.3
041C:  BSF    F89.3
....................  delay_us(2);  
041E:  MOVLW  02
0420:  MOVWF  00
0422:  DECFSZ 00,F
0424:  BRA    0422
0426:  BRA    0428
0428:  NOP   
....................  output_low(LCD_E);  
042A:  BCF    F92.3
042C:  BCF    F89.3
042E:  MOVLB  0
0430:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
0432:  BCF    F96.2
0434:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0436:  MOVLW  63
0438:  MOVWF  00
043A:  DECFSZ 00,F
043C:  BRA    043A
043E:  BRA    0440
.................... #endif  
....................  
.................... if(address)  
0440:  MOVLB  1
0442:  MOVF   x98,F
0444:  BZ    044C
....................    output_high(LCD_RS);  
0446:  BCF    F96.2
0448:  BSF    F8D.2
044A:  BRA    0450
.................... else  
....................    output_low(LCD_RS);  
044C:  BCF    F96.2
044E:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
0450:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0452:  BCF    F92.3
0454:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
0456:  SWAPF  x99,W
0458:  MOVWF  x9A
045A:  MOVLW  0F
045C:  ANDWF  x9A,F
045E:  MOVFF  19A,19B
0462:  MOVLB  0
0464:  RCALL  03E6
.................... lcd_send_nibble(n & 0xf);  
0466:  MOVLB  1
0468:  MOVF   x99,W
046A:  ANDLW  0F
046C:  MOVWF  x9A
046E:  MOVWF  x9B
0470:  MOVLB  0
0472:  RCALL  03E6
0474:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
0476:  MOVLW  01
0478:  MOVWF  21
....................  
....................    output_low(LCD_RS);  
047A:  BCF    F96.2
047C:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
047E:  BCF    F92.3
0480:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
0482:  MOVLW  23
0484:  MOVLB  1
0486:  MOVWF  x94
0488:  MOVLB  0
048A:  RCALL  03BE
....................  
....................    for(i=0 ;i < 3; i++)  
048C:  MOVLB  1
048E:  CLRF   x8A
0490:  MOVF   x8A,W
0492:  SUBLW  02
0494:  BNC   04AE
....................    {  
....................       lcd_send_nibble(0x03);  
0496:  MOVLW  03
0498:  MOVWF  x9B
049A:  MOVLB  0
049C:  RCALL  03E6
....................       delay_ms(5);  
049E:  MOVLW  05
04A0:  MOVLB  1
04A2:  MOVWF  x94
04A4:  MOVLB  0
04A6:  RCALL  03BE
04A8:  MOVLB  1
04AA:  INCF   x8A,F
04AC:  BRA    0490
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
04AE:  MOVLW  02
04B0:  MOVWF  x9B
04B2:  MOVLB  0
04B4:  RCALL  03E6
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
04B6:  MOVLB  1
04B8:  CLRF   x8A
04BA:  MOVF   x8A,W
04BC:  SUBLW  03
04BE:  BNC   04E4
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
04C0:  CLRF   03
04C2:  MOVF   x8A,W
04C4:  MOVLB  0
04C6:  RCALL  00BA
04C8:  MOVLB  1
04CA:  MOVWF  x8B
04CC:  CLRF   x98
04CE:  MOVWF  x99
04D0:  MOVLB  0
04D2:  RCALL  0432
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
04D4:  MOVLW  05
04D6:  MOVLB  1
04D8:  MOVWF  x94
04DA:  MOVLB  0
04DC:  RCALL  03BE
....................       #endif  
04DE:  MOVLB  1
04E0:  INCF   x8A,F
04E2:  BRA    04BA
....................    }  
04E4:  MOVLB  0
04E6:  GOTO   2C74 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
0822:  MOVLB  1
0824:  MOVF   x95,W
0826:  XORLW  01
0828:  MOVLB  0
082A:  BZ    083A
082C:  XORLW  03
082E:  BZ    0840
0830:  XORLW  01
0832:  BZ    0848
0834:  XORLW  07
0836:  BZ    0850
0838:  BRA    085A
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
083A:  MOVLB  1
083C:  CLRF   x96
....................      break;  
083E:  BRA    085E
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
0840:  MOVLW  40
0842:  MOVLB  1
0844:  MOVWF  x96
....................      break;  
0846:  BRA    085E
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0848:  MOVLW  14
084A:  MOVLB  1
084C:  MOVWF  x96
....................      break;  
084E:  BRA    085E
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0850:  MOVLW  54
0852:  MOVLB  1
0854:  MOVWF  x96
....................      break;  
0856:  BRA    085E
0858:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
085A:  MOVLB  1
085C:  CLRF   x96
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
085E:  MOVLW  01
0860:  SUBWF  x94,W
0862:  ADDWF  x96,F
.................... lcd_send_byte(0, 0x80 | address);  
0864:  MOVF   x96,W
0866:  IORLW  80
0868:  MOVWF  x97
086A:  CLRF   x98
086C:  MOVWF  x99
086E:  MOVLB  0
0870:  RCALL  0432
0872:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
0874:  MOVLB  1
0876:  MOVF   x93,W
0878:  XORLW  0C
087A:  MOVLB  0
087C:  BZ    0888
087E:  XORLW  06
0880:  BZ    08A4
0882:  XORLW  02
0884:  BZ    08B6
0886:  BRA    08C4
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
0888:  MOVLB  1
088A:  CLRF   x98
088C:  MOVLW  01
088E:  MOVWF  x99
0890:  MOVLB  0
0892:  RCALL  0432
....................       lcd_line = 1;  
0894:  MOVLW  01
0896:  MOVWF  21
....................       delay_ms(2);  
0898:  MOVLW  02
089A:  MOVLB  1
089C:  MOVWF  x94
089E:  MOVLB  0
08A0:  RCALL  03BE
....................       break;  
08A2:  BRA    08D2
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
08A4:  INCF   21,F
08A6:  MOVLW  01
08A8:  MOVLB  1
08AA:  MOVWF  x94
08AC:  MOVFF  21,195
08B0:  MOVLB  0
08B2:  RCALL  0822
....................        break;  
08B4:  BRA    08D2
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
08B6:  MOVLB  1
08B8:  CLRF   x98
08BA:  MOVLW  10
08BC:  MOVWF  x99
08BE:  MOVLB  0
08C0:  RCALL  0432
....................        break;  
08C2:  BRA    08D2
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
08C4:  MOVLW  01
08C6:  MOVLB  1
08C8:  MOVWF  x98
08CA:  MOVFF  193,199
08CE:  MOVLB  0
08D0:  RCALL  0432
....................        break;  
....................    }  
08D2:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_eeprom.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_D6//PIN_B7 
.................... #define EEPROM_SCL  PIN_D7//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
04F2:  MOVLW  08
04F4:  MOVWF  01
04F6:  MOVLW  05
04F8:  MOVWF  00
04FA:  DECFSZ 00,F
04FC:  BRA    04FA
04FE:  BCF    F8C.7
0500:  BCF    F95.7
0502:  MOVLW  06
0504:  MOVWF  00
0506:  DECFSZ 00,F
0508:  BRA    0506
050A:  MOVLB  1
050C:  RLCF   x94,F
050E:  BCF    F8C.6
0510:  BTFSC  FD8.0
0512:  BSF    F95.6
0514:  BTFSS  FD8.0
0516:  BCF    F95.6
0518:  BSF    F95.7
051A:  BTFSS  F83.7
051C:  BRA    051A
051E:  DECFSZ 01,F
0520:  BRA    0524
0522:  BRA    0528
0524:  MOVLB  0
0526:  BRA    04F6
0528:  MOVLW  05
052A:  MOVWF  00
052C:  DECFSZ 00,F
052E:  BRA    052C
0530:  BCF    F8C.7
0532:  BCF    F95.7
0534:  NOP   
0536:  BSF    F95.6
0538:  MOVLW  06
053A:  MOVWF  00
053C:  DECFSZ 00,F
053E:  BRA    053C
0540:  MOVLW  06
0542:  MOVWF  00
0544:  DECFSZ 00,F
0546:  BRA    0544
0548:  BSF    F95.7
054A:  BTFSS  F83.7
054C:  BRA    054A
054E:  CLRF   01
0550:  MOVLW  06
0552:  MOVWF  00
0554:  DECFSZ 00,F
0556:  BRA    0554
0558:  BTFSC  F83.6
055A:  BSF    01.0
055C:  BCF    F8C.7
055E:  BCF    F95.7
0560:  BCF    F8C.6
0562:  BCF    F95.6
0564:  MOVLB  0
0566:  RETURN 0
*
06BC:  MOVLW  08
06BE:  MOVLB  1
06C0:  MOVWF  x92
06C2:  MOVFF  00,193
06C6:  BSF    F95.6
06C8:  MOVLW  06
06CA:  MOVWF  00
06CC:  DECFSZ 00,F
06CE:  BRA    06CC
06D0:  BSF    F95.7
06D2:  BTFSS  F83.7
06D4:  BRA    06D2
06D6:  BTFSC  F83.6
06D8:  BSF    FD8.0
06DA:  BTFSS  F83.6
06DC:  BCF    FD8.0
06DE:  RLCF   01,F
06E0:  MOVLW  05
06E2:  MOVWF  00
06E4:  DECFSZ 00,F
06E6:  BRA    06E4
06E8:  BCF    F95.7
06EA:  BCF    F8C.7
06EC:  DECFSZ x92,F
06EE:  BRA    06C6
06F0:  BSF    F95.6
06F2:  MOVLW  06
06F4:  MOVWF  00
06F6:  DECFSZ 00,F
06F8:  BRA    06F6
06FA:  BCF    F8C.6
06FC:  MOVF   x93,W
06FE:  BTFSS  FD8.2
0700:  BCF    F95.6
0702:  NOP   
0704:  BSF    F95.7
0706:  BTFSS  F83.7
0708:  BRA    0706
070A:  MOVLW  05
070C:  MOVWF  00
070E:  DECFSZ 00,F
0710:  BRA    070E
0712:  BCF    F8C.7
0714:  BCF    F95.7
0716:  MOVLW  06
0718:  MOVWF  00
071A:  DECFSZ 00,F
071C:  BRA    071A
071E:  BCF    F8C.6
0720:  BCF    F95.6
0722:  MOVLB  0
0724:  GOTO   07A2 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
04EA:  BSF    F95.7
....................    output_float(EEPROM_SDA); 
04EC:  BSF    F95.6
04EE:  GOTO   2C78 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0568:  BSF    F95.6
056A:  MOVLW  05
056C:  MOVWF  00
056E:  DECFSZ 00,F
0570:  BRA    056E
0572:  BSF    F95.7
0574:  MOVLW  06
0576:  MOVWF  00
0578:  DECFSZ 00,F
057A:  BRA    0578
057C:  BCF    F8C.6
057E:  BCF    F95.6
0580:  MOVLW  05
0582:  MOVWF  00
0584:  DECFSZ 00,F
0586:  BRA    0584
0588:  BCF    F8C.7
058A:  BCF    F95.7
....................    i2c_write(0xa0); 
058C:  MOVLW  A0
058E:  MOVLB  1
0590:  MOVWF  x94
0592:  MOVLB  0
0594:  RCALL  04F2
....................    i2c_write(address>>8); 
0596:  MOVFF  18F,192
059A:  MOVLB  1
059C:  CLRF   x93
059E:  MOVFF  18F,194
05A2:  MOVLB  0
05A4:  RCALL  04F2
....................    i2c_write(address); 
05A6:  MOVFF  18E,194
05AA:  RCALL  04F2
....................    i2c_write(data); 
05AC:  MOVFF  190,194
05B0:  RCALL  04F2
....................    i2c_stop(); 
05B2:  BCF    F95.6
05B4:  NOP   
05B6:  BSF    F95.7
05B8:  BTFSS  F83.7
05BA:  BRA    05B8
05BC:  MOVLW  05
05BE:  MOVWF  00
05C0:  DECFSZ 00,F
05C2:  BRA    05C0
05C4:  BRA    05C6
05C6:  NOP   
05C8:  BSF    F95.6
05CA:  MOVLW  05
05CC:  MOVWF  00
05CE:  DECFSZ 00,F
05D0:  BRA    05CE
....................    i2c_start(); 
05D2:  BSF    F95.6
05D4:  MOVLW  05
05D6:  MOVWF  00
05D8:  DECFSZ 00,F
05DA:  BRA    05D8
05DC:  BSF    F95.7
05DE:  MOVLW  06
05E0:  MOVWF  00
05E2:  DECFSZ 00,F
05E4:  BRA    05E2
05E6:  BCF    F8C.6
05E8:  BCF    F95.6
05EA:  MOVLW  05
05EC:  MOVWF  00
05EE:  DECFSZ 00,F
05F0:  BRA    05EE
05F2:  BCF    F8C.7
05F4:  BCF    F95.7
....................    status=i2c_write(0xa0); 
05F6:  MOVLW  A0
05F8:  MOVLB  1
05FA:  MOVWF  x94
05FC:  MOVLB  0
05FE:  RCALL  04F2
0600:  MOVF   01,W
0602:  MOVLB  1
0604:  BCF    x91.0
0606:  BTFSC  01.0
0608:  BSF    x91.0
....................    while(status==1) 
060A:  BTFSS  x91.0
060C:  BRA    064A
....................    { 
....................    i2c_start(); 
060E:  BSF    F95.6
0610:  MOVLW  05
0612:  MOVWF  00
0614:  DECFSZ 00,F
0616:  BRA    0614
0618:  BSF    F95.7
061A:  MOVLW  06
061C:  MOVWF  00
061E:  DECFSZ 00,F
0620:  BRA    061E
0622:  BTFSS  F83.7
0624:  BRA    0622
0626:  BCF    F8C.6
0628:  BCF    F95.6
062A:  MOVLW  05
062C:  MOVWF  00
062E:  DECFSZ 00,F
0630:  BRA    062E
0632:  BCF    F8C.7
0634:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0636:  MOVLW  A0
0638:  MOVWF  x94
063A:  MOVLB  0
063C:  RCALL  04F2
063E:  MOVF   01,W
0640:  MOVLB  1
0642:  BCF    x91.0
0644:  BTFSC  01.0
0646:  BSF    x91.0
0648:  BRA    060A
....................    } 
....................    i2c_stop(); 
064A:  BCF    F95.6
064C:  NOP   
064E:  BSF    F95.7
0650:  BTFSS  F83.7
0652:  BRA    0650
0654:  MOVLW  05
0656:  MOVWF  00
0658:  DECFSZ 00,F
065A:  BRA    0658
065C:  BRA    065E
065E:  NOP   
0660:  BSF    F95.6
0662:  MOVLW  05
0664:  MOVWF  00
0666:  DECFSZ 00,F
0668:  BRA    0666
066A:  MOVLB  0
066C:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0728:  BSF    F95.6
072A:  MOVLW  05
072C:  MOVWF  00
072E:  DECFSZ 00,F
0730:  BRA    072E
0732:  BSF    F95.7
0734:  MOVLW  06
0736:  MOVWF  00
0738:  DECFSZ 00,F
073A:  BRA    0738
073C:  BCF    F8C.6
073E:  BCF    F95.6
0740:  MOVLW  05
0742:  MOVWF  00
0744:  DECFSZ 00,F
0746:  BRA    0744
0748:  BCF    F8C.7
074A:  BCF    F95.7
....................    i2c_write(0xa0); 
074C:  MOVLW  A0
074E:  MOVLB  1
0750:  MOVWF  x94
0752:  MOVLB  0
0754:  RCALL  04F2
....................    i2c_write(address>>8); 
0756:  MOVFF  18F,191
075A:  MOVLB  1
075C:  CLRF   x92
075E:  MOVFF  18F,194
0762:  MOVLB  0
0764:  RCALL  04F2
....................    i2c_write(address); 
0766:  MOVFF  18E,194
076A:  RCALL  04F2
....................    i2c_start(); 
076C:  BSF    F95.6
076E:  MOVLW  05
0770:  MOVWF  00
0772:  DECFSZ 00,F
0774:  BRA    0772
0776:  BSF    F95.7
0778:  MOVLW  06
077A:  MOVWF  00
077C:  DECFSZ 00,F
077E:  BRA    077C
0780:  BTFSS  F83.7
0782:  BRA    0780
0784:  BCF    F8C.6
0786:  BCF    F95.6
0788:  MOVLW  05
078A:  MOVWF  00
078C:  DECFSZ 00,F
078E:  BRA    078C
0790:  BCF    F8C.7
0792:  BCF    F95.7
....................    i2c_write(0xa1); 
0794:  MOVLW  A1
0796:  MOVLB  1
0798:  MOVWF  x94
079A:  MOVLB  0
079C:  RCALL  04F2
....................    data=i2c_read(0); 
079E:  CLRF   00
07A0:  BRA    06BC
07A2:  MOVFF  01,190
....................    i2c_stop(); 
07A6:  BCF    F95.6
07A8:  NOP   
07AA:  BSF    F95.7
07AC:  BTFSS  F83.7
07AE:  BRA    07AC
07B0:  MOVLW  05
07B2:  MOVWF  00
07B4:  DECFSZ 00,F
07B6:  BRA    07B4
07B8:  BRA    07BA
07BA:  NOP   
07BC:  BSF    F95.6
07BE:  MOVLW  05
07C0:  MOVWF  00
07C2:  DECFSZ 00,F
07C4:  BRA    07C2
....................    return(data); 
07C6:  MOVLB  1
07C8:  MOVFF  190,01
07CC:  MOVLB  0
07CE:  RETURN 0
.................... } 
....................  
.................... //****************************************************************************** 
.................... // entradas 
.................... #define entrada01 PIN_B4 ////SENSOR 1              2  1 
.................... #define entrada02 PIN_D4 ////SENSOR 2              4  3 
.................... #define entrada03 PIN_B2 ////SENSOR 3              6  5 
.................... #define entrada04 PIN_B3 ////SENSOR 4 
.................... #define entrada05 PIN_B0 ////SENSOR 5 
.................... #define entrada06 PIN_B1 ////SENSOR 6 
....................  
.................... #define rst_cta PIN_D3    ////REINICIAR CONTADOR 
.................... #define frente PIN_D2     /// INDICADOR DE MAESTRO 
.................... #define B_silencio PIN_D1 /// BOTON PARA SILENCIAR (eliminado) 
.................... // salidas 
.................... #define salida01 PIN_C3 // Buzzer 
.................... #define salida02 PIN_C4 // Indicador de Sensado 
.................... #define salida03 PIN_C5 // Relay 
.................... const int s_cta = 5;    // numero de veces para verificar obsturbcion (sensibilidad de deteccion) 
.................... int size_s;             // Tamao de trama que espera leer el puerto serial (se utiliza para agilizar la captura de datos) 
.................... ///////VARIABLES DE CONEXION///// 
.................... int error, transmitir; // variable para indicar un error al escuchar la cuenta del poste trasero, bandera para inciar transmision a gprs 
.................... ///////GENERALES////////////////////// 
.................... int sumae1, sumas1;                                                  // Variables temporales de suma de entradas y salidas 
.................... int lim_b;                                                           // cuenta de sensores bloqueados 
.................... int fse1, fse2, fse3, fss1, fss2, fss3;                              // banderas que indican si los pares de sensores detectaron entrada o salida 
.................... unsigned int16 temporal1, temporal2, tempo_tn, sub_atras, baj_atras; // variables temporales para hacer calculos. 
.................... int16 entran1, salen1;                                               // variables temporales para hacer calculos. 
.................... ///////--------------------/////////// 
.................... int16 salian, time_clr; // variable temporal para guardar salidas 
.................... int ini, i, ii, j = 0, a, master = 0, flag_enviar, f_clr; 
.................... int16 b, n, cta_bloqueo, cta_enviar, total2_t;                                                //,envia_ent,envia_sal; 
.................... int cta_bloq1 = 0, cta_bloq2 = 0, cta_bloq3 = 0;                                              // variables para contar bloqueos por pares 
.................... int ent1 = 0, ent2 = 0, ent3 = 0, ent4 = 0, ent5 = 0, ent6 = 0;                               // variables de estado de sensores 
.................... int sen_ent = 0, sen_sal = 0;                                                                 // variables para definir el sentido (subio o bajo) 
.................... int16 sub_cta1 = 0, sub_cta2 = 0, sub_cta3 = 0, sub_cta4 = 0, sub_cta5 = 0, sub_cta6 = 0;     // variables para calculos de cuentas 
.................... int detec1, detec2, detec3, detec4, detec5, detec6;                                           // variables para determinar el cambio de estado de los sensores 
.................... int sub_d1, sub_d2, sub_d3, sub_d4, sub_d5, sub_d6;                                           // variables para determinar el cambio de estado de los sensores 
.................... int entra_act1 = 0, edo1 = 0, entra1 = 0, sale1 = 0, edoa1 = 0, enable1 = 0, entra_temp1 = 0; // variables para la maquina de estados de sensores par1 
.................... int entra_act2 = 0, edo2 = 0, entra2 = 0, sale2 = 0, edoa2 = 0, enable2 = 0, entra_temp2 = 0; // variables para la maquina de estados de sensores par2 
.................... int entra_act3 = 0, edo3 = 0, entra3 = 0, sale3 = 0, edoa3 = 0, enable3 = 0, entra_temp3 = 0; // variables para la maquina de estados de sensores par3 
.................... int16 entraront = 0, salieront = 0, pasaje = 0, pasajet = 0;                                  // cuenta total de entradas y salidas 
.................... int16 tem_entraront = 0, tem_salieront = 0, temporal3;                                        // cuenta total de entradas y salidas recibidas de cuentas del poste trasero. 
.................... int des1 = 0, des2 = 0, des3 = 0; 
.................... int bloq_p1, bloq_p2, bloq_p3, en_b1, en_b2, en_b3; 
.................... int16 tim_p1, tim_p2, tim_p3, segundoen, time_envio; 
.................... const int32 set_timer = 59286;  // 10ms 
.................... const int16 time_bloqueo = 500; // 5seg. 100=1seg. 
.................... int clear_lcd1, time_lcd1; 
.................... int y = 0; 
.................... int nuevo_pulso = 0; 
.................... int time_s3 = 0; 
.................... int fls3 = 0; 
.................... int cta_pulsos = 0; 
....................  
....................  
....................  
.................... char *textosearch[11] = {"V5.01     \r", 
....................                          "LEERCUENTA\r", 
....................                          "GRABAR_DAT\r", // GRABAR_DAT 
....................                          "BORRAR_ALL\r", // LEERCUENTA 
....................                          "SOLICITADO\r", 
....................                          "PASAJEROS:\r", 
....................                          "SERIALTEST\r", 
....................                          "SERIAL_TOK\r", 
....................                          "SUBIENDOC2\r", 
....................                          "SINFUNCION\r", 
....................                          "          \r" 
....................  
.................... }; 
....................  
.................... char version[] = "V1.0B"; //<---Version de codigo de contador 
....................  
.................... /////EEPROM/////////// 
.................... const int word_size = 10; // TAMAO DE LOS DATOS EN EEPROM//antes 8 
.................... const int data_set = 9; 
.................... char XX[word_size + 19]; // ARREGLO SERIAL 
.................... char entran[4]; 
.................... char salen[4]; 
.................... char bloqueado[3]; 
.................... char memory[word_size]; 
.................... //*******************************// 
.................... char tempo_tc[4]; 
.................... /////////////FUNCIONES///////////// 
.................... //void rev_suben(); 
.................... void cuenta_pulsos(); 
.................... void rev_suben(); 
.................... void enviop1(); 
.................... void finsuma(); 
.................... void leer_conta2(); 
.................... void graba_conta2(); 
....................  
.................... int convertir_to_entero(char *cadena); 
.................... int evaluar_string(char *command[]); 
.................... void envia2(); 
.................... void solicitar(); 
.................... void envio_master(); 
.................... void envio(); 
.................... void limpiar(); 
.................... void detecta_suma(); 
.................... void write_ent(); 
.................... void write_sal(); 
.................... void entraron_total(); 
.................... void salieron_total(); 
.................... void rd_eeprom(); 
.................... void rd_eeprom_inicio(); 
.................... // void llaves(); 
....................  
.................... void lcd_cuentas(); 
.................... void sentidos(); 
.................... void sensores(); 
.................... void sensando1(); 
.................... void sensando2(); 
.................... void sensando3(); 
.................... void contando1(); 
.................... void contando2(); 
.................... void contando3(); 
.................... void dar_dato(); 
.................... void reset(); 
.................... //------------------------------------------------------------------------------ 
.................... // Rutina de gestin de interrupciones 
.................... //------------------------------------------------------------------------------ 
.................... #int_TIMER1 // se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void) 
.................... { 
....................    time_clr++; 
*
00CE:  INCF   3E,F
00D0:  BTFSC  FD8.2
00D2:  INCF   3F,F
....................    time_s3++; 
00D4:  INCF   xAF,F
....................    segundoen++; 
00D6:  INCF   xA7,F
00D8:  BTFSC  FD8.2
00DA:  INCF   xA8,F
....................    if (segundoen >= 100) 
00DC:  MOVF   xA8,F
00DE:  BNZ   00E6
00E0:  MOVF   xA7,W
00E2:  SUBLW  63
00E4:  BC    00F2
....................    { 
....................       segundoen = 0; 
00E6:  CLRF   xA8
00E8:  CLRF   xA7
....................       time_envio++; 
00EA:  INCF   xA9,F
00EC:  BTFSC  FD8.2
00EE:  INCF   xAA,F
....................       time_lcd1++; 
00F0:  INCF   xAC,F
....................    } 
....................    //****Se definen los estados de los sensores (deteccion)***// 
....................    // sensor1 
....................    ent1 = input(entrada01); 
00F2:  BSF    F93.4
00F4:  CLRF   55
00F6:  BTFSC  F81.4
00F8:  INCF   55,F
....................    if (ent1 == 0) 
00FA:  MOVF   55,F
00FC:  BNZ   0104
....................       sub_cta1++; // ent1 =0 (no pulso) 
00FE:  INCF   5D,F
0100:  BTFSC  FD8.2
0102:  INCF   5E,F
....................    // sensor2 
....................    ent2 = input(entrada02); 
0104:  BSF    F95.4
0106:  CLRF   56
0108:  BTFSC  F83.4
010A:  INCF   56,F
....................    if (ent2 == 0) 
010C:  MOVF   56,F
010E:  BNZ   0116
....................       sub_cta2++; 
0110:  INCF   5F,F
0112:  BTFSC  FD8.2
0114:  INCF   x60,F
....................    // sensor3 
....................    ent3 = input(entrada03); 
0116:  BSF    F93.2
0118:  CLRF   57
011A:  BTFSC  F81.2
011C:  INCF   57,F
....................    if (ent3 == 0) 
011E:  MOVF   57,F
0120:  BNZ   0128
....................       sub_cta3++; 
0122:  INCF   x61,F
0124:  BTFSC  FD8.2
0126:  INCF   x62,F
....................    // sensor4 
....................    ent4 = input(entrada04); 
0128:  BSF    F93.3
012A:  CLRF   58
012C:  BTFSC  F81.3
012E:  INCF   58,F
....................    if (ent4 == 0) 
0130:  MOVF   58,F
0132:  BNZ   013A
....................       sub_cta4++; 
0134:  INCF   x63,F
0136:  BTFSC  FD8.2
0138:  INCF   x64,F
....................    // sensor5 
....................    ent5 = input(entrada05); 
013A:  BSF    F93.0
013C:  CLRF   59
013E:  BTFSC  F81.0
0140:  INCF   59,F
....................    if (ent5 == 0) 
0142:  MOVF   59,F
0144:  BNZ   014C
....................       sub_cta5++; 
0146:  INCF   x65,F
0148:  BTFSC  FD8.2
014A:  INCF   x66,F
....................    // sensor6 
....................    ent6 = input(entrada06); 
014C:  BSF    F93.1
014E:  CLRF   5A
0150:  BTFSC  F81.1
0152:  INCF   5A,F
....................    if (ent6 == 0) 
0154:  MOVF   5A,F
0156:  BNZ   015E
....................       sub_cta6++; 
0158:  INCF   x67,F
015A:  BTFSC  FD8.2
015C:  INCF   x68,F
....................    //****************************************// 
....................    tim_p1++; 
015E:  INCF   xA1,F
0160:  BTFSC  FD8.2
0162:  INCF   xA2,F
....................    tim_p2++; 
0164:  INCF   xA3,F
0166:  BTFSC  FD8.2
0168:  INCF   xA4,F
....................    tim_p3++; 
016A:  INCF   xA5,F
016C:  BTFSC  FD8.2
016E:  INCF   xA6,F
....................    cta_enviar++; 
0170:  INCF   4E,F
0172:  BTFSC  FD8.2
0174:  INCF   4F,F
....................    set_timer1(set_timer); // 10ms 
0176:  MOVLW  E7
0178:  MOVWF  FCF
017A:  MOVLW  96
017C:  MOVWF  FCE
.................... } 
.................... //****************************************************************************// 
....................  
017E:  BCF    F9E.0
0180:  GOTO   006C
.................... #int_rda 
.................... void isr_rs232() 
.................... {                              // escucha segundo poste 
....................    disable_interrupts(GLOBAL); // deshabilita interrupciones globales 
*
01E2:  BCF    FF2.6
01E4:  BCF    FF2.7
01E6:  BTFSC  FF2.7
01E8:  BRA    01E4
....................    i = 0;                      // CONTADOR DE ARREGLO SERIAL INICIADO 
01EA:  CLRF   41
....................  
....................    while (i <= 15) 
01EC:  MOVF   41,W
01EE:  SUBLW  0F
01F0:  BNC   0230
....................    { 
....................       XX[i] = fgetc(monitor); 
01F2:  CLRF   03
01F4:  MOVF   41,W
01F6:  ADDLW  52
01F8:  MOVWF  FE9
01FA:  MOVLW  01
01FC:  ADDWFC 03,W
01FE:  MOVWF  FEA
0200:  MOVFF  FEA,19F
0204:  MOVFF  FE9,19E
0208:  BRA    01A6
020A:  MOVFF  19F,FEA
020E:  MOVFF  19E,FE9
0212:  MOVFF  01,FEF
....................       i++; 
0216:  INCF   41,F
....................       if (XX[i] == 13) 
0218:  CLRF   03
021A:  MOVF   41,W
021C:  ADDLW  52
021E:  MOVWF  FE9
0220:  MOVLW  01
0222:  ADDWFC 03,W
0224:  MOVWF  FEA
0226:  MOVF   FEF,W
0228:  SUBLW  0D
022A:  BNZ   022E
....................          break; 
022C:  BRA    0230
022E:  BRA    01EC
....................    }; // se captura el dato del serial monitor(comunicacion entre pics) 
....................    j = 1; 
0230:  MOVLW  01
0232:  MOVWF  43
....................    y = 1; 
0234:  MOVWF  xAD
....................     
.................... } 
....................  
0236:  BCF    F9E.5
0238:  GOTO   006C
.................... #ZERO_RAM 
.................... void main() 
*
2AB2:  CLRF   FF8
2AB4:  BCF    FD0.7
2AB6:  BSF    07.7
2AB8:  MOVLW  FE
2ABA:  MOVWF  00
2ABC:  MOVLW  06
2ABE:  MOVWF  01
2AC0:  MOVLW  02
2AC2:  MOVWF  FE9
2AC4:  MOVLW  00
2AC6:  MOVWF  FEA
2AC8:  CLRF   FEE
2ACA:  DECFSZ 00,F
2ACC:  BRA    2AC8
2ACE:  DECFSZ 01,F
2AD0:  BRA    2AC8
2AD2:  CLRF   1F
2AD4:  BSF    FB8.3
2AD6:  MOVLW  08
2AD8:  MOVWF  FAF
2ADA:  MOVLW  02
2ADC:  MOVWF  FB0
2ADE:  MOVLW  A6
2AE0:  MOVWF  FAC
2AE2:  MOVLW  90
2AE4:  MOVWF  FAB
2AE6:  CLRF   20
2AE8:  BCF    F94.0
2AEA:  BSF    F8B.0
2AEC:  CLRF   43
2AEE:  CLRF   45
2AF0:  CLRF   52
2AF2:  CLRF   53
2AF4:  CLRF   54
2AF6:  CLRF   55
2AF8:  CLRF   56
2AFA:  CLRF   57
2AFC:  CLRF   58
2AFE:  CLRF   59
2B00:  CLRF   5A
2B02:  CLRF   5B
2B04:  CLRF   5C
2B06:  CLRF   5E
2B08:  CLRF   5D
2B0A:  CLRF   x60
2B0C:  CLRF   5F
2B0E:  CLRF   x62
2B10:  CLRF   x61
2B12:  CLRF   x64
2B14:  CLRF   x63
2B16:  CLRF   x66
2B18:  CLRF   x65
2B1A:  CLRF   x68
2B1C:  CLRF   x67
2B1E:  CLRF   x75
2B20:  CLRF   x76
2B22:  CLRF   x77
2B24:  CLRF   x78
2B26:  CLRF   x79
2B28:  CLRF   x7A
2B2A:  CLRF   x7B
2B2C:  CLRF   x7C
2B2E:  CLRF   x7D
2B30:  CLRF   x7E
2B32:  CLRF   x7F
2B34:  CLRF   x80
2B36:  CLRF   x81
2B38:  CLRF   x82
2B3A:  CLRF   x83
2B3C:  CLRF   x84
2B3E:  CLRF   x85
2B40:  CLRF   x86
2B42:  CLRF   x87
2B44:  CLRF   x88
2B46:  CLRF   x89
2B48:  CLRF   x8B
2B4A:  CLRF   x8A
2B4C:  CLRF   x8D
2B4E:  CLRF   x8C
2B50:  CLRF   x8F
2B52:  CLRF   x8E
2B54:  CLRF   x91
2B56:  CLRF   x90
2B58:  CLRF   x93
2B5A:  CLRF   x92
2B5C:  CLRF   x95
2B5E:  CLRF   x94
2B60:  CLRF   x98
2B62:  CLRF   x99
2B64:  CLRF   x9A
2B66:  CLRF   xAD
2B68:  CLRF   xAE
2B6A:  CLRF   xAF
2B6C:  CLRF   xB0
2B6E:  CLRF   xB1
2B70:  MOVF   FC1,W
2B72:  ANDLW  C0
2B74:  IORLW  0F
2B76:  MOVWF  FC1
2B78:  MOVLW  07
2B7A:  MOVWF  FB4
2B7C:  BRA    2C28
2B7E:  DATA 02,00
2B80:  DATA 19,00
2B82:  DATA 00,05
2B84:  DATA 00,C8
2B86:  DATA 56,35
2B88:  DATA 2E,30
2B8A:  DATA 31,05
2B8C:  DATA C0,20
2B8E:  DATA 6E,80
2B90:  DATA 0D,00
2B92:  DATA 4C,45
2B94:  DATA 45,52
2B96:  DATA 43,55
2B98:  DATA 45,4E
2B9A:  DATA 54,41
2B9C:  DATA 0D,00
2B9E:  DATA 47,52
2BA0:  DATA 41,42
2BA2:  DATA 41,52
2BA4:  DATA 5F,44
2BA6:  DATA 41,54
2BA8:  DATA 0D,00
2BAA:  DATA 42,4F
2BAC:  DATA 52,52
2BAE:  DATA 41,52
2BB0:  DATA 5F,41
2BB2:  DATA 4C,4C
2BB4:  DATA 0D,00
2BB6:  DATA 53,4F
2BB8:  DATA 4C,49
2BBA:  DATA 43,49
2BBC:  DATA 54,41
2BBE:  DATA 44,4F
2BC0:  DATA 0D,00
2BC2:  DATA 50,41
2BC4:  DATA 53,41
2BC6:  DATA 4A,45
2BC8:  DATA 52,4F
2BCA:  DATA 53,3A
2BCC:  DATA 0D,00
2BCE:  DATA 53,45
2BD0:  DATA 52,49
2BD2:  DATA 41,4C
2BD4:  DATA 54,45
2BD6:  DATA 53,54
2BD8:  DATA 0D,00
2BDA:  DATA 53,45
2BDC:  DATA 52,49
2BDE:  DATA 41,4C
2BE0:  DATA 5F,54
2BE2:  DATA 4F,4B
2BE4:  DATA 0D,00
2BE6:  DATA 53,55
2BE8:  DATA 42,49
2BEA:  DATA 45,4E
2BEC:  DATA 44,4F
2BEE:  DATA 43,32
2BF0:  DATA 0D,00
2BF2:  DATA 53,49
2BF4:  DATA 4E,46
2BF6:  DATA 55,4E
2BF8:  DATA 43,49
2BFA:  DATA 4F,4E
2BFC:  DATA 0D,00
2BFE:  DATA 0A,C0
2C00:  DATA 20,02
2C02:  DATA 80,0D
2C04:  DATA 00,16
2C06:  DATA 00,B2
2C08:  DATA C8,00
2C0A:  DATA D4,00
2C0C:  DATA E0,00
2C0E:  DATA EC,00
2C10:  DATA F8,00
2C12:  DATA 04,01
2C14:  DATA 10,01
2C16:  DATA 1C,01
2C18:  DATA 28,01
2C1A:  DATA 34,01
2C1C:  DATA 40,01
2C1E:  DATA 06,01
2C20:  DATA 4C,56
2C22:  DATA 31,2E
2C24:  DATA 30,42
2C26:  DATA 00,00
2C28:  MOVLW  00
2C2A:  MOVWF  FF8
2C2C:  MOVLW  2B
2C2E:  MOVWF  FF7
2C30:  MOVLW  7E
2C32:  MOVWF  FF6
2C34:  TBLRD*+
2C36:  MOVF   FF5,W
2C38:  MOVWF  00
2C3A:  XORLW  00
2C3C:  BZ    2C64
2C3E:  TBLRD*+
2C40:  MOVF   FF5,W
2C42:  MOVWF  01
2C44:  BTFSC  FE8.7
2C46:  BRA    2C52
2C48:  ANDLW  0F
2C4A:  MOVWF  FEA
2C4C:  TBLRD*+
2C4E:  MOVFF  FF5,FE9
2C52:  BTFSC  01.6
2C54:  TBLRD*+
2C56:  BTFSS  01.6
2C58:  TBLRD*+
2C5A:  MOVFF  FF5,FEE
2C5E:  DCFSNZ 00,F
2C60:  BRA    2C34
2C62:  BRA    2C56
2C64:  CLRF   FF8
.................... { 
....................    // Apaga entradas analogicas 
....................    setup_adc_ports(NO_ANALOGS); 
2C66:  MOVF   FC1,W
2C68:  ANDLW  C0
2C6A:  IORLW  0F
2C6C:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
2C6E:  BCF    FC2.0
....................    lcd_init();                               // inicia LCD 
2C70:  GOTO   0476
....................    init_ext_eeprom();                        // Inicia EEPROM 
2C74:  GOTO   04EA
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); // Configura timer1:Reloj interno, preescaler=8 
2C78:  MOVLW  B5
2C7A:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);            // Habilito interrupcin particular del TIMER1 
2C7C:  BSF    F9D.0
....................    set_timer1(set_timer);                    // Setea cuenta para la interrupcion. 
2C7E:  MOVLW  E7
2C80:  MOVWF  FCF
2C82:  MOVLW  96
2C84:  MOVWF  FCE
....................    disable_interrupts(INT_EXT);              // desabilita interrupciones externas 
2C86:  BCF    FF2.4
....................    enable_interrupts(GLOBAL);                // habilita interrupciones globales 
2C88:  MOVLW  C0
2C8A:  IORWF  FF2,F
....................    ///**************************************************************************/// 
....................    ////////Confuguracion de PWM//////// 
....................    output_low(PIN_C2); // CCP1 
2C8C:  BCF    F94.2
2C8E:  BCF    F8B.2
....................    setup_ccp1(CCP_PWM); 
2C90:  BCF    F94.2
2C92:  BCF    F8B.2
2C94:  MOVLW  0C
2C96:  MOVWF  FBD
....................    setup_timer_2(t2_div_By_1, 131, 1); // frecuencia 38khz 
2C98:  MOVLW  00
2C9A:  IORLW  04
2C9C:  MOVWF  FCA
2C9E:  MOVLW  83
2CA0:  MOVWF  FCB
....................    // set_pwm1_duty(26);//(5%) alto 
....................    set_pwm1_duty(279); //(10%) Parte alta del ciclo 
2CA2:  MOVLW  45
2CA4:  MOVWF  FBE
2CA6:  MOVF   FBD,W
2CA8:  ANDLW  CF
2CAA:  IORLW  30
2CAC:  MOVWF  FBD
....................    //////////////////////////////////// 
....................    ini = read_eeprom(100); // Carga estado de inicio 
2CAE:  MOVFF  FF2,18A
2CB2:  BCF    FF2.7
2CB4:  MOVLW  64
2CB6:  MOVWF  FA9
2CB8:  BCF    FA6.6
2CBA:  BCF    FA6.7
2CBC:  BSF    FA6.0
2CBE:  MOVF   FA8,W
2CC0:  MOVLB  1
2CC2:  BTFSC  x8A.7
2CC4:  BSF    FF2.7
2CC6:  MOVWF  40
....................    if (ini != 1) 
2CC8:  DECFSZ 40,W
2CCA:  BRA    2CCE
2CCC:  BRA    2D00
....................    {                        // Verifica si es la primera vez que se enciende el poste y graba configuracion inicial 
....................       write_eeprom(100, 1); // Graba inicio 
2CCE:  MOVF   FF2,W
2CD0:  MOVWF  00
2CD2:  BCF    FF2.7
2CD4:  MOVLW  64
2CD6:  MOVWF  FA9
2CD8:  MOVLW  01
2CDA:  MOVWF  FA8
2CDC:  BCF    FA6.6
2CDE:  BCF    FA6.7
2CE0:  BSF    FA6.2
2CE2:  MOVLB  F
2CE4:  MOVLW  55
2CE6:  MOVWF  FA7
2CE8:  MOVLW  AA
2CEA:  MOVWF  FA7
2CEC:  BSF    FA6.1
2CEE:  BTFSC  FA6.1
2CF0:  BRA    2CEE
2CF2:  BCF    FA6.2
2CF4:  MOVF   00,W
2CF6:  IORWF  FF2,F
....................       limpiar();            // pone en 0 el registro de cuentas almacenadas. 
2CF8:  MOVLB  0
2CFA:  CALL   0CD0
2CFE:  MOVLB  1
....................    } 
....................  
....................    // llaves();//Graba instrucciones de control en eeprom 
....................    ///////////////////////////////lee que tienen la memoria eeprom////////////////////////////////// 
....................    // rd_eeprom_inicio(); 
....................    ///////////////////////////////////////////////////////////////////////////////////////////////// 
....................    entraron_total();                            // carga el total de entradas registradas 
2D00:  MOVLB  0
2D02:  GOTO   0D3C
....................    salieron_total();                            // carga el total de salidas registradas 
2D06:  GOTO   0D96
....................    ent1 = ent2 = ent3 = ent4 = ent5 = ent6 = 0; // inicia en 0 variables de estado de sensores 
2D0A:  CLRF   5A
2D0C:  MOVFF  5A,59
2D10:  MOVFF  59,58
2D14:  MOVFF  58,57
2D18:  MOVFF  57,56
2D1C:  MOVFF  56,55
....................    tim_p1 = tim_p2 = tim_p3 = 0;                // inicia en 0 las cuentas para detectar sensores bloqueados 
2D20:  CLRF   xA6
2D22:  CLRF   xA5
2D24:  MOVFF  A6,A4
2D28:  MOVFF  A5,A3
2D2C:  MOVFF  A4,A2
2D30:  MOVFF  A3,A1
....................    en_b1 = en_b2 = en_b3 = 0;                   // bandera de pares bloqueados 
2D34:  CLRF   xA0
2D36:  MOVFF  A0,9F
2D3A:  MOVFF  9F,9E
....................    time_envio = 0;                              // inicia en 0 cuenta para transmitir datos 
2D3E:  CLRF   xAA
2D40:  CLRF   xA9
....................    if (input(frente)) 
2D42:  BSF    F95.2
2D44:  BTFSS  F83.2
2D46:  BRA    2D52
....................    { // revisa si es maestro (1) o escalvo (2) 
....................       master = 1; 
2D48:  MOVLW  01
2D4A:  MOVWF  45
....................       size_s = 29; 
2D4C:  MOVLW  1D
2D4E:  MOVWF  22
....................    } 
2D50:  BRA    2D58
....................    else 
....................    { 
....................       master = 0; 
2D52:  CLRF   45
....................       size_s = 15; 
2D54:  MOVLW  0F
2D56:  MOVWF  22
....................    } 
....................    lcd_cuentas();                   // Escribe texto base en LCD 
2D58:  CALL   0A18
....................    cta_bloq1 = read_ext_eeprom(9);  // carga bloqueos acumulados en par1 
2D5C:  MOVLB  1
2D5E:  CLRF   x8F
2D60:  MOVLW  09
2D62:  MOVWF  x8E
2D64:  MOVLB  0
2D66:  CALL   0728
2D6A:  MOVFF  01,52
....................    cta_bloq2 = read_ext_eeprom(10); // carga bloqueos acumulados en par2 
2D6E:  MOVLB  1
2D70:  CLRF   x8F
2D72:  MOVLW  0A
2D74:  MOVWF  x8E
2D76:  MOVLB  0
2D78:  CALL   0728
2D7C:  MOVFF  01,53
....................    cta_bloq3 = read_ext_eeprom(11); // carga bloqueos acumulados en par3 
2D80:  MOVLB  1
2D82:  CLRF   x8F
2D84:  MOVLW  0B
2D86:  MOVWF  x8E
2D88:  MOVLB  0
2D8A:  CALL   0728
2D8E:  MOVFF  01,54
....................    int tem_res; 
....................    tem_res = input(rst_cta); // inicializa variable de reset de cuenta fisico 
2D92:  BSF    F95.3
2D94:  MOVLB  1
2D96:  CLRF   x88
2D98:  BTFSC  F83.3
2D9A:  INCF   x88,F
....................    j = 0; 
2D9C:  CLRF   43
....................    flag_enviar = 0; 
2D9E:  CLRF   46
....................    salian = 0; 
2DA0:  CLRF   3D
2DA2:  CLRF   3C
....................    enable_interrupts(INT_RDA); // habilita interrupcion serial 
2DA4:  BSF    F9D.5
....................    setup_wdt(WDT_ON);          // habilita watch dog 
2DA6:  BSF    FD1.0
....................    sub_cta1 = sub_cta2 = sub_cta3 = sub_cta4 = sub_cta5 = sub_cta6 = 0; 
2DA8:  MOVLB  0
2DAA:  CLRF   x68
2DAC:  CLRF   x67
2DAE:  MOVFF  68,66
2DB2:  MOVFF  67,65
2DB6:  MOVFF  66,64
2DBA:  MOVFF  65,63
2DBE:  MOVFF  64,62
2DC2:  MOVFF  63,61
2DC6:  MOVFF  62,60
2DCA:  MOVFF  61,5F
2DCE:  MOVFF  60,5E
2DD2:  MOVFF  5F,5D
....................    tem_entraront = tem_salieront = 0; 
2DD6:  CLRF   x95
2DD8:  CLRF   x94
2DDA:  MOVFF  95,93
2DDE:  MOVFF  94,92
....................    error = 0; 
2DE2:  CLRF   23
....................    reset(); // Revisa causa de inicio del pic 
2DE4:  GOTO   0E12
....................    transmitir = 0; 
2DE8:  CLRF   24
....................    output_low(salida02); 
2DEA:  BCF    F94.4
2DEC:  BCF    F8B.4
....................    output_low(salida03); 
2DEE:  BCF    F94.5
2DF0:  BCF    F8B.5
....................    sub_atras = baj_atras = 0; 
2DF2:  CLRF   37
2DF4:  CLRF   36
2DF6:  MOVFF  37,35
2DFA:  MOVFF  36,34
....................    clear_lcd1 = 0; 
2DFE:  CLRF   xAB
....................    while (TRUE) 
....................    { 
....................       ///////////////////////preuba comunicacion serial con poste trasero/////////////// 
....................       // fprintf(monitor,"SOLICITADO");//4 
....................       // delay_ms(100); 
....................       if (y == 1) 
2E00:  DECFSZ xAD,W
2E02:  BRA    2E0A
....................       { 
....................          // fprintf(monitor,"XX=%c%c%c%c%c%c%c",XX[0],XX[1],XX[2],XX[3],XX[4],XX[5],XX[6]); 
....................          // fprintf(monitor,"XX=%s",XX); 
....................          enable_interrupts(GLOBAL); // habilita interrupciones globales 
2E04:  MOVLW  C0
2E06:  IORWF  FF2,F
....................          y = 0; 
2E08:  CLRF   xAD
....................       } 
....................  
....................       ////////////////////////////////////////////////////////////////////////////////// 
....................       if (tem_res != input(rst_cta)) 
2E0A:  BSF    F95.3
2E0C:  MOVLW  00
2E0E:  BTFSC  F83.3
2E10:  MOVLW  01
2E12:  MOVLB  1
2E14:  SUBWF  x88,W
2E16:  BZ    2E60
....................       { // BOTON DE RESET DE CUENTA 
....................          delay_ms(50); 
2E18:  MOVLW  32
2E1A:  MOVWF  x94
2E1C:  MOVLB  0
2E1E:  CALL   03BE
....................          if (tem_res != input(rst_cta)) 
2E22:  BSF    F95.3
2E24:  MOVLW  00
2E26:  BTFSC  F83.3
2E28:  MOVLW  01
2E2A:  MOVLB  1
2E2C:  SUBWF  x88,W
2E2E:  BZ    2E60
....................          { 
....................             tem_res = input(rst_cta); 
2E30:  BSF    F95.3
2E32:  CLRF   x88
2E34:  BTFSC  F83.3
2E36:  INCF   x88,F
....................             if ((master == 1) && (tem_res == 0)) 
2E38:  DECFSZ 45,W
2E3A:  BRA    2E60
2E3C:  MOVF   x88,F
2E3E:  BNZ   2E60
....................             { 
....................                fprintf(monitor, "BORRAR_ALL\r"); 
2E40:  MOVLW  3C
2E42:  MOVWF  FF6
2E44:  MOVLW  02
2E46:  MOVWF  FF7
2E48:  MOVLB  0
2E4A:  CALL   0DF0
....................                printf(lcd_putc, "\fBORRAR_ALL"); 
2E4E:  MOVLW  48
2E50:  MOVWF  FF6
2E52:  MOVLW  02
2E54:  MOVWF  FF7
2E56:  CALL   09F8
....................                limpiar(); 
2E5A:  CALL   0CD0
2E5E:  MOVLB  1
....................             } 
....................          } 
....................       } 
....................       //! 
....................       if (kbhit(GPS) && master) 
2E60:  BTFSC  F82.1
2E62:  BRA    2EE4
2E64:  MOVF   45,F
2E66:  BZ    2EE4
....................       {         // escucha gsm 
....................          i = 0; // CONTADOR DE ARREGLO SERIAL INICIADO 
2E68:  CLRF   41
....................          XX[i] = fgetc(GPS); 
2E6A:  CLRF   03
2E6C:  MOVF   41,W
2E6E:  ADDLW  52
2E70:  MOVWF  FE9
2E72:  MOVLW  01
2E74:  ADDWFC 03,W
2E76:  MOVWF  FEA
2E78:  MOVFF  FEA,18D
2E7C:  MOVFF  FE9,18C
2E80:  MOVLB  0
2E82:  CALL   0E4A
2E86:  MOVFF  18D,FEA
2E8A:  MOVFF  18C,FE9
2E8E:  MOVFF  01,FEF
....................          i++; 
2E92:  INCF   41,F
....................          if ((XX[0] >= 65) && (XX[0] <= 90)) 
2E94:  MOVLB  1
2E96:  MOVF   x52,W
2E98:  SUBLW  40
2E9A:  BC    2EE4
2E9C:  MOVF   x52,W
2E9E:  SUBLW  5A
2EA0:  BNC   2EE4
....................          { // validar no sea ruido 
....................             while (i <= word_size) 
2EA2:  MOVF   41,W
2EA4:  SUBLW  0A
2EA6:  BNC   2ED6
....................             { 
....................                XX[i] = fgetc(GPS); 
2EA8:  CLRF   03
2EAA:  MOVF   41,W
2EAC:  ADDLW  52
2EAE:  MOVWF  FE9
2EB0:  MOVLW  01
2EB2:  ADDWFC 03,W
2EB4:  MOVWF  FEA
2EB6:  MOVFF  FEA,18D
2EBA:  MOVFF  FE9,18C
2EBE:  MOVLB  0
2EC0:  CALL   0E4A
2EC4:  MOVFF  18D,FEA
2EC8:  MOVFF  18C,FE9
2ECC:  MOVFF  01,FEF
....................                i++; 
2ED0:  INCF   41,F
2ED2:  MOVLB  1
2ED4:  BRA    2EA2
....................             } 
....................             if (XX[1] == 'R') 
2ED6:  MOVF   x53,W
2ED8:  SUBLW  52
2EDA:  BNZ   2EE0
....................                XX[0] = 'G'; 
2EDC:  MOVLW  47
2EDE:  MOVWF  x52
....................             j = 1; 
2EE0:  MOVLW  01
2EE2:  MOVWF  43
....................          } /// 
....................          // sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
....................       } // end gps 
....................       //! 
....................       if (j == 1) 
2EE4:  DECFSZ 43,W
2EE6:  BRA    3082
....................       { // Revisa si hubo datos por cualquiera de los 2 puertos seriales 
....................          //rd_eeprom(); // valida dato recibido para ver si es una palabra de control 
....................          int caso_valor = evaluar_string(XX); 
2EE8:  MOVLW  01
2EEA:  MOVWF  x8B
2EEC:  MOVLW  52
2EEE:  MOVWF  x8A
2EF0:  MOVLB  0
2EF2:  GOTO   0F3A
2EF6:  MOVFF  01,189
....................          lcd_gotoxy(9, 1); 
2EFA:  MOVLW  09
2EFC:  MOVLB  1
2EFE:  MOVWF  x94
2F00:  MOVLW  01
2F02:  MOVWF  x95
2F04:  MOVLB  0
2F06:  CALL   0822
....................          printf(lcd_putc, "%d ", caso_valor); // pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
2F0A:  MOVFF  189,18A
2F0E:  MOVLW  18
2F10:  MOVLB  1
2F12:  MOVWF  x8B
2F14:  MOVLB  0
2F16:  CALL   0FC0
2F1A:  MOVLW  20
2F1C:  MOVLB  1
2F1E:  MOVWF  x93
2F20:  MOVLB  0
2F22:  CALL   0874
....................          switch (caso_valor) 
2F26:  MOVLW  01
2F28:  MOVLB  1
2F2A:  SUBWF  x89,W
2F2C:  ADDLW  F8
2F2E:  BTFSC  FD8.0
2F30:  BRA    3060
2F32:  ADDLW  08
2F34:  MOVLB  0
2F36:  GOTO   32EC
....................          { 
....................          case 1: 
....................          { // Se pone en 0 la cuenta 
....................             limpiar(); 
2F3A:  CALL   0CD0
....................             if (master == 1) 
2F3E:  DECFSZ 45,W
2F40:  BRA    2F4E
....................                fprintf(monitor, "BORRAR_ALL\r"); // 4 
2F42:  MOVLW  54
2F44:  MOVWF  FF6
2F46:  MOVLW  02
2F48:  MOVWF  FF7
2F4A:  CALL   0DF0
....................             break; 
2F4E:  MOVLB  1
2F50:  BRA    3060
2F52:  MOVLB  0
....................          } 
....................          case 2: 
....................          { // Se hace solicitud de cuenta del poste trasero 
....................             solicitar(); 
2F54:  CALL   107E
....................             break; 
2F58:  MOVLB  1
2F5A:  BRA    3060
2F5C:  MOVLB  0
....................          } 
....................          case 3: 
....................          { // Se pone en 0 la cuenta por peticion del GPRS 
....................             if (master == 1) 
2F5E:  DECFSZ 45,W
2F60:  BRA    2F6E
....................                fprintf(GPS, "RESET_OK\r\n"); // confirma a gsm 
2F62:  MOVLW  60
2F64:  MOVWF  FF6
2F66:  MOVLW  02
2F68:  MOVWF  FF7
2F6A:  GOTO   10E4
....................             delay_ms(1000); 
2F6E:  MOVLW  04
2F70:  MOVLB  1
2F72:  MOVWF  x8A
2F74:  MOVLW  FA
2F76:  MOVWF  x94
2F78:  MOVLB  0
2F7A:  CALL   03BE
2F7E:  MOVLB  1
2F80:  DECFSZ x8A,F
2F82:  BRA    2F74
....................             limpiar(); 
2F84:  MOVLB  0
2F86:  CALL   0CD0
....................             if (master == 1) 
2F8A:  DECFSZ 45,W
2F8C:  BRA    2F9A
....................                fprintf(monitor, "BORRAR_ALL\r"); // 4 
2F8E:  MOVLW  6C
2F90:  MOVWF  FF6
2F92:  MOVLW  02
2F94:  MOVWF  FF7
2F96:  CALL   0DF0
....................             break; 
2F9A:  MOVLB  1
2F9C:  BRA    3060
2F9E:  MOVLB  0
....................          } 
....................          case 4: 
....................          { // ver pasaje total de este acceso (contador atras) 
....................             envio_master(); 
2FA0:  CALL   12D0
....................             break; 
2FA4:  MOVLB  1
2FA6:  BRA    3060
2FA8:  MOVLB  0
....................          } 
....................          case 5: 
....................          { // envia a GPS pasaje total actual de ambos accesos (recibe cuenta de atras y suma) 
....................             flag_enviar = 0; 
2FAA:  CLRF   46
....................             enviop1(); 
2FAC:  GOTO   13A8
....................             transmitir = 1; 
2FB0:  MOVLW  01
2FB2:  MOVWF  24
....................             lcd_gotoxy(9, 4); 
2FB4:  MOVLW  09
2FB6:  MOVLB  1
2FB8:  MOVWF  x94
2FBA:  MOVLW  04
2FBC:  MOVWF  x95
2FBE:  MOVLB  0
2FC0:  CALL   0822
....................             lcd_putc("C2OK"); 
2FC4:  MOVLW  78
2FC6:  MOVWF  FF6
2FC8:  MOVLW  02
2FCA:  MOVWF  FF7
2FCC:  CALL   09F8
....................             break; 
2FD0:  MOVLB  1
2FD2:  BRA    3060
2FD4:  MOVLB  0
....................          } 
....................          case 6: 
....................          { // TEST DE COMUNICACION SERIAL 
....................             clear_lcd1 = 1; 
2FD6:  MOVLW  01
2FD8:  MOVWF  xAB
....................             time_lcd1 = 0; 
2FDA:  CLRF   xAC
....................             lcd_gotoxy(9, 3); 
2FDC:  MOVLW  09
2FDE:  MOVLB  1
2FE0:  MOVWF  x94
2FE2:  MOVLW  03
2FE4:  MOVWF  x95
2FE6:  MOVLB  0
2FE8:  CALL   0822
....................             lcd_putc("C1OK"); 
2FEC:  MOVLW  7E
2FEE:  MOVWF  FF6
2FF0:  MOVLW  02
2FF2:  MOVWF  FF7
2FF4:  CALL   09F8
....................             fprintf(monitor, "SERIAL_TOK\r"); // 
2FF8:  MOVLW  84
2FFA:  MOVWF  FF6
2FFC:  MOVLW  02
2FFE:  MOVWF  FF7
3000:  CALL   0DF0
....................             break; 
3004:  MOVLB  1
3006:  BRA    3060
3008:  MOVLB  0
....................          } 
....................          case 7: 
....................          { // CONFIRMACION DE COMUNICACION SERIAL 
....................             clear_lcd1 = 1; 
300A:  MOVLW  01
300C:  MOVWF  xAB
....................             time_lcd1 = 0; 
300E:  CLRF   xAC
....................             lcd_gotoxy(9, 4); 
3010:  MOVLW  09
3012:  MOVLB  1
3014:  MOVWF  x94
3016:  MOVLW  04
3018:  MOVWF  x95
301A:  MOVLB  0
301C:  CALL   0822
....................             lcd_putc("C2OK"); 
3020:  MOVLW  90
3022:  MOVWF  FF6
3024:  MOVLW  02
3026:  MOVWF  FF7
3028:  CALL   09F8
....................             break; 
302C:  MOVLB  1
302E:  BRA    3060
3030:  MOVLB  0
....................          } 
....................          case 8: 
....................          { // Suben por atras 
....................             clear_lcd1 = 1; 
3032:  MOVLW  01
3034:  MOVWF  xAB
....................             time_lcd1 = 0; 
3036:  CLRF   xAC
....................             lcd_gotoxy(9, 4); 
3038:  MOVLW  09
303A:  MOVLB  1
303C:  MOVWF  x94
303E:  MOVLW  04
3040:  MOVWF  x95
3042:  MOVLB  0
3044:  CALL   0822
....................             cuenta_pulsos(); 
3048:  CALL   152E
....................             lcd_putc("Sub2"); 
304C:  MOVLW  96
304E:  MOVWF  FF6
3050:  MOVLW  02
3052:  MOVWF  FF7
3054:  CALL   09F8
....................             break; 
3058:  MOVLB  1
305A:  BRA    3060
305C:  MOVLB  0
305E:  MOVLB  1
....................          } 
....................          } // end switch 
....................          memset(XX, 0, sizeof(XX)); 
3060:  MOVLW  01
3062:  MOVWF  FEA
3064:  MOVLW  52
3066:  MOVWF  FE9
3068:  CLRF   00
306A:  CLRF   02
306C:  MOVLW  1D
306E:  MOVWF  01
3070:  MOVLB  0
3072:  CALL   138E
....................          time_clr = 0; 
3076:  CLRF   3F
3078:  CLRF   3E
....................          f_clr = 1; 
307A:  MOVLW  01
307C:  MOVWF  47
....................          j = 0; 
307E:  CLRF   43
3080:  MOVLB  1
....................       } 
....................       // if( (time_envio>=180)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
....................       if ((time_envio >= 10) && (master)) 
3082:  MOVLB  0
3084:  MOVF   xAA,F
3086:  BNZ   308E
3088:  MOVF   xA9,W
308A:  SUBLW  09
308C:  BC    3096
308E:  MOVF   45,F
3090:  BZ    3096
....................       { // Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
....................          solicitar(); 
3092:  CALL   107E
....................       } 
....................       if ((clear_lcd1) && (time_lcd1 >= 10)) 
3096:  MOVF   xAB,F
3098:  BZ    30F6
309A:  MOVF   xAC,W
309C:  SUBLW  09
309E:  BC    30F6
....................       { // cronometro para limpiar notificaciones LCD 
....................          clear_lcd1 = 0; 
30A0:  CLRF   xAB
....................          lcd_gotoxy(9, 1); 
30A2:  MOVLW  09
30A4:  MOVLB  1
30A6:  MOVWF  x94
30A8:  MOVLW  01
30AA:  MOVWF  x95
30AC:  MOVLB  0
30AE:  CALL   0822
....................          lcd_putc("    "); 
30B2:  MOVLW  9C
30B4:  MOVWF  FF6
30B6:  MOVLW  02
30B8:  MOVWF  FF7
30BA:  CALL   09F8
....................          lcd_gotoxy(9, 3); 
30BE:  MOVLW  09
30C0:  MOVLB  1
30C2:  MOVWF  x94
30C4:  MOVLW  03
30C6:  MOVWF  x95
30C8:  MOVLB  0
30CA:  CALL   0822
....................          lcd_putc("    "); 
30CE:  MOVLW  A2
30D0:  MOVWF  FF6
30D2:  MOVLW  02
30D4:  MOVWF  FF7
30D6:  CALL   09F8
....................          lcd_gotoxy(9, 4); 
30DA:  MOVLW  09
30DC:  MOVLB  1
30DE:  MOVWF  x94
30E0:  MOVLW  04
30E2:  MOVWF  x95
30E4:  MOVLB  0
30E6:  CALL   0822
....................          lcd_putc("    "); 
30EA:  MOVLW  A8
30EC:  MOVWF  FF6
30EE:  MOVLW  02
30F0:  MOVWF  FF7
30F2:  CALL   09F8
....................       } 
....................  
....................       if ((flag_enviar) && (cta_enviar >= 2000) && (master)) 
30F6:  MOVF   46,F
30F8:  BZ    3112
30FA:  MOVF   4F,W
30FC:  SUBLW  06
30FE:  BC    3112
3100:  XORLW  FF
3102:  BNZ   310A
3104:  MOVF   4E,W
3106:  SUBLW  CF
3108:  BC    3112
310A:  MOVF   45,F
310C:  BZ    3112
....................          envia2(); // Si el poste esclavo no contesta enviar sin conexion 
310E:  GOTO   16A6
....................       if (transmitir) 
3112:  MOVF   24,F
3114:  BZ    311A
....................          envio(); // cuando el esclavo reporto su cuenta, maestro prepara paquete para mandar a la nube 
3116:  GOTO   189C
....................  
....................       if ((bloq_p1) && (tim_p1 >= time_bloqueo) && (!en_b1)) 
311A:  MOVF   x9B,F
311C:  BZ    318A
311E:  MOVF   xA2,W
3120:  SUBLW  00
3122:  BC    318A
3124:  XORLW  FF
3126:  BNZ   312E
3128:  MOVF   xA1,W
312A:  SUBLW  F3
312C:  BC    318A
312E:  MOVF   x9E,F
3130:  BNZ   318A
....................       {               // bloqueo de par 1 por ms de X segundos 
....................          bloq_p1 = 0; // bandera de par de sensores bloqueados detectando, no significa contador bloqueado 
3132:  CLRF   x9B
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
3134:  MOVF   x9E,F
3136:  BNZ   3186
3138:  MOVF   x9F,F
313A:  BNZ   3186
313C:  MOVF   xA0,F
313E:  BNZ   3186
....................          {                     // si no habia un bloqueo antes 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
3140:  MOVLW  0A
3142:  MOVLB  1
3144:  MOVWF  x94
3146:  MOVLW  01
3148:  MOVWF  x95
314A:  MOVLB  0
314C:  CALL   0822
....................             lcd_putc("BL"); 
3150:  MOVLW  AE
3152:  MOVWF  FF6
3154:  MOVLW  02
3156:  MOVWF  FF7
3158:  CALL   09F8
....................             cta_bloq1++; 
315C:  INCF   52,F
....................             write_ext_eeprom(9, cta_bloq1); // bloq1 
315E:  MOVLB  1
3160:  CLRF   x8F
3162:  MOVLW  09
3164:  MOVWF  x8E
3166:  MOVFF  52,190
316A:  MOVLB  0
316C:  CALL   0568
....................             if ((master == 1) && (j == 0)) 
3170:  DECFSZ 45,W
3172:  BRA    317E
3174:  MOVF   43,F
3176:  BNZ   317E
....................                solicitar(); 
3178:  CALL   107E
317C:  BRA    3186
....................             else if (j == 0) 
317E:  MOVF   43,F
3180:  BNZ   3186
....................                envio_master(); 
3182:  CALL   12D0
....................          } 
....................          en_b1 = 1; // bandera de bloqueo detectado en par 1 
3186:  MOVLW  01
3188:  MOVWF  x9E
....................       } 
....................       if ((bloq_p2) && (tim_p2 >= time_bloqueo) && (!en_b2)) 
318A:  MOVF   x9C,F
318C:  BZ    31FA
318E:  MOVF   xA4,W
3190:  SUBLW  00
3192:  BC    31FA
3194:  XORLW  FF
3196:  BNZ   319E
3198:  MOVF   xA3,W
319A:  SUBLW  F3
319C:  BC    31FA
319E:  MOVF   x9F,F
31A0:  BNZ   31FA
....................       { // bloqueo de par 2 por ms de X segundos 
....................          bloq_p2 = 0; 
31A2:  CLRF   x9C
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
31A4:  MOVF   x9E,F
31A6:  BNZ   31F6
31A8:  MOVF   x9F,F
31AA:  BNZ   31F6
31AC:  MOVF   xA0,F
31AE:  BNZ   31F6
....................          { 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
31B0:  MOVLW  0A
31B2:  MOVLB  1
31B4:  MOVWF  x94
31B6:  MOVLW  01
31B8:  MOVWF  x95
31BA:  MOVLB  0
31BC:  CALL   0822
....................             lcd_putc("BL"); 
31C0:  MOVLW  B2
31C2:  MOVWF  FF6
31C4:  MOVLW  02
31C6:  MOVWF  FF7
31C8:  CALL   09F8
....................             cta_bloq2++; 
31CC:  INCF   53,F
....................             write_ext_eeprom(10, cta_bloq2); // bloq2 
31CE:  MOVLB  1
31D0:  CLRF   x8F
31D2:  MOVLW  0A
31D4:  MOVWF  x8E
31D6:  MOVFF  53,190
31DA:  MOVLB  0
31DC:  CALL   0568
....................             if ((master == 1) && (j == 0)) 
31E0:  DECFSZ 45,W
31E2:  BRA    31EE
31E4:  MOVF   43,F
31E6:  BNZ   31EE
....................                solicitar(); 
31E8:  CALL   107E
31EC:  BRA    31F6
....................             else if (j == 0) 
31EE:  MOVF   43,F
31F0:  BNZ   31F6
....................                envio_master(); 
31F2:  CALL   12D0
....................          } 
....................          en_b2 = 1; 
31F6:  MOVLW  01
31F8:  MOVWF  x9F
....................       } 
....................       if ((bloq_p3) && (tim_p3 >= time_bloqueo) && (!en_b3)) 
31FA:  MOVF   x9D,F
31FC:  BZ    326A
31FE:  MOVF   xA6,W
3200:  SUBLW  00
3202:  BC    326A
3204:  XORLW  FF
3206:  BNZ   320E
3208:  MOVF   xA5,W
320A:  SUBLW  F3
320C:  BC    326A
320E:  MOVF   xA0,F
3210:  BNZ   326A
....................       { // bloqueo de par 3 por ms de X segundos 
....................          bloq_p3 = 0; 
3212:  CLRF   x9D
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
3214:  MOVF   x9E,F
3216:  BNZ   3266
3218:  MOVF   x9F,F
321A:  BNZ   3266
321C:  MOVF   xA0,F
321E:  BNZ   3266
....................          { 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
3220:  MOVLW  0A
3222:  MOVLB  1
3224:  MOVWF  x94
3226:  MOVLW  01
3228:  MOVWF  x95
322A:  MOVLB  0
322C:  CALL   0822
....................             lcd_putc("BL"); 
3230:  MOVLW  B6
3232:  MOVWF  FF6
3234:  MOVLW  02
3236:  MOVWF  FF7
3238:  CALL   09F8
....................             cta_bloq3++; 
323C:  INCF   54,F
....................             write_ext_eeprom(11, cta_bloq3); // bloq3 
323E:  MOVLB  1
3240:  CLRF   x8F
3242:  MOVLW  0B
3244:  MOVWF  x8E
3246:  MOVFF  54,190
324A:  MOVLB  0
324C:  CALL   0568
....................             if ((master == 1) && (j == 0)) 
3250:  DECFSZ 45,W
3252:  BRA    325E
3254:  MOVF   43,F
3256:  BNZ   325E
....................                solicitar(); 
3258:  CALL   107E
325C:  BRA    3266
....................             else if (j == 0) 
325E:  MOVF   43,F
3260:  BNZ   3266
....................                envio_master(); 
3262:  CALL   12D0
....................          } 
....................          en_b3 = 1; 
3266:  MOVLW  01
3268:  MOVWF  xA0
....................       } // end deteccion 
....................       if ((!bloq_p3) && (!bloq_p2) && (!bloq_p1)) 
326A:  MOVF   x9D,F
326C:  BNZ   3292
326E:  MOVF   x9C,F
3270:  BNZ   3292
3272:  MOVF   x9B,F
3274:  BNZ   3292
....................       { // Si todos los pares estan desbloqueados limpia estado de bloqueo LCD 
....................          lcd_gotoxy(10, 1); 
3276:  MOVLW  0A
3278:  MOVLB  1
327A:  MOVWF  x94
327C:  MOVLW  01
327E:  MOVWF  x95
3280:  MOVLB  0
3282:  CALL   0822
....................          lcd_putc("  "); 
3286:  MOVLW  BA
3288:  MOVWF  FF6
328A:  MOVLW  02
328C:  MOVWF  FF7
328E:  CALL   09F8
....................       } 
....................  
....................       if ((time_clr >= 900) && (f_clr)) 
3292:  MOVF   3F,W
3294:  SUBLW  02
3296:  BC    32AC
3298:  XORLW  FF
329A:  BNZ   32A2
329C:  MOVF   3E,W
329E:  SUBLW  83
32A0:  BC    32AC
32A2:  MOVF   47,F
32A4:  BZ    32AC
....................       { // refresca LCD 
....................          lcd_cuentas(); 
32A6:  CALL   0A18
....................          f_clr = 0; 
32AA:  CLRF   47
....................       } 
....................       sensores(); // Revisa estado de los sensores 
32AC:  GOTO   274E
....................        ////////////////// verificar si ya cont el pasajero y enva pulso por relay ////////////////////////////////////////// 
....................       if ((nuevo_pulso==1) && (time_s3 >= 100)) 
32B0:  DECFSZ xAE,W
32B2:  BRA    32CA
32B4:  MOVF   xAF,W
32B6:  SUBLW  63
32B8:  BC    32CA
....................       { // Nuevo Pulso de subida para impresion (flanco alto) 
....................          nuevo_pulso = 0; 
32BA:  CLRF   xAE
....................          fls3 = 1; 
32BC:  MOVLW  01
32BE:  MOVWF  xB0
....................          time_s3 = 0; 
32C0:  CLRF   xAF
....................          output_high(salida03); 
32C2:  BCF    F94.5
32C4:  BSF    F8B.5
....................          rev_suben(); 
32C6:  CALL   1528
....................       } 
....................       ///////////////apagar pulso de relay///////////////////////////////////////////////////////////////////////////////////// 
....................       if ((time_s3 >= 10) && (fls3)) 
32CA:  MOVF   xAF,W
32CC:  SUBLW  09
32CE:  BC    32E6
32D0:  MOVF   xB0,F
32D2:  BZ    32E6
....................       { // Pulsos de subida para impresion (flanco bajo) 
....................          output_low(salida03); 
32D4:  BCF    F94.5
32D6:  BCF    F8B.5
....................          cta_pulsos--; 
32D8:  DECF   xB1,F
....................          if (cta_pulsos > 0) 
32DA:  MOVF   xB1,F
32DC:  BZ    32E2
....................             nuevo_pulso = 1; 
32DE:  MOVLW  01
32E0:  MOVWF  xAE
....................          fls3 = 0; 
32E2:  CLRF   xB0
....................          time_s3 = 0; 
32E4:  CLRF   xAF
....................       } 
....................       ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................       restart_wdt(); 
32E6:  CLRWDT
32E8:  BRA    2E00
....................    } // end true 
.................... } // end main 
....................  
32EA:  SLEEP 
.................... void solicitar() 
.................... {                                    // Solicita cuenta al poste esclavo 
....................    fprintf(monitor, "SOLICITADO\r"); // 4 
*
107E:  MOVLW  BE
1080:  MOVWF  FF6
1082:  MOVLW  02
1084:  MOVWF  FF7
1086:  RCALL  0DF0
....................    time_envio = 0; 
1088:  CLRF   xAA
108A:  CLRF   xA9
....................    flag_enviar = 1; 
108C:  MOVLW  01
108E:  MOVWF  46
....................    cta_enviar = 0; 
1090:  CLRF   4F
1092:  CLRF   4E
1094:  RETURN 0
.................... } 
....................  
.................... void envio_master() 
.................... { // reporta al maestro 
....................    int16 envit; 
....................    envit = (entraront + salieront) / 2; 
*
12D0:  MOVF   x8C,W
12D2:  ADDWF  x8A,W
12D4:  MOVLB  1
12D6:  MOVWF  x8C
12D8:  MOVLB  0
12DA:  MOVF   x8D,W
12DC:  ADDWFC x8B,W
12DE:  MOVLB  1
12E0:  MOVWF  x8D
12E2:  BCF    FD8.0
12E4:  RRCF   x8D,W
12E6:  MOVWF  x8B
12E8:  RRCF   x8C,W
12EA:  MOVWF  x8A
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
12EC:  MOVF   53,W
12EE:  ADDWF  52,W
12F0:  ADDWF  54,W
12F2:  MOVWF  4C
12F4:  CLRF   4D
....................    clear_lcd1 = 1; 
12F6:  MOVLW  01
12F8:  MOVLB  0
12FA:  MOVWF  xAB
....................    time_lcd1 = 0; 
12FC:  CLRF   xAC
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
12FE:  MOVLW  09
1300:  MOVLB  1
1302:  MOVWF  x94
1304:  MOVLW  03
1306:  MOVWF  x95
1308:  MOVLB  0
130A:  CALL   0822
....................    lcd_putc(0xAB); 
130E:  MOVLW  AB
1310:  MOVLB  1
1312:  MOVWF  x93
1314:  MOVLB  0
1316:  CALL   0874
....................    fprintf(monitor, "PASAJEROS:%04Ld/%04Ld/%03Ld/%04Lu/\r", entraront, salieront, cta_bloqueo, envit); 
131A:  MOVLW  CA
131C:  MOVWF  FF6
131E:  MOVLW  02
1320:  MOVWF  FF7
1322:  MOVLW  0A
1324:  MOVLB  1
1326:  MOVWF  x8C
1328:  MOVLB  0
132A:  BRA    1106
132C:  MOVLW  0A
132E:  MOVWF  FE9
1330:  MOVFF  8B,18D
1334:  MOVFF  8A,18C
1338:  RCALL  1132
133A:  MOVLW  2F
133C:  BTFSS  F9E.4
133E:  BRA    133C
1340:  MOVWF  FAD
1342:  MOVLW  0A
1344:  MOVWF  FE9
1346:  MOVFF  8D,18D
134A:  MOVFF  8C,18C
134E:  RCALL  1132
1350:  MOVLW  2F
1352:  BTFSS  F9E.4
1354:  BRA    1352
1356:  MOVWF  FAD
1358:  MOVLW  0B
135A:  MOVWF  FE9
135C:  MOVFF  4D,18D
1360:  MOVFF  4C,18C
1364:  RCALL  1132
1366:  MOVLW  2F
1368:  BTFSS  F9E.4
136A:  BRA    1368
136C:  MOVWF  FAD
136E:  MOVLW  09
1370:  MOVWF  FE9
1372:  MOVFF  18B,18D
1376:  MOVFF  18A,18C
137A:  BRA    121C
137C:  MOVLW  2F
137E:  BTFSS  F9E.4
1380:  BRA    137E
1382:  MOVWF  FAD
1384:  MOVLW  0D
1386:  BTFSS  F9E.4
1388:  BRA    1386
138A:  MOVWF  FAD
138C:  RETURN 0
....................    // fprintf(monitor,"PASAJEROS:\r"); 
....................    // fprintf(monitor,"PASAJERO\r-%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
.................... } 
....................  
.................... int convertir_to_entero(char *cadena) 
*
17F4:  MOVLB  1
17F6:  CLRF   x8C
.................... { 
....................    int valor = 0; 
....................    if (cadena == '0') 
17F8:  MOVF   x8A,W
17FA:  SUBLW  30
17FC:  BNZ   1806
17FE:  MOVF   x8B,F
1800:  BNZ   1806
....................       valor = 0; 
1802:  CLRF   x8C
1804:  BRA    1894
....................    else if (cadena == '1') 
1806:  MOVF   x8A,W
1808:  SUBLW  31
180A:  BNZ   1816
180C:  MOVF   x8B,F
180E:  BNZ   1816
....................       valor = 1; 
1810:  MOVLW  01
1812:  MOVWF  x8C
1814:  BRA    1894
....................    else if (cadena == '2') 
1816:  MOVF   x8A,W
1818:  SUBLW  32
181A:  BNZ   1826
181C:  MOVF   x8B,F
181E:  BNZ   1826
....................       valor = 2; 
1820:  MOVLW  02
1822:  MOVWF  x8C
1824:  BRA    1894
....................    else if (cadena == '3') 
1826:  MOVF   x8A,W
1828:  SUBLW  33
182A:  BNZ   1836
182C:  MOVF   x8B,F
182E:  BNZ   1836
....................       valor = 3; 
1830:  MOVLW  03
1832:  MOVWF  x8C
1834:  BRA    1894
....................    else if (cadena == '4') 
1836:  MOVF   x8A,W
1838:  SUBLW  34
183A:  BNZ   1846
183C:  MOVF   x8B,F
183E:  BNZ   1846
....................       valor = 4; 
1840:  MOVLW  04
1842:  MOVWF  x8C
1844:  BRA    1894
....................    else if (cadena == '5') 
1846:  MOVF   x8A,W
1848:  SUBLW  35
184A:  BNZ   1856
184C:  MOVF   x8B,F
184E:  BNZ   1856
....................       valor = 5; 
1850:  MOVLW  05
1852:  MOVWF  x8C
1854:  BRA    1894
....................    else if (cadena == '6') 
1856:  MOVF   x8A,W
1858:  SUBLW  36
185A:  BNZ   1866
185C:  MOVF   x8B,F
185E:  BNZ   1866
....................       valor = 6; 
1860:  MOVLW  06
1862:  MOVWF  x8C
1864:  BRA    1894
....................    else if (cadena == '7') 
1866:  MOVF   x8A,W
1868:  SUBLW  37
186A:  BNZ   1876
186C:  MOVF   x8B,F
186E:  BNZ   1876
....................       valor = 7; 
1870:  MOVLW  07
1872:  MOVWF  x8C
1874:  BRA    1894
....................    else if (cadena == '8') 
1876:  MOVF   x8A,W
1878:  SUBLW  38
187A:  BNZ   1886
187C:  MOVF   x8B,F
187E:  BNZ   1886
....................       valor = 8; 
1880:  MOVLW  08
1882:  MOVWF  x8C
1884:  BRA    1894
....................    else if (cadena == '9') 
1886:  MOVF   x8A,W
1888:  SUBLW  39
188A:  BNZ   1894
188C:  MOVF   x8B,F
188E:  BNZ   1894
....................       valor = 9; 
1890:  MOVLW  09
1892:  MOVWF  x8C
....................    return valor; 
1894:  MOVFF  18C,01
1898:  MOVLB  0
189A:  RETURN 0
.................... } 
....................  
.................... void enviop1() 
.................... { // Convierte a enteros la cadena recibida por el poste esclavo 
....................    disable_interrupts(INT_RDA); 
*
13A8:  BCF    F9D.5
....................    entran1 = 0; 
13AA:  CLRF   39
13AC:  CLRF   38
....................    salen1 = 0; 
13AE:  CLRF   3B
13B0:  CLRF   3A
....................    temporal1 = 0; 
13B2:  CLRF   2F
13B4:  CLRF   2E
....................    temporal2 = 0; 
13B6:  CLRF   31
13B8:  CLRF   30
....................    temporal3 = 0; 
13BA:  CLRF   x97
13BC:  CLRF   x96
....................    tempo_tn = 0; 
13BE:  CLRF   33
13C0:  CLRF   32
....................    pasajet = 0; 
13C2:  CLRF   x91
13C4:  CLRF   x90
....................    memset(entran, 0, sizeof(entran));       // entran=0; 
13C6:  MOVLW  01
13C8:  MOVWF  FEA
13CA:  MOVLW  6F
13CC:  MOVWF  FE9
13CE:  CLRF   00
13D0:  CLRF   02
13D2:  MOVLW  04
13D4:  MOVWF  01
13D6:  RCALL  138E
....................    memset(salen, 0, sizeof(salen));         // salen=0; 
13D8:  MOVLW  01
13DA:  MOVWF  FEA
13DC:  MOVLW  73
13DE:  MOVWF  FE9
13E0:  CLRF   00
13E2:  CLRF   02
13E4:  MOVLW  04
13E6:  MOVWF  01
13E8:  RCALL  138E
....................    memset(bloqueado, 0, sizeof(bloqueado)); // bloqueado=0; 
13EA:  MOVLW  01
13EC:  MOVWF  FEA
13EE:  MOVLW  77
13F0:  MOVWF  FE9
13F2:  CLRF   00
13F4:  CLRF   02
13F6:  MOVLW  03
13F8:  MOVWF  01
13FA:  RCALL  138E
....................    memset(bloqueado, 0, sizeof(tempo_tc));  // total 
13FC:  MOVLW  01
13FE:  MOVWF  FEA
1400:  MOVLW  77
1402:  MOVWF  FE9
1404:  CLRF   00
1406:  CLRF   02
1408:  MOVLW  04
140A:  MOVWF  01
140C:  RCALL  138E
....................    i = 10; 
140E:  MOVLW  0A
1410:  MOVWF  41
....................    ii = 0; 
1412:  CLRF   42
....................    for (ii = 0; ii <= 3; ii++) 
1414:  CLRF   42
1416:  MOVF   42,W
1418:  SUBLW  03
141A:  BNC   1458
....................       entran[ii] = XX[10 + ii]; 
141C:  CLRF   03
141E:  MOVF   42,W
1420:  ADDLW  6F
1422:  MOVWF  01
1424:  MOVLW  01
1426:  ADDWFC 03,F
1428:  MOVFF  01,18A
142C:  MOVLB  1
142E:  MOVFF  03,18B
1432:  MOVLW  0A
1434:  ADDWF  42,W
1436:  CLRF   03
1438:  ADDLW  52
143A:  MOVWF  FE9
143C:  MOVLW  01
143E:  ADDWFC 03,W
1440:  MOVWF  FEA
1442:  MOVFF  FEF,18C
1446:  MOVFF  18B,FEA
144A:  MOVFF  01,FE9
144E:  MOVFF  18C,FEF
1452:  INCF   42,F
1454:  MOVLB  0
1456:  BRA    1416
....................    for (ii = 0; ii <= 3; ii++) 
1458:  CLRF   42
145A:  MOVF   42,W
145C:  SUBLW  03
145E:  BNC   149C
....................       salen[ii] = XX[15 + ii]; 
1460:  CLRF   03
1462:  MOVF   42,W
1464:  ADDLW  73
1466:  MOVWF  01
1468:  MOVLW  01
146A:  ADDWFC 03,F
146C:  MOVFF  01,18A
1470:  MOVLB  1
1472:  MOVFF  03,18B
1476:  MOVLW  0F
1478:  ADDWF  42,W
147A:  CLRF   03
147C:  ADDLW  52
147E:  MOVWF  FE9
1480:  MOVLW  01
1482:  ADDWFC 03,W
1484:  MOVWF  FEA
1486:  MOVFF  FEF,18C
148A:  MOVFF  18B,FEA
148E:  MOVFF  01,FE9
1492:  MOVFF  18C,FEF
1496:  INCF   42,F
1498:  MOVLB  0
149A:  BRA    145A
....................    for (ii = 0; ii <= 2; ii++) 
149C:  CLRF   42
149E:  MOVF   42,W
14A0:  SUBLW  02
14A2:  BNC   14E0
....................       bloqueado[ii] = XX[20 + ii]; 
14A4:  CLRF   03
14A6:  MOVF   42,W
14A8:  ADDLW  77
14AA:  MOVWF  01
14AC:  MOVLW  01
14AE:  ADDWFC 03,F
14B0:  MOVFF  01,18A
14B4:  MOVLB  1
14B6:  MOVFF  03,18B
14BA:  MOVLW  14
14BC:  ADDWF  42,W
14BE:  CLRF   03
14C0:  ADDLW  52
14C2:  MOVWF  FE9
14C4:  MOVLW  01
14C6:  ADDWFC 03,W
14C8:  MOVWF  FEA
14CA:  MOVFF  FEF,18C
14CE:  MOVFF  18B,FEA
14D2:  MOVFF  01,FE9
14D6:  MOVFF  18C,FEF
14DA:  INCF   42,F
14DC:  MOVLB  0
14DE:  BRA    149E
....................    for (ii = 0; ii <= 3; ii++) 
14E0:  CLRF   42
14E2:  MOVF   42,W
14E4:  SUBLW  03
14E6:  BNC   1524
....................       tempo_tc[ii] = XX[24 + ii]; 
14E8:  CLRF   03
14EA:  MOVF   42,W
14EC:  ADDLW  84
14EE:  MOVWF  01
14F0:  MOVLW  01
14F2:  ADDWFC 03,F
14F4:  MOVFF  01,18A
14F8:  MOVLB  1
14FA:  MOVFF  03,18B
14FE:  MOVLW  18
1500:  ADDWF  42,W
1502:  CLRF   03
1504:  ADDLW  52
1506:  MOVWF  FE9
1508:  MOVLW  01
150A:  ADDWFC 03,W
150C:  MOVWF  FEA
150E:  MOVFF  FEF,18C
1512:  MOVFF  18B,FEA
1516:  MOVFF  01,FE9
151A:  MOVFF  18C,FEF
151E:  INCF   42,F
1520:  MOVLB  0
1522:  BRA    14E2
1524:  GOTO   2FB0 (RETURN)
....................    //!   lcd_gotoxy(15,3);// 
....................    //!   printf(lcd_putc,"A:%c%c%c%c",tempo_tc[0],tempo_tc[1],tempo_tc[2],tempo_tc[3]); 
.................... } 
....................  
.................... void envio() 
.................... { // crea paquete para enviar al modulo GPRS 
....................    ////////////// Detectando envio total 
....................    if (convertir_to_entero(tempo_tc[0]) > 0) 
*
189C:  MOVLB  1
189E:  CLRF   x8B
18A0:  MOVFF  184,18A
18A4:  MOVLB  0
18A6:  RCALL  17F4
18A8:  MOVF   01,F
18AA:  BZ    18CC
....................       for (i = 0; i < convertir_to_entero(tempo_tc[0]); i++) 
18AC:  CLRF   41
18AE:  MOVLB  1
18B0:  CLRF   x8B
18B2:  MOVFF  184,18A
18B6:  MOVLB  0
18B8:  RCALL  17F4
18BA:  MOVF   01,W
18BC:  SUBWF  41,W
18BE:  BC    18CC
....................          tempo_tn = tempo_tn + 1000; 
18C0:  MOVLW  E8
18C2:  ADDWF  32,F
18C4:  MOVLW  03
18C6:  ADDWFC 33,F
18C8:  INCF   41,F
18CA:  BRA    18AE
....................    if (convertir_to_entero(tempo_tc[1]) > 0) 
18CC:  MOVLB  1
18CE:  CLRF   x8B
18D0:  MOVFF  185,18A
18D4:  MOVLB  0
18D6:  RCALL  17F4
18D8:  MOVF   01,F
18DA:  BZ    18FC
....................       for (i = 0; i < convertir_to_entero(tempo_tc[1]); i++) 
18DC:  CLRF   41
18DE:  MOVLB  1
18E0:  CLRF   x8B
18E2:  MOVFF  185,18A
18E6:  MOVLB  0
18E8:  RCALL  17F4
18EA:  MOVF   01,W
18EC:  SUBWF  41,W
18EE:  BC    18FC
....................          tempo_tn = tempo_tn + 100; 
18F0:  MOVLW  64
18F2:  ADDWF  32,F
18F4:  MOVLW  00
18F6:  ADDWFC 33,F
18F8:  INCF   41,F
18FA:  BRA    18DE
....................    if (convertir_to_entero(tempo_tc[2]) > 0) 
18FC:  MOVLB  1
18FE:  CLRF   x8B
1900:  MOVFF  186,18A
1904:  MOVLB  0
1906:  RCALL  17F4
1908:  MOVF   01,F
190A:  BZ    192C
....................       for (i = 0; i < convertir_to_entero(tempo_tc[2]); i++) 
190C:  CLRF   41
190E:  MOVLB  1
1910:  CLRF   x8B
1912:  MOVFF  186,18A
1916:  MOVLB  0
1918:  RCALL  17F4
191A:  MOVF   01,W
191C:  SUBWF  41,W
191E:  BC    192C
....................          tempo_tn = tempo_tn + 10; 
1920:  MOVLW  0A
1922:  ADDWF  32,F
1924:  MOVLW  00
1926:  ADDWFC 33,F
1928:  INCF   41,F
192A:  BRA    190E
....................    tempo_tn = tempo_tn + convertir_to_entero(tempo_tc[3]); 
192C:  MOVLB  1
192E:  CLRF   x8B
1930:  MOVFF  187,18A
1934:  MOVLB  0
1936:  RCALL  17F4
1938:  MOVF   01,W
193A:  ADDWF  32,F
193C:  MOVLW  00
193E:  ADDWFC 33,F
....................    //////////////////////////////////////////////////// 
....................    if (convertir_to_entero(entran[0]) > 0) 
1940:  MOVLB  1
1942:  CLRF   x8B
1944:  MOVFF  16F,18A
1948:  MOVLB  0
194A:  RCALL  17F4
194C:  MOVF   01,F
194E:  BZ    1970
....................       for (i = 0; i < convertir_to_entero(entran[0]); i++) 
1950:  CLRF   41
1952:  MOVLB  1
1954:  CLRF   x8B
1956:  MOVFF  16F,18A
195A:  MOVLB  0
195C:  RCALL  17F4
195E:  MOVF   01,W
1960:  SUBWF  41,W
1962:  BC    1970
....................          temporal1 = temporal1 + 1000; 
1964:  MOVLW  E8
1966:  ADDWF  2E,F
1968:  MOVLW  03
196A:  ADDWFC 2F,F
196C:  INCF   41,F
196E:  BRA    1952
....................    if (convertir_to_entero(entran[1]) > 0) 
1970:  MOVLB  1
1972:  CLRF   x8B
1974:  MOVFF  170,18A
1978:  MOVLB  0
197A:  RCALL  17F4
197C:  MOVF   01,F
197E:  BZ    19A0
....................       for (i = 0; i < convertir_to_entero(entran[1]); i++) 
1980:  CLRF   41
1982:  MOVLB  1
1984:  CLRF   x8B
1986:  MOVFF  170,18A
198A:  MOVLB  0
198C:  RCALL  17F4
198E:  MOVF   01,W
1990:  SUBWF  41,W
1992:  BC    19A0
....................          temporal1 = temporal1 + 100; 
1994:  MOVLW  64
1996:  ADDWF  2E,F
1998:  MOVLW  00
199A:  ADDWFC 2F,F
199C:  INCF   41,F
199E:  BRA    1982
....................    if (convertir_to_entero(entran[2]) > 0) 
19A0:  MOVLB  1
19A2:  CLRF   x8B
19A4:  MOVFF  171,18A
19A8:  MOVLB  0
19AA:  RCALL  17F4
19AC:  MOVF   01,F
19AE:  BZ    19D0
....................       for (i = 0; i < convertir_to_entero(entran[2]); i++) 
19B0:  CLRF   41
19B2:  MOVLB  1
19B4:  CLRF   x8B
19B6:  MOVFF  171,18A
19BA:  MOVLB  0
19BC:  RCALL  17F4
19BE:  MOVF   01,W
19C0:  SUBWF  41,W
19C2:  BC    19D0
....................          temporal1 = temporal1 + 10; 
19C4:  MOVLW  0A
19C6:  ADDWF  2E,F
19C8:  MOVLW  00
19CA:  ADDWFC 2F,F
19CC:  INCF   41,F
19CE:  BRA    19B2
....................    sub_atras = temporal1 = temporal1 + convertir_to_entero(entran[3]); 
19D0:  MOVLB  1
19D2:  CLRF   x8B
19D4:  MOVFF  172,18A
19D8:  MOVLB  0
19DA:  RCALL  17F4
19DC:  MOVF   01,W
19DE:  ADDWF  2E,F
19E0:  MOVLW  00
19E2:  ADDWFC 2F,F
19E4:  MOVFF  2F,35
19E8:  MOVFF  2E,34
....................  
....................    if (convertir_to_entero(salen[0]) > 0) 
19EC:  MOVLB  1
19EE:  CLRF   x8B
19F0:  MOVFF  173,18A
19F4:  MOVLB  0
19F6:  RCALL  17F4
19F8:  MOVF   01,F
19FA:  BZ    1A1C
....................       for (i = 0; i < convertir_to_entero(salen[0]); i++) 
19FC:  CLRF   41
19FE:  MOVLB  1
1A00:  CLRF   x8B
1A02:  MOVFF  173,18A
1A06:  MOVLB  0
1A08:  RCALL  17F4
1A0A:  MOVF   01,W
1A0C:  SUBWF  41,W
1A0E:  BC    1A1C
....................          temporal2 = temporal2 + 1000; 
1A10:  MOVLW  E8
1A12:  ADDWF  30,F
1A14:  MOVLW  03
1A16:  ADDWFC 31,F
1A18:  INCF   41,F
1A1A:  BRA    19FE
....................    if (convertir_to_entero(salen[1]) > 0) 
1A1C:  MOVLB  1
1A1E:  CLRF   x8B
1A20:  MOVFF  174,18A
1A24:  MOVLB  0
1A26:  RCALL  17F4
1A28:  MOVF   01,F
1A2A:  BZ    1A4C
....................       for (i = 0; i < convertir_to_entero(salen[1]); i++) 
1A2C:  CLRF   41
1A2E:  MOVLB  1
1A30:  CLRF   x8B
1A32:  MOVFF  174,18A
1A36:  MOVLB  0
1A38:  RCALL  17F4
1A3A:  MOVF   01,W
1A3C:  SUBWF  41,W
1A3E:  BC    1A4C
....................          temporal2 = temporal2 + 100; 
1A40:  MOVLW  64
1A42:  ADDWF  30,F
1A44:  MOVLW  00
1A46:  ADDWFC 31,F
1A48:  INCF   41,F
1A4A:  BRA    1A2E
....................    if (convertir_to_entero(salen[2]) > 0) 
1A4C:  MOVLB  1
1A4E:  CLRF   x8B
1A50:  MOVFF  175,18A
1A54:  MOVLB  0
1A56:  RCALL  17F4
1A58:  MOVF   01,F
1A5A:  BZ    1A7C
....................       for (i = 0; i < convertir_to_entero(salen[2]); i++) 
1A5C:  CLRF   41
1A5E:  MOVLB  1
1A60:  CLRF   x8B
1A62:  MOVFF  175,18A
1A66:  MOVLB  0
1A68:  RCALL  17F4
1A6A:  MOVF   01,W
1A6C:  SUBWF  41,W
1A6E:  BC    1A7C
....................          temporal2 = temporal2 + 10; 
1A70:  MOVLW  0A
1A72:  ADDWF  30,F
1A74:  MOVLW  00
1A76:  ADDWFC 31,F
1A78:  INCF   41,F
1A7A:  BRA    1A5E
....................    baj_atras = temporal2 = temporal2 + convertir_to_entero(salen[3]); 
1A7C:  MOVLB  1
1A7E:  CLRF   x8B
1A80:  MOVFF  176,18A
1A84:  MOVLB  0
1A86:  RCALL  17F4
1A88:  MOVF   01,W
1A8A:  ADDWF  30,F
1A8C:  MOVLW  00
1A8E:  ADDWFC 31,F
1A90:  MOVFF  31,37
1A94:  MOVFF  30,36
....................  
....................    if (convertir_to_entero(bloqueado[0]) > 0) 
1A98:  MOVLB  1
1A9A:  CLRF   x8B
1A9C:  MOVFF  177,18A
1AA0:  MOVLB  0
1AA2:  RCALL  17F4
1AA4:  MOVF   01,F
1AA6:  BZ    1AC8
....................       for (i = 0; i < convertir_to_entero(bloqueado[0]); i++) 
1AA8:  CLRF   41
1AAA:  MOVLB  1
1AAC:  CLRF   x8B
1AAE:  MOVFF  177,18A
1AB2:  MOVLB  0
1AB4:  RCALL  17F4
1AB6:  MOVF   01,W
1AB8:  SUBWF  41,W
1ABA:  BC    1AC8
....................          temporal3 = temporal3 + 100; 
1ABC:  MOVLW  64
1ABE:  ADDWF  x96,F
1AC0:  MOVLW  00
1AC2:  ADDWFC x97,F
1AC4:  INCF   41,F
1AC6:  BRA    1AAA
....................    if (convertir_to_entero(bloqueado[1]) > 0) 
1AC8:  MOVLB  1
1ACA:  CLRF   x8B
1ACC:  MOVFF  178,18A
1AD0:  MOVLB  0
1AD2:  RCALL  17F4
1AD4:  MOVF   01,F
1AD6:  BZ    1AF8
....................       for (i = 0; i < convertir_to_entero(bloqueado[1]); i++) 
1AD8:  CLRF   41
1ADA:  MOVLB  1
1ADC:  CLRF   x8B
1ADE:  MOVFF  178,18A
1AE2:  MOVLB  0
1AE4:  RCALL  17F4
1AE6:  MOVF   01,W
1AE8:  SUBWF  41,W
1AEA:  BC    1AF8
....................          temporal3 = temporal3 + 10; 
1AEC:  MOVLW  0A
1AEE:  ADDWF  x96,F
1AF0:  MOVLW  00
1AF2:  ADDWFC x97,F
1AF4:  INCF   41,F
1AF6:  BRA    1ADA
....................    temporal3 = temporal3 + convertir_to_entero(bloqueado[2]); 
1AF8:  MOVLB  1
1AFA:  CLRF   x8B
1AFC:  MOVFF  179,18A
1B00:  MOVLB  0
1B02:  RCALL  17F4
1B04:  MOVF   01,W
1B06:  ADDWF  x96,F
1B08:  MOVLW  00
1B0A:  ADDWFC x97,F
....................  
....................    entran1 = (entraront + salieront) / 2; 
1B0C:  MOVF   x8C,W
1B0E:  ADDWF  x8A,W
1B10:  MOVLB  1
1B12:  MOVWF  x8A
1B14:  MOVLB  0
1B16:  MOVF   x8D,W
1B18:  ADDWFC x8B,W
1B1A:  MOVLB  1
1B1C:  MOVWF  x8B
1B1E:  BCF    FD8.0
1B20:  RRCF   x8B,W
1B22:  MOVWF  39
1B24:  RRCF   x8A,W
1B26:  MOVWF  38
....................  
....................    total2_t = (temporal1 + temporal2) / 2; 
1B28:  MOVF   30,W
1B2A:  ADDWF  2E,W
1B2C:  MOVWF  x8A
1B2E:  MOVF   31,W
1B30:  ADDWFC 2F,W
1B32:  MOVWF  x8B
1B34:  BCF    FD8.0
1B36:  RRCF   x8B,W
1B38:  MOVWF  51
1B3A:  RRCF   x8A,W
1B3C:  MOVWF  50
....................    leer_conta2(); 
1B3E:  MOVLB  0
1B40:  CALL   07D0
....................    if (total2_t == tempo_tn) 
1B44:  MOVF   32,W
1B46:  SUBWF  50,W
1B48:  BNZ   1B68
1B4A:  MOVF   33,W
1B4C:  SUBWF  51,W
1B4E:  BNZ   1B68
....................    { // dato recibido correcto 
....................       salian = salen1 = total2_t; 
1B50:  MOVFF  51,3B
1B54:  MOVFF  50,3A
1B58:  MOVFF  3B,3D
1B5C:  MOVFF  3A,3C
....................       graba_conta2(); 
1B60:  CALL   066E
....................       error = 0; 
1B64:  CLRF   23
....................    } 
1B66:  BRA    1B6C
....................    else 
....................       error = 2; 
1B68:  MOVLW  02
1B6A:  MOVWF  23
....................    ///////////// 
....................    pasajet = entran1 + salen1; 
1B6C:  MOVF   3A,W
1B6E:  ADDWF  38,W
1B70:  MOVWF  x90
1B72:  MOVF   3B,W
1B74:  ADDWFC 39,W
1B76:  MOVWF  x91
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
1B78:  MOVF   53,W
1B7A:  ADDWF  52,W
1B7C:  ADDWF  54,W
1B7E:  MOVWF  4C
1B80:  CLRF   4D
....................    // fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,temporal1,temporal2,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS, "ACC+01:%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n", pasajet, entran1, salen1, cta_bloqueo, temporal3, error); 
1B82:  MOVLW  EE
1B84:  MOVWF  FF6
1B86:  MOVLW  02
1B88:  MOVWF  FF7
1B8A:  MOVLW  07
1B8C:  MOVLB  1
1B8E:  MOVWF  x8A
1B90:  MOVLB  0
1B92:  RCALL  153E
1B94:  MOVLW  09
1B96:  MOVWF  FE9
1B98:  MOVFF  91,18B
1B9C:  MOVFF  90,18A
1BA0:  RCALL  1566
1BA2:  MOVLW  2C
1BA4:  MOVLB  1
1BA6:  MOVWF  x93
1BA8:  MOVLB  0
1BAA:  CALL   1096
1BAE:  MOVLW  09
1BB0:  MOVWF  FE9
1BB2:  MOVFF  39,18B
1BB6:  MOVFF  38,18A
1BBA:  RCALL  1566
1BBC:  MOVLW  2C
1BBE:  MOVLB  1
1BC0:  MOVWF  x93
1BC2:  MOVLB  0
1BC4:  CALL   1096
1BC8:  MOVLW  09
1BCA:  MOVWF  FE9
1BCC:  MOVFF  3B,18B
1BD0:  MOVFF  3A,18A
1BD4:  RCALL  1566
1BD6:  MOVLW  2C
1BD8:  MOVLB  1
1BDA:  MOVWF  x93
1BDC:  MOVLB  0
1BDE:  CALL   1096
1BE2:  MOVLW  0A
1BE4:  MOVWF  FE9
1BE6:  MOVFF  4D,18B
1BEA:  MOVFF  4C,18A
1BEE:  RCALL  1566
1BF0:  MOVLW  2C
1BF2:  MOVLB  1
1BF4:  MOVWF  x93
1BF6:  MOVLB  0
1BF8:  CALL   1096
1BFC:  MOVLW  0A
1BFE:  MOVWF  FE9
1C00:  MOVFF  97,18B
1C04:  MOVFF  96,18A
1C08:  RCALL  1566
1C0A:  MOVLW  2C
1C0C:  MOVLB  1
1C0E:  MOVWF  x93
1C10:  MOVLB  0
1C12:  CALL   1096
1C16:  MOVFF  23,18A
1C1A:  MOVLW  01
1C1C:  MOVLB  1
1C1E:  MOVWF  x8B
1C20:  MOVLB  0
1C22:  RCALL  162A
1C24:  MOVLW  17
1C26:  MOVWF  FF6
1C28:  MOVLW  03
1C2A:  MOVWF  FF7
1C2C:  MOVLW  03
1C2E:  MOVLB  1
1C30:  MOVWF  x8A
1C32:  MOVLB  0
1C34:  RCALL  153E
....................    lcd_cuentas(); 
1C36:  CALL   0A18
....................    /////////////////////////// 
....................    //!   lcd_gotoxy(8,4); 
....................    //!   printf(lcd_putc,"M:%Ld E:%Ld T:%Ld ",entran1,salen1,pasajet); 
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
1C3A:  MOVLW  09
1C3C:  MOVLB  1
1C3E:  MOVWF  x94
1C40:  MOVLW  03
1C42:  MOVWF  x95
1C44:  MOVLB  0
1C46:  CALL   0822
....................    lcd_putc(0xAB); 
1C4A:  MOVLW  AB
1C4C:  MOVLB  1
1C4E:  MOVWF  x93
1C50:  MOVLB  0
1C52:  CALL   0874
....................    // lcd_gotoxy(9,4);//cronometro para limpiar 
....................    // lcd_putc("    "); 
....................    clear_lcd1 = 1; 
1C56:  MOVLW  01
1C58:  MOVWF  xAB
....................    time_lcd1 = 0; 
1C5A:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio = 0; // reinicia el tiempo para el siguiente envio 
1C5C:  CLRF   xAA
1C5E:  CLRF   xA9
....................    transmitir = 0; 
1C60:  CLRF   24
....................    enable_interrupts(INT_RDA); 
1C62:  BSF    F9D.5
1C64:  GOTO   311A (RETURN)
.................... } 
....................  
.................... void envia2() 
.................... { // Crea paquete para enviar a modulo GPRS cuando no hay conexion con esclavo 
....................    disable_interrupts(INT_RDA); 
*
16A6:  BCF    F9D.5
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
16A8:  MOVF   53,W
16AA:  ADDWF  52,W
16AC:  ADDWF  54,W
16AE:  MOVWF  4C
16B0:  CLRF   4D
....................    memset(entran, 0, sizeof(entran));       // entran=0; 
16B2:  MOVLW  01
16B4:  MOVWF  FEA
16B6:  MOVLW  6F
16B8:  MOVWF  FE9
16BA:  CLRF   00
16BC:  CLRF   02
16BE:  MOVLW  04
16C0:  MOVWF  01
16C2:  RCALL  138E
....................    memset(salen, 0, sizeof(salen));         // salen=0; 
16C4:  MOVLW  01
16C6:  MOVWF  FEA
16C8:  MOVLW  73
16CA:  MOVWF  FE9
16CC:  CLRF   00
16CE:  CLRF   02
16D0:  MOVLW  04
16D2:  MOVWF  01
16D4:  RCALL  138E
....................    memset(bloqueado, 0, sizeof(bloqueado)); // bloqueado=0; 
16D6:  MOVLW  01
16D8:  MOVWF  FEA
16DA:  MOVLW  77
16DC:  MOVWF  FE9
16DE:  CLRF   00
16E0:  CLRF   02
16E2:  MOVLW  03
16E4:  MOVWF  01
16E6:  RCALL  138E
....................    i = 10; 
16E8:  MOVLW  0A
16EA:  MOVWF  41
....................    ii = 0; 
16EC:  CLRF   42
....................    entran1 = (entraront + salieront) / 2; 
16EE:  MOVF   x8C,W
16F0:  ADDWF  x8A,W
16F2:  MOVLB  1
16F4:  MOVWF  x8A
16F6:  MOVLB  0
16F8:  MOVF   x8D,W
16FA:  ADDWFC x8B,W
16FC:  MOVLB  1
16FE:  MOVWF  x8B
1700:  BCF    FD8.0
1702:  RRCF   x8B,W
1704:  MOVWF  39
1706:  RRCF   x8A,W
1708:  MOVWF  38
....................    leer_conta2(); 
170A:  MOVLB  0
170C:  CALL   07D0
....................    pasajet = entran1 + salian; 
1710:  MOVF   3C,W
1712:  ADDWF  38,W
1714:  MOVWF  x90
1716:  MOVF   3D,W
1718:  ADDWFC 39,W
171A:  MOVWF  x91
....................    error = 1; 
171C:  MOVLW  01
171E:  MOVWF  23
....................    // fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,DESC,DESC,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS, "ACC+01:%04Lu,%04Lu,DESC,%03Lu,000,%02u,\r\n", pasajet, entran1, cta_bloqueo, error); 
1720:  MOVLW  1C
1722:  MOVWF  FF6
1724:  MOVLW  03
1726:  MOVWF  FF7
1728:  MOVLW  07
172A:  MOVLB  1
172C:  MOVWF  x8A
172E:  MOVLB  0
1730:  RCALL  153E
1732:  MOVLW  09
1734:  MOVWF  FE9
1736:  MOVFF  91,18B
173A:  MOVFF  90,18A
173E:  RCALL  1566
1740:  MOVLW  2C
1742:  MOVLB  1
1744:  MOVWF  x93
1746:  MOVLB  0
1748:  RCALL  1096
174A:  MOVLW  09
174C:  MOVWF  FE9
174E:  MOVFF  39,18B
1752:  MOVFF  38,18A
1756:  RCALL  1566
1758:  MOVLW  2E
175A:  MOVWF  FF6
175C:  MOVLW  03
175E:  MOVWF  FF7
1760:  MOVLW  06
1762:  MOVLB  1
1764:  MOVWF  x8A
1766:  MOVLB  0
1768:  RCALL  153E
176A:  MOVLW  0A
176C:  MOVWF  FE9
176E:  MOVFF  4D,18B
1772:  MOVFF  4C,18A
1776:  RCALL  1566
1778:  MOVLW  39
177A:  MOVWF  FF6
177C:  MOVLW  03
177E:  MOVWF  FF7
1780:  MOVLW  05
1782:  MOVLB  1
1784:  MOVWF  x8A
1786:  MOVLB  0
1788:  RCALL  153E
178A:  MOVFF  23,18A
178E:  MOVLW  01
1790:  MOVLB  1
1792:  MOVWF  x8B
1794:  MOVLB  0
1796:  RCALL  162A
1798:  MOVLW  42
179A:  MOVWF  FF6
179C:  MOVLW  03
179E:  MOVWF  FF7
17A0:  MOVLW  03
17A2:  MOVLB  1
17A4:  MOVWF  x8A
17A6:  MOVLB  0
17A8:  RCALL  153E
....................    //!   lcd_gotoxy(1,4); 
....................    //!   printf(lcd_putc,"T:%04Lu BS:%03Lu ",pasajet,cta_bloqueo); 
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
17AA:  MOVLW  09
17AC:  MOVLB  1
17AE:  MOVWF  x94
17B0:  MOVLW  03
17B2:  MOVWF  x95
17B4:  MOVLB  0
17B6:  CALL   0822
....................    lcd_putc(0xAB); 
17BA:  MOVLW  AB
17BC:  MOVLB  1
17BE:  MOVWF  x93
17C0:  MOVLB  0
17C2:  CALL   0874
....................    lcd_gotoxy(9, 4); // cronometro para limpiar 
17C6:  MOVLW  09
17C8:  MOVLB  1
17CA:  MOVWF  x94
17CC:  MOVLW  04
17CE:  MOVWF  x95
17D0:  MOVLB  0
17D2:  CALL   0822
....................    lcd_putc("DESC"); 
17D6:  MOVLW  46
17D8:  MOVWF  FF6
17DA:  MOVLW  03
17DC:  MOVWF  FF7
17DE:  CALL   09F8
....................    clear_lcd1 = 1; 
17E2:  MOVLW  01
17E4:  MOVWF  xAB
....................    time_lcd1 = 0; 
17E6:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio = 0; // reinicia el tiempo para el siguiente envio 
17E8:  CLRF   xAA
17EA:  CLRF   xA9
....................    flag_enviar = 0; 
17EC:  CLRF   46
....................    enable_interrupts(INT_RDA); 
17EE:  BSF    F9D.5
17F0:  GOTO   3112 (RETURN)
.................... } 
....................  
.................... void limpiar() 
.................... { // borra cuentas de subidas, bajadas y bloqueos 
....................    tem_entraront = 0; 
*
0CD0:  CLRF   x93
0CD2:  CLRF   x92
....................    tem_salieront = 0; 
0CD4:  CLRF   x95
0CD6:  CLRF   x94
....................    salian = 0; 
0CD8:  CLRF   3D
0CDA:  CLRF   3C
....................    graba_conta2(); 
0CDC:  RCALL  066E
....................    leer_conta2(); 
0CDE:  RCALL  07D0
....................    pasaje = 0; 
0CE0:  CLRF   x8F
0CE2:  CLRF   x8E
....................    pasajet = 0; 
0CE4:  CLRF   x91
0CE6:  CLRF   x90
....................    salieront = 0; 
0CE8:  CLRF   x8D
0CEA:  CLRF   x8C
....................    entraront = 0; 
0CEC:  CLRF   x8B
0CEE:  CLRF   x8A
....................    write_ent(); 
0CF0:  RCALL  0C64
....................    write_sal(); 
0CF2:  RCALL  0C9A
....................    cta_bloqueo = 0; 
0CF4:  CLRF   4D
0CF6:  CLRF   4C
....................    cta_bloq1 = 0; 
0CF8:  CLRF   52
....................    cta_bloq2 = 0; 
0CFA:  CLRF   53
....................    cta_bloq3 = 0; 
0CFC:  CLRF   54
....................    write_ext_eeprom(9, cta_bloq1);  // bloq1 
0CFE:  MOVLB  1
0D00:  CLRF   x8F
0D02:  MOVLW  09
0D04:  MOVWF  x8E
0D06:  MOVFF  52,190
0D0A:  MOVLB  0
0D0C:  RCALL  0568
....................    write_ext_eeprom(10, cta_bloq2); // bloq2 
0D0E:  MOVLB  1
0D10:  CLRF   x8F
0D12:  MOVLW  0A
0D14:  MOVWF  x8E
0D16:  MOVFF  53,190
0D1A:  MOVLB  0
0D1C:  RCALL  0568
....................    write_ext_eeprom(11, cta_bloq3); // bloq3 
0D1E:  MOVLB  1
0D20:  CLRF   x8F
0D22:  MOVLW  0B
0D24:  MOVWF  x8E
0D26:  MOVFF  54,190
0D2A:  MOVLB  0
0D2C:  RCALL  0568
....................    lcd_putc("\f"); 
0D2E:  MOVLW  4C
0D30:  MOVWF  FF6
0D32:  MOVLW  03
0D34:  MOVWF  FF7
0D36:  RCALL  09F8
....................    lcd_cuentas(); 
0D38:  RCALL  0A18
0D3A:  RETURN 0
.................... } 
....................  
.................... void detecta_suma() 
.................... { // Realiza suma de entradas o salidas 
....................    if ((!detec1) && (!detec2) && (!detec3) && (!detec4) && (!detec5) && (!detec6)) 
*
1F38:  MOVF   x69,F
1F3A:  BNZ   1FAA
1F3C:  MOVF   x6A,F
1F3E:  BNZ   1FAA
1F40:  MOVF   x6B,F
1F42:  BNZ   1FAA
1F44:  MOVF   x6C,F
1F46:  BNZ   1FAA
1F48:  MOVF   x6D,F
1F4A:  BNZ   1FAA
1F4C:  MOVF   x6E,F
1F4E:  BNZ   1FAA
....................    { // suma sin bloqueos 
....................       sumae1 = fse1 + fse2 + fse3; 
1F50:  MOVF   29,W
1F52:  ADDWF  28,W
1F54:  ADDWF  2A,W
1F56:  MOVWF  25
....................       sumas1 = fss1 + fss2 + fss3; 
1F58:  MOVF   2C,W
1F5A:  ADDWF  2B,W
1F5C:  ADDWF  2D,W
1F5E:  MOVWF  26
....................       //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
....................       //!      printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................       if ((sumae1 >= 2) || (sumas1 >= 2)) 
1F60:  MOVF   25,W
1F62:  SUBLW  01
1F64:  BNC   1F6C
1F66:  MOVF   26,W
1F68:  SUBLW  01
1F6A:  BC    1F8C
....................       { 
....................          if (sumae1 > sumas1) 
1F6C:  MOVF   25,W
1F6E:  SUBWF  26,W
1F70:  BC    1F82
....................          { 
....................             entraront++; 
1F72:  INCF   x8A,F
1F74:  BTFSC  FD8.2
1F76:  INCF   x8B,F
....................             write_ent(); 
1F78:  CALL   0C64
....................             /////enciende relay//// 
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
1F7C:  CALL   152E
....................             //////// 
....................          } 
1F80:  BRA    1F8C
....................          else 
....................          { 
....................             salieront++; 
1F82:  INCF   x8C,F
1F84:  BTFSC  FD8.2
1F86:  INCF   x8D,F
....................             write_sal(); 
1F88:  CALL   0C9A
....................          } 
....................       } 
....................       sumae1 = fse1 = fse2 = fse3 = 0; 
1F8C:  CLRF   2A
1F8E:  MOVFF  2A,29
1F92:  MOVFF  29,28
1F96:  MOVFF  28,25
....................       sumas1 = fss1 = fss2 = fss3 = 0; 
1F9A:  CLRF   2D
1F9C:  MOVFF  2D,2C
1FA0:  MOVFF  2C,2B
1FA4:  MOVFF  2B,26
....................       // envio_PC(); 
....................    } // fin suma sin bloqueos 
1FA8:  BRA    20B8
....................    else if ((en_b1) || (en_b2) || (en_b3)) 
1FAA:  MOVF   x9E,F
1FAC:  BNZ   1FB8
1FAE:  MOVF   x9F,F
1FB0:  BNZ   1FB8
1FB2:  MOVF   xA0,F
1FB4:  BTFSC  FD8.2
1FB6:  BRA    20B8
....................    { // contar con bloqueos 
....................       lim_b = en_b1 + en_b2 + en_b3; 
1FB8:  MOVF   x9F,W
1FBA:  ADDWF  x9E,W
1FBC:  ADDWF  xA0,W
1FBE:  MOVWF  27
....................       if (lim_b == 1) 
1FC0:  DECFSZ 27,W
1FC2:  BRA    2060
....................       { // un solo bloqueo 
....................          if (en_b1) 
1FC4:  MOVF   x9E,F
1FC6:  BZ    1FF8
....................          { 
....................             if ((!detec3) && (!detec4) && (!detec5) && (!detec6)) 
1FC8:  MOVF   x6B,F
1FCA:  BNZ   1FF6
1FCC:  MOVF   x6C,F
1FCE:  BNZ   1FF6
1FD0:  MOVF   x6D,F
1FD2:  BNZ   1FF6
1FD4:  MOVF   x6E,F
1FD6:  BNZ   1FF6
....................             { 
....................                if (sen_ent == 1) 
1FD8:  DECFSZ 5B,W
1FDA:  BRA    1FEC
....................                { 
....................                   entraront++; 
1FDC:  INCF   x8A,F
1FDE:  BTFSC  FD8.2
1FE0:  INCF   x8B,F
....................                   write_ent(); 
1FE2:  CALL   0C64
....................                   /////enciende relay//// 
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
1FE6:  CALL   152E
....................             //////// 
....................                } 
1FEA:  BRA    1FF6
....................                else 
....................                { 
....................                   salieront++; 
1FEC:  INCF   x8C,F
1FEE:  BTFSC  FD8.2
1FF0:  INCF   x8D,F
....................                   write_sal(); 
1FF2:  CALL   0C9A
....................                } 
....................             } // fin sensores 0 
....................          }    // fin bloqueo par 1 
1FF6:  BRA    205E
....................          else if (en_b2) 
1FF8:  MOVF   x9F,F
1FFA:  BZ    202C
....................          { // bloqueo en par 2 
....................             if ((!detec1) && (!detec2) && (!detec5) && (!detec6)) 
1FFC:  MOVF   x69,F
1FFE:  BNZ   202A
2000:  MOVF   x6A,F
2002:  BNZ   202A
2004:  MOVF   x6D,F
2006:  BNZ   202A
2008:  MOVF   x6E,F
200A:  BNZ   202A
....................             { 
....................                if (sen_ent) 
200C:  MOVF   5B,F
200E:  BZ    2020
....................                { 
....................                   entraront++; 
2010:  INCF   x8A,F
2012:  BTFSC  FD8.2
2014:  INCF   x8B,F
....................                   write_ent(); 
2016:  CALL   0C64
....................                   /////enciende relay//// 
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
201A:  CALL   152E
....................             //////// 
....................                } 
201E:  BRA    202A
....................                else 
....................                { 
....................                   salieront++; 
2020:  INCF   x8C,F
2022:  BTFSC  FD8.2
2024:  INCF   x8D,F
....................                   write_sal(); 
2026:  CALL   0C9A
....................                } 
....................             } // fin sensores 0 
....................          }    // fin par 2 
202A:  BRA    205E
....................          else if (en_b3) 
202C:  MOVF   xA0,F
202E:  BZ    205E
....................          { // bloqueao en par 3 
....................             if ((!detec3) && (!detec4) && (!detec1) && (!detec2)) 
2030:  MOVF   x6B,F
2032:  BNZ   205E
2034:  MOVF   x6C,F
2036:  BNZ   205E
2038:  MOVF   x69,F
203A:  BNZ   205E
203C:  MOVF   x6A,F
203E:  BNZ   205E
....................             { 
....................                if (sen_ent) 
2040:  MOVF   5B,F
2042:  BZ    2054
....................                { 
....................                   entraront++; 
2044:  INCF   x8A,F
2046:  BTFSC  FD8.2
2048:  INCF   x8B,F
....................                   write_ent(); 
204A:  CALL   0C64
....................                   /////enciende relay//// 
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
204E:  CALL   152E
....................             //////// 
....................                } 
2052:  BRA    205E
....................                else 
....................                { 
....................                   salieront++; 
2054:  INCF   x8C,F
2056:  BTFSC  FD8.2
2058:  INCF   x8D,F
....................                   write_sal(); 
205A:  CALL   0C9A
....................                } 
....................             } 
....................          } // fin par 3 
....................       }    // fin un solo bloqueo 
205E:  BRA    209C
....................       //----------------------------------------------------------------------------- 
....................       else 
....................       { // mas de un bloqueo 
....................          sumae1 = fse1 + fse2 + fse3; 
2060:  MOVF   29,W
2062:  ADDWF  28,W
2064:  ADDWF  2A,W
2066:  MOVWF  25
....................          sumas1 = fss1 + fss2 + fss3; 
2068:  MOVF   2C,W
206A:  ADDWF  2B,W
206C:  ADDWF  2D,W
206E:  MOVWF  26
....................          // lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
....................          // printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................          if ((sumae1 >= 1) || (sumas1 >= 1)) 
2070:  MOVF   25,W
2072:  SUBLW  00
2074:  BNC   207C
2076:  MOVF   26,W
2078:  SUBLW  00
207A:  BC    209C
....................          { 
....................             if (sumae1 > sumas1) 
207C:  MOVF   25,W
207E:  SUBWF  26,W
2080:  BC    2092
....................             { 
....................                entraront++; 
2082:  INCF   x8A,F
2084:  BTFSC  FD8.2
2086:  INCF   x8B,F
....................                write_ent(); 
2088:  CALL   0C64
....................                /////enciende relay//// 
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
208C:  CALL   152E
....................             //////// 
....................             } 
2090:  BRA    209C
....................             else 
....................             { 
....................                salieront++; 
2092:  INCF   x8C,F
2094:  BTFSC  FD8.2
2096:  INCF   x8D,F
....................                write_sal(); 
2098:  CALL   0C9A
....................             } 
....................          } 
....................       } // fin mas de un bloqueo 
....................       sumae1 = fse1 = fse2 = fse3 = 0; 
209C:  CLRF   2A
209E:  MOVFF  2A,29
20A2:  MOVFF  29,28
20A6:  MOVFF  28,25
....................       sumas1 = fss1 = fss2 = fss3 = 0; 
20AA:  CLRF   2D
20AC:  MOVFF  2D,2C
20B0:  MOVFF  2C,2B
20B4:  MOVFF  2B,26
....................       //----------------------------------------------------------------------------- 
....................    } // end bloqueos 
20B8:  RETURN 0
.................... } 
....................  
.................... void finsuma() 
.................... { // Pinta en LCD la nueva cifra de entrada o salida 
....................    //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
....................    //!      printf(lcd_putc,"se:%u ss:%u ",sen_ent,sen_sal);//habilitar unicamente para hacer diagnosticos 
....................    pasaje = (entraront + salieront) / 2; 
*
0C26:  MOVF   x8C,W
0C28:  ADDWF  x8A,W
0C2A:  MOVLB  1
0C2C:  MOVWF  x8A
0C2E:  MOVLB  0
0C30:  MOVF   x8D,W
0C32:  ADDWFC x8B,W
0C34:  MOVLB  1
0C36:  MOVWF  x8B
0C38:  BCF    FD8.0
0C3A:  RRCF   x8B,W
0C3C:  MOVLB  0
0C3E:  MOVWF  x8F
0C40:  MOVLB  1
0C42:  RRCF   x8A,W
0C44:  MOVLB  0
0C46:  MOVWF  x8E
....................    lcd_cuentas(); 
0C48:  RCALL  0A18
....................    sen_ent = 0; 
0C4A:  CLRF   5B
....................    sen_sal = 0; 
0C4C:  CLRF   5C
....................    fse1 = fse2 = fse3 = 0; 
0C4E:  CLRF   2A
0C50:  MOVFF  2A,29
0C54:  MOVFF  29,28
....................    fss1 = fss2 = fss3 = 0; 
0C58:  CLRF   2D
0C5A:  MOVFF  2D,2C
0C5E:  MOVFF  2C,2B
0C62:  RETURN 0
.................... } 
....................  
.................... void contando1() 
.................... { // Revisa maquina de estados para par 1 
....................    if (entra_temp1 != edo1) 
*
20BA:  MOVF   x76,W
20BC:  SUBWF  x7B,W
20BE:  BZ    20C8
....................    { 
....................       entra_temp1 = edo1; 
20C0:  MOVFF  76,7B
....................       enable1 = 1; 
20C4:  MOVLW  01
20C6:  MOVWF  x7A
....................    } 
....................    if (enable1 == 1) 
20C8:  DECFSZ x7A,W
20CA:  BRA    2108
....................    { 
....................       switch (edo1) 
20CC:  MOVLW  01
20CE:  SUBWF  x76,W
20D0:  ADDLW  F4
20D2:  BC    2104
20D4:  ADDLW  0C
20D6:  GOTO   210A
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
20DA:  BRA    2104
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss1) 
20DC:  MOVF   2B,F
20DE:  BNZ   20E6
....................             fse1 = 1; // si no ha salido antes 
20E0:  MOVLW  01
20E2:  MOVWF  28
20E4:  BRA    20E8
....................          else 
....................             fss1 = 0; 
20E6:  CLRF   2B
....................          detecta_suma(); 
20E8:  RCALL  1F38
....................          break; 
20EA:  BRA    2104
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
20EC:  RCALL  1F38
....................          break; 
20EE:  BRA    2104
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
20F0:  BRA    2104
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse1) 
20F2:  MOVF   28,F
20F4:  BNZ   20FC
....................             fss1 = 1; // si no ha entrado antes 
20F6:  MOVLW  01
20F8:  MOVWF  2B
20FA:  BRA    20FE
....................          else 
....................             fse1 = 0; 
20FC:  CLRF   28
....................          detecta_suma(); 
20FE:  RCALL  1F38
....................          break; 
2100:  BRA    2104
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
2102:  RCALL  1F38
....................          break; 
....................       } 
....................       } 
....................       enable1 = 0; 
2104:  CLRF   x7A
....................       entra_act1 = 0; 
2106:  CLRF   x75
....................    } 
2108:  RETURN 0
.................... } 
....................  
.................... void contando2() 
.................... { // Revisa maquina de estados para par 2 
....................    if (entra_temp2 != edo2) 
*
23C2:  MOVF   x7D,W
23C4:  SUBWF  x82,W
23C6:  BZ    23D0
....................    { 
....................       entra_temp2 = edo2; 
23C8:  MOVFF  7D,82
....................       enable2 = 1; 
23CC:  MOVLW  01
23CE:  MOVWF  x81
....................    } 
....................    if (enable2 == 1) 
23D0:  DECFSZ x81,W
23D2:  BRA    2410
....................    { 
....................       switch (edo2) 
23D4:  MOVLW  01
23D6:  SUBWF  x7D,W
23D8:  ADDLW  F4
23DA:  BC    240C
23DC:  ADDLW  0C
23DE:  GOTO   2412
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
23E2:  BRA    240C
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss2) 
23E4:  MOVF   2C,F
23E6:  BNZ   23EE
....................             fse2 = 1; 
23E8:  MOVLW  01
23EA:  MOVWF  29
23EC:  BRA    23F0
....................          else 
....................             fss2 = 0; 
23EE:  CLRF   2C
....................          detecta_suma(); 
23F0:  RCALL  1F38
....................          break; 
23F2:  BRA    240C
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
23F4:  RCALL  1F38
....................          break; 
23F6:  BRA    240C
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
23F8:  BRA    240C
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse2) 
23FA:  MOVF   29,F
23FC:  BNZ   2404
....................             fss2 = 1; 
23FE:  MOVLW  01
2400:  MOVWF  2C
2402:  BRA    2406
....................          else 
....................             fse2 = 0; 
2404:  CLRF   29
....................          detecta_suma(); 
2406:  RCALL  1F38
....................          break; 
2408:  BRA    240C
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
240A:  RCALL  1F38
....................          break; 
....................       } 
....................       } 
....................       enable2 = 0; 
240C:  CLRF   x81
....................       entra_act2 = 0; 
240E:  CLRF   x7C
....................    } 
2410:  RETURN 0
.................... } 
....................  
.................... void contando3() 
.................... { // Revisa maquina de estados para par 3 
....................    if (entra_temp3 != edo3) 
*
26CC:  MOVF   x84,W
26CE:  SUBWF  x89,W
26D0:  BZ    26DA
....................    { 
....................       entra_temp3 = edo3; 
26D2:  MOVFF  84,89
....................       enable3 = 1; 
26D6:  MOVLW  01
26D8:  MOVWF  x88
....................    } 
....................    if (enable3 == 1) 
26DA:  DECFSZ x88,W
26DC:  BRA    271A
....................    { 
....................       switch (edo3) 
26DE:  MOVLW  01
26E0:  SUBWF  x84,W
26E2:  ADDLW  F4
26E4:  BC    2716
26E6:  ADDLW  0C
26E8:  GOTO   271C
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
26EC:  BRA    2716
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss3) 
26EE:  MOVF   2D,F
26F0:  BNZ   26F8
....................             fse3 = 1; 
26F2:  MOVLW  01
26F4:  MOVWF  2A
26F6:  BRA    26FA
....................          else 
....................             fss3 = 0; 
26F8:  CLRF   2D
....................          detecta_suma(); 
26FA:  RCALL  1F38
....................          break; 
26FC:  BRA    2716
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
26FE:  RCALL  1F38
....................          break; 
2700:  BRA    2716
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
2702:  BRA    2716
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse3) 
2704:  MOVF   2A,F
2706:  BNZ   270E
....................             fss3 = 1; 
2708:  MOVLW  01
270A:  MOVWF  2D
270C:  BRA    2710
....................          else 
....................             fse3 = 0; 
270E:  CLRF   2A
....................          detecta_suma(); 
2710:  RCALL  1F38
....................          break; 
2712:  BRA    2716
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
2714:  RCALL  1F38
....................          break; 
....................       } 
....................       } 
....................       enable3 = 0; 
2716:  CLRF   x88
....................       entra_act3 = 0; 
2718:  CLRF   x83
....................    } 
271A:  RETURN 0
.................... } 
....................  
.................... void sensando1() 
.................... { // Define estados para la maquina de estados del par 1 
....................    /////normal/////// 
....................    if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 0) && (sale1 == 0)) 
*
1CB2:  MOVF   x75,F
1CB4:  BNZ   1CFA
1CB6:  DECFSZ x69,W
1CB8:  BRA    1CFA
1CBA:  MOVF   x6A,F
1CBC:  BNZ   1CFA
1CBE:  MOVF   x77,F
1CC0:  BNZ   1CFA
1CC2:  MOVF   x78,F
1CC4:  BNZ   1CFA
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
1CC6:  MOVF   5B,F
1CC8:  BNZ   1CD0
1CCA:  MOVF   5C,F
1CCC:  BNZ   1CD0
....................          sentidos(); 
1CCE:  RCALL  1C68
....................       lcd_gotoxy(8, 2); 
1CD0:  MOVLW  08
1CD2:  MOVLB  1
1CD4:  MOVWF  x94
1CD6:  MOVLW  02
1CD8:  MOVWF  x95
1CDA:  MOVLB  0
1CDC:  CALL   0822
....................       lcd_putc(0x7F); // flecha del sentido 
1CE0:  MOVLW  7F
1CE2:  MOVLB  1
1CE4:  MOVWF  x93
1CE6:  MOVLB  0
1CE8:  CALL   0874
....................       des1 = 1; 
1CEC:  MOVLW  01
1CEE:  MOVWF  x98
....................       //// 
....................       edo1 = 1; 
1CF0:  MOVWF  x76
....................       entra1 = 1; 
1CF2:  MOVWF  x77
....................       edoa1 = 1; 
1CF4:  MOVWF  x79
....................       entra_act1 = 1; 
1CF6:  MOVWF  x75
....................    } 
1CF8:  BRA    1F36
....................    /// prioridad 
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 1) && (entra1 == 1) && (sale1 == 0)) 
1CFA:  MOVF   x75,F
1CFC:  BNZ   1D1A
1CFE:  DECFSZ x69,W
1D00:  BRA    1D1A
1D02:  DECFSZ x6A,W
1D04:  BRA    1D1A
1D06:  DECFSZ x77,W
1D08:  BRA    1D1A
1D0A:  MOVF   x78,F
1D0C:  BNZ   1D1A
....................    { // PERSONA ENTRANDO 
....................       edo1 = 3; 
1D0E:  MOVLW  03
1D10:  MOVWF  x76
....................       edoa1 = 0; 
1D12:  CLRF   x79
....................       entra_act1 = 1; 
1D14:  MOVLW  01
1D16:  MOVWF  x75
....................    } 
1D18:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 1) && (sale1 == 0)) 
1D1A:  MOVF   x75,F
1D1C:  BNZ   1D38
1D1E:  MOVF   x69,F
1D20:  BNZ   1D38
1D22:  DECFSZ x6A,W
1D24:  BRA    1D38
1D26:  DECFSZ x77,W
1D28:  BRA    1D38
1D2A:  MOVF   x78,F
1D2C:  BNZ   1D38
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo1 = 4; 
1D2E:  MOVLW  04
1D30:  MOVWF  x76
....................       entra_act1 = 1; 
1D32:  MOVLW  01
1D34:  MOVWF  x75
....................    } 
1D36:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 0) && (entra1 == 1) && (sale1 == 0)) 
1D38:  MOVF   x75,F
1D3A:  BNZ   1D90
1D3C:  MOVF   x69,F
1D3E:  BNZ   1D90
1D40:  MOVF   x6A,F
1D42:  BNZ   1D90
1D44:  MOVF   x79,F
1D46:  BNZ   1D90
1D48:  DECFSZ x77,W
1D4A:  BRA    1D90
1D4C:  MOVF   x78,F
1D4E:  BNZ   1D90
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 2); 
1D50:  MOVLW  08
1D52:  MOVLB  1
1D54:  MOVWF  x94
1D56:  MOVLW  02
1D58:  MOVWF  x95
1D5A:  MOVLB  0
1D5C:  CALL   0822
....................       lcd_putc(" "); 
1D60:  MOVLW  4E
1D62:  MOVWF  FF6
1D64:  MOVLW  03
1D66:  MOVWF  FF7
1D68:  CALL   09F8
....................       des1 = 0; 
1D6C:  CLRF   x98
....................       if (entra_temp1 == 4) 
1D6E:  MOVF   x7B,W
1D70:  SUBLW  04
1D72:  BNZ   1D80
....................       { 
....................          edo1 = 5; 
1D74:  MOVLW  05
1D76:  MOVWF  x76
....................          entra1 = 0; 
1D78:  CLRF   x77
....................          entra_act1 = 1; 
1D7A:  MOVLW  01
1D7C:  MOVWF  x75
....................       } 
1D7E:  BRA    1D8E
....................       else 
....................       { // entraba y se regresa 
....................          des1 = 0; 
1D80:  CLRF   x98
....................          edo1 = 6; 
1D82:  MOVLW  06
1D84:  MOVWF  x76
....................          entra1 = 0; 
1D86:  CLRF   x77
....................          edoa1 = 0; 
1D88:  CLRF   x79
....................          entra_act1 = 1; 
1D8A:  MOVLW  01
1D8C:  MOVWF  x75
....................       } 
....................    } 
1D8E:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 1) && (entra1 == 1) && (sale1 == 0)) 
1D90:  MOVF   x75,F
1D92:  BNZ   1DD4
1D94:  MOVF   x69,F
1D96:  BNZ   1DD4
1D98:  MOVF   x6A,F
1D9A:  BNZ   1DD4
1D9C:  DECFSZ x79,W
1D9E:  BRA    1DD4
1DA0:  DECFSZ x77,W
1DA2:  BRA    1DD4
1DA4:  MOVF   x78,F
1DA6:  BNZ   1DD4
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 2); 
1DA8:  MOVLW  08
1DAA:  MOVLB  1
1DAC:  MOVWF  x94
1DAE:  MOVLW  02
1DB0:  MOVWF  x95
1DB2:  MOVLB  0
1DB4:  CALL   0822
....................       lcd_putc(" "); 
1DB8:  MOVLW  50
1DBA:  MOVWF  FF6
1DBC:  MOVLW  03
1DBE:  MOVWF  FF7
1DC0:  CALL   09F8
....................       des1 = 0; 
1DC4:  CLRF   x98
....................       edo1 = 6; 
1DC6:  MOVLW  06
1DC8:  MOVWF  x76
....................       entra1 = 0; 
1DCA:  CLRF   x77
....................       edoa1 = 0; 
1DCC:  CLRF   x79
....................       entra_act1 = 1; 
1DCE:  MOVLW  01
1DD0:  MOVWF  x75
....................    } 
1DD2:  BRA    1F36
....................    ///// 
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 1) && (sale1 == 0)) 
1DD4:  MOVF   x75,F
1DD6:  BNZ   1DF4
1DD8:  DECFSZ x69,W
1DDA:  BRA    1DF4
1DDC:  MOVF   x6A,F
1DDE:  BNZ   1DF4
1DE0:  DECFSZ x77,W
1DE2:  BRA    1DF4
1DE4:  MOVF   x78,F
1DE6:  BNZ   1DF4
....................    { 
....................       edo1 = 2; 
1DE8:  MOVLW  02
1DEA:  MOVWF  x76
....................       edoa1 = 1; 
1DEC:  MOVLW  01
1DEE:  MOVWF  x79
....................       entra_act1 = 1; 
1DF0:  MOVWF  x75
....................    } // checar prioridad 
1DF2:  BRA    1F36
....................    //////sentido inverso/// 
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 0) && (sale1 == 0)) 
1DF4:  MOVF   x75,F
1DF6:  BNZ   1E3E
1DF8:  MOVF   x69,F
1DFA:  BNZ   1E3E
1DFC:  DECFSZ x6A,W
1DFE:  BRA    1E3E
1E00:  MOVF   x77,F
1E02:  BNZ   1E3E
1E04:  MOVF   x78,F
1E06:  BNZ   1E3E
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
1E08:  MOVF   5B,F
1E0A:  BNZ   1E12
1E0C:  MOVF   5C,F
1E0E:  BNZ   1E12
....................          sentidos(); 
1E10:  RCALL  1C68
....................       lcd_gotoxy(8, 2); 
1E12:  MOVLW  08
1E14:  MOVLB  1
1E16:  MOVWF  x94
1E18:  MOVLW  02
1E1A:  MOVWF  x95
1E1C:  MOVLB  0
1E1E:  CALL   0822
....................       lcd_putc(0x7E); // flecha del sentido 
1E22:  MOVLW  7E
1E24:  MOVLB  1
1E26:  MOVWF  x93
1E28:  MOVLB  0
1E2A:  CALL   0874
....................       des1 = 1; 
1E2E:  MOVLW  01
1E30:  MOVWF  x98
....................       edo1 = 7; 
1E32:  MOVLW  07
1E34:  MOVWF  x76
....................       sale1 = 1; 
1E36:  MOVLW  01
1E38:  MOVWF  x78
....................       entra_act1 = 1; 
1E3A:  MOVWF  x75
....................    } 
1E3C:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 0) && (sale1 == 1)) 
1E3E:  MOVF   x75,F
1E40:  BNZ   1E5E
1E42:  MOVF   x69,F
1E44:  BNZ   1E5E
1E46:  DECFSZ x6A,W
1E48:  BRA    1E5E
1E4A:  MOVF   x77,F
1E4C:  BNZ   1E5E
1E4E:  DECFSZ x78,W
1E50:  BRA    1E5E
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo1 = 8; 
1E52:  MOVLW  08
1E54:  MOVWF  x76
....................       edoa1 = 1; 
1E56:  MOVLW  01
1E58:  MOVWF  x79
....................       entra_act1 = 1; 
1E5A:  MOVWF  x75
....................    } 
1E5C:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 1) && (entra1 == 0) && (sale1 == 1)) 
1E5E:  MOVF   x75,F
1E60:  BNZ   1E7E
1E62:  DECFSZ x69,W
1E64:  BRA    1E7E
1E66:  DECFSZ x6A,W
1E68:  BRA    1E7E
1E6A:  MOVF   x77,F
1E6C:  BNZ   1E7E
1E6E:  DECFSZ x78,W
1E70:  BRA    1E7E
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo1 = 9; 
1E72:  MOVLW  09
1E74:  MOVWF  x76
....................       edoa1 = 0; 
1E76:  CLRF   x79
....................       entra_act1 = 1; 
1E78:  MOVLW  01
1E7A:  MOVWF  x75
....................    } 
1E7C:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 0) && (sale1 == 1)) 
1E7E:  MOVF   x75,F
1E80:  BNZ   1E9C
1E82:  DECFSZ x69,W
1E84:  BRA    1E9C
1E86:  MOVF   x6A,F
1E88:  BNZ   1E9C
1E8A:  MOVF   x77,F
1E8C:  BNZ   1E9C
1E8E:  DECFSZ x78,W
1E90:  BRA    1E9C
....................    { // CASI TERMINA DE SALIR 
....................       edo1 = 10; 
1E92:  MOVLW  0A
1E94:  MOVWF  x76
....................       entra_act1 = 1; 
1E96:  MOVLW  01
1E98:  MOVWF  x75
....................    } 
1E9A:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 0) && (entra1 == 0) && (sale1 == 1)) 
1E9C:  MOVF   x75,F
1E9E:  BNZ   1EF4
1EA0:  MOVF   x69,F
1EA2:  BNZ   1EF4
1EA4:  MOVF   x6A,F
1EA6:  BNZ   1EF4
1EA8:  MOVF   x79,F
1EAA:  BNZ   1EF4
1EAC:  MOVF   x77,F
1EAE:  BNZ   1EF4
1EB0:  DECFSZ x78,W
1EB2:  BRA    1EF4
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 2); 
1EB4:  MOVLW  08
1EB6:  MOVLB  1
1EB8:  MOVWF  x94
1EBA:  MOVLW  02
1EBC:  MOVWF  x95
1EBE:  MOVLB  0
1EC0:  CALL   0822
....................       lcd_putc(" "); 
1EC4:  MOVLW  52
1EC6:  MOVWF  FF6
1EC8:  MOVLW  03
1ECA:  MOVWF  FF7
1ECC:  CALL   09F8
....................       if (entra_temp1 == 10) 
1ED0:  MOVF   x7B,W
1ED2:  SUBLW  0A
1ED4:  BNZ   1EE4
....................       { 
....................          des1 = 0; 
1ED6:  CLRF   x98
....................          edo1 = 11; 
1ED8:  MOVLW  0B
1EDA:  MOVWF  x76
....................          sale1 = 0; 
1EDC:  CLRF   x78
....................          entra_act1 = 1; 
1EDE:  MOVLW  01
1EE0:  MOVWF  x75
....................       } 
1EE2:  BRA    1EF2
....................       else 
....................       { 
....................          des1 = 0; 
1EE4:  CLRF   x98
....................          edo1 = 12; 
1EE6:  MOVLW  0C
1EE8:  MOVWF  x76
....................          sale1 = 0; 
1EEA:  CLRF   x78
....................          edoa1 = 0; 
1EEC:  CLRF   x79
....................          entra_act1 = 1; 
1EEE:  MOVLW  01
1EF0:  MOVWF  x75
....................       } 
....................    } 
1EF2:  BRA    1F36
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 1) && (entra1 == 0) && (sale1 == 1)) 
1EF4:  MOVF   x75,F
1EF6:  BNZ   1F36
1EF8:  MOVF   x69,F
1EFA:  BNZ   1F36
1EFC:  MOVF   x6A,F
1EFE:  BNZ   1F36
1F00:  DECFSZ x79,W
1F02:  BRA    1F36
1F04:  MOVF   x77,F
1F06:  BNZ   1F36
1F08:  DECFSZ x78,W
1F0A:  BRA    1F36
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 2); 
1F0C:  MOVLW  08
1F0E:  MOVLB  1
1F10:  MOVWF  x94
1F12:  MOVLW  02
1F14:  MOVWF  x95
1F16:  MOVLB  0
1F18:  CALL   0822
....................       lcd_putc(" "); 
1F1C:  MOVLW  54
1F1E:  MOVWF  FF6
1F20:  MOVLW  03
1F22:  MOVWF  FF7
1F24:  CALL   09F8
....................       des1 = 0; 
1F28:  CLRF   x98
....................       edo1 = 12; 
1F2A:  MOVLW  0C
1F2C:  MOVWF  x76
....................       sale1 = 0; 
1F2E:  CLRF   x78
....................       edoa1 = 0; 
1F30:  CLRF   x79
....................       entra_act1 = 1; 
1F32:  MOVLW  01
1F34:  MOVWF  x75
....................    } 
1F36:  RETURN 0
.................... } 
....................  
.................... void sensando2() 
.................... { // Define estados para la maquina de estados del par 2 
....................    /////normal/////// 
....................    if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 0) && (sale2 == 0)) 
*
213C:  MOVF   x7C,F
213E:  BNZ   2184
2140:  DECFSZ x6B,W
2142:  BRA    2184
2144:  MOVF   x6C,F
2146:  BNZ   2184
2148:  MOVF   x7E,F
214A:  BNZ   2184
214C:  MOVF   x7F,F
214E:  BNZ   2184
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
2150:  MOVF   5B,F
2152:  BNZ   215A
2154:  MOVF   5C,F
2156:  BNZ   215A
....................          sentidos(); 
2158:  RCALL  1C68
....................       lcd_gotoxy(8, 3); 
215A:  MOVLW  08
215C:  MOVLB  1
215E:  MOVWF  x94
2160:  MOVLW  03
2162:  MOVWF  x95
2164:  MOVLB  0
2166:  CALL   0822
....................       lcd_putc(0x7F); 
216A:  MOVLW  7F
216C:  MOVLB  1
216E:  MOVWF  x93
2170:  MOVLB  0
2172:  CALL   0874
....................       des2 = 1; 
2176:  MOVLW  01
2178:  MOVWF  x99
....................       edo2 = 1; 
217A:  MOVWF  x7D
....................       entra2 = 1; 
217C:  MOVWF  x7E
....................       edoa2 = 1; 
217E:  MOVWF  x80
....................       entra_act2 = 1; 
2180:  MOVWF  x7C
....................    } 
2182:  BRA    23C0
....................    /// prioridad 
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 1) && (entra2 == 1) && (sale2 == 0)) 
2184:  MOVF   x7C,F
2186:  BNZ   21A4
2188:  DECFSZ x6B,W
218A:  BRA    21A4
218C:  DECFSZ x6C,W
218E:  BRA    21A4
2190:  DECFSZ x7E,W
2192:  BRA    21A4
2194:  MOVF   x7F,F
2196:  BNZ   21A4
....................    { // PERSONA ENTRANDO 
....................       edo2 = 3; 
2198:  MOVLW  03
219A:  MOVWF  x7D
....................       edoa2 = 0; 
219C:  CLRF   x80
....................       entra_act2 = 1; 
219E:  MOVLW  01
21A0:  MOVWF  x7C
....................    } 
21A2:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 1) && (sale2 == 0)) 
21A4:  MOVF   x7C,F
21A6:  BNZ   21C2
21A8:  MOVF   x6B,F
21AA:  BNZ   21C2
21AC:  DECFSZ x6C,W
21AE:  BRA    21C2
21B0:  DECFSZ x7E,W
21B2:  BRA    21C2
21B4:  MOVF   x7F,F
21B6:  BNZ   21C2
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo2 = 4; 
21B8:  MOVLW  04
21BA:  MOVWF  x7D
....................       entra_act2 = 1; 
21BC:  MOVLW  01
21BE:  MOVWF  x7C
....................    } 
21C0:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 0) && (entra2 == 1) && (sale2 == 0)) 
21C2:  MOVF   x7C,F
21C4:  BNZ   221A
21C6:  MOVF   x6B,F
21C8:  BNZ   221A
21CA:  MOVF   x6C,F
21CC:  BNZ   221A
21CE:  MOVF   x80,F
21D0:  BNZ   221A
21D2:  DECFSZ x7E,W
21D4:  BRA    221A
21D6:  MOVF   x7F,F
21D8:  BNZ   221A
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 3); 
21DA:  MOVLW  08
21DC:  MOVLB  1
21DE:  MOVWF  x94
21E0:  MOVLW  03
21E2:  MOVWF  x95
21E4:  MOVLB  0
21E6:  CALL   0822
....................       lcd_putc(" "); 
21EA:  MOVLW  56
21EC:  MOVWF  FF6
21EE:  MOVLW  03
21F0:  MOVWF  FF7
21F2:  CALL   09F8
....................       if (entra_temp2 == 4) 
21F6:  MOVF   x82,W
21F8:  SUBLW  04
21FA:  BNZ   220A
....................       { 
....................          des2 = 0; 
21FC:  CLRF   x99
....................          edo2 = 5; 
21FE:  MOVLW  05
2200:  MOVWF  x7D
....................          entra2 = 0; 
2202:  CLRF   x7E
....................          entra_act2 = 1; 
2204:  MOVLW  01
2206:  MOVWF  x7C
....................       } 
2208:  BRA    2218
....................       else 
....................       { 
....................          des2 = 0; 
220A:  CLRF   x99
....................          edo2 = 6; 
220C:  MOVLW  06
220E:  MOVWF  x7D
....................          entra2 = 0; 
2210:  CLRF   x7E
....................          edoa2 = 0; 
2212:  CLRF   x80
....................          entra_act2 = 1; 
2214:  MOVLW  01
2216:  MOVWF  x7C
....................       } 
....................    } 
2218:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 1) && (entra2 == 1) && (sale2 == 0)) 
221A:  MOVF   x7C,F
221C:  BNZ   225E
221E:  MOVF   x6B,F
2220:  BNZ   225E
2222:  MOVF   x6C,F
2224:  BNZ   225E
2226:  DECFSZ x80,W
2228:  BRA    225E
222A:  DECFSZ x7E,W
222C:  BRA    225E
222E:  MOVF   x7F,F
2230:  BNZ   225E
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 3); 
2232:  MOVLW  08
2234:  MOVLB  1
2236:  MOVWF  x94
2238:  MOVLW  03
223A:  MOVWF  x95
223C:  MOVLB  0
223E:  CALL   0822
....................       lcd_putc(" "); 
2242:  MOVLW  58
2244:  MOVWF  FF6
2246:  MOVLW  03
2248:  MOVWF  FF7
224A:  CALL   09F8
....................       des2 = 0; 
224E:  CLRF   x99
....................       edo2 = 6; 
2250:  MOVLW  06
2252:  MOVWF  x7D
....................       entra2 = 0; 
2254:  CLRF   x7E
....................       edoa2 = 0; 
2256:  CLRF   x80
....................       entra_act2 = 1; 
2258:  MOVLW  01
225A:  MOVWF  x7C
....................    } 
225C:  BRA    23C0
....................    ///// 
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 1) && (sale2 == 0)) 
225E:  MOVF   x7C,F
2260:  BNZ   227E
2262:  DECFSZ x6B,W
2264:  BRA    227E
2266:  MOVF   x6C,F
2268:  BNZ   227E
226A:  DECFSZ x7E,W
226C:  BRA    227E
226E:  MOVF   x7F,F
2270:  BNZ   227E
....................    { 
....................       edo2 = 2; 
2272:  MOVLW  02
2274:  MOVWF  x7D
....................       edoa2 = 1; 
2276:  MOVLW  01
2278:  MOVWF  x80
....................       entra_act2 = 1; 
227A:  MOVWF  x7C
....................    } // checar prioridad 
227C:  BRA    23C0
....................    //////sentido inverso/// 
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 0) && (sale2 == 0)) 
227E:  MOVF   x7C,F
2280:  BNZ   22C8
2282:  MOVF   x6B,F
2284:  BNZ   22C8
2286:  DECFSZ x6C,W
2288:  BRA    22C8
228A:  MOVF   x7E,F
228C:  BNZ   22C8
228E:  MOVF   x7F,F
2290:  BNZ   22C8
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
2292:  MOVF   5B,F
2294:  BNZ   229C
2296:  MOVF   5C,F
2298:  BNZ   229C
....................          sentidos(); 
229A:  RCALL  1C68
....................       lcd_gotoxy(8, 3); 
229C:  MOVLW  08
229E:  MOVLB  1
22A0:  MOVWF  x94
22A2:  MOVLW  03
22A4:  MOVWF  x95
22A6:  MOVLB  0
22A8:  CALL   0822
....................       lcd_putc(0x7E); // flecha del sentido 
22AC:  MOVLW  7E
22AE:  MOVLB  1
22B0:  MOVWF  x93
22B2:  MOVLB  0
22B4:  CALL   0874
....................       des2 = 1; 
22B8:  MOVLW  01
22BA:  MOVWF  x99
....................       edo2 = 7; 
22BC:  MOVLW  07
22BE:  MOVWF  x7D
....................       sale2 = 1; 
22C0:  MOVLW  01
22C2:  MOVWF  x7F
....................       entra_act2 = 1; 
22C4:  MOVWF  x7C
....................    } 
22C6:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 0) && (sale2 == 1)) 
22C8:  MOVF   x7C,F
22CA:  BNZ   22E8
22CC:  MOVF   x6B,F
22CE:  BNZ   22E8
22D0:  DECFSZ x6C,W
22D2:  BRA    22E8
22D4:  MOVF   x7E,F
22D6:  BNZ   22E8
22D8:  DECFSZ x7F,W
22DA:  BRA    22E8
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo2 = 8; 
22DC:  MOVLW  08
22DE:  MOVWF  x7D
....................       edoa2 = 1; 
22E0:  MOVLW  01
22E2:  MOVWF  x80
....................       entra_act2 = 1; 
22E4:  MOVWF  x7C
....................    } 
22E6:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 1) && (entra2 == 0) && (sale2 == 1)) 
22E8:  MOVF   x7C,F
22EA:  BNZ   2308
22EC:  DECFSZ x6B,W
22EE:  BRA    2308
22F0:  DECFSZ x6C,W
22F2:  BRA    2308
22F4:  MOVF   x7E,F
22F6:  BNZ   2308
22F8:  DECFSZ x7F,W
22FA:  BRA    2308
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo2 = 9; 
22FC:  MOVLW  09
22FE:  MOVWF  x7D
....................       edoa2 = 0; 
2300:  CLRF   x80
....................       entra_act2 = 1; 
2302:  MOVLW  01
2304:  MOVWF  x7C
....................    } 
2306:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 0) && (sale2 == 1)) 
2308:  MOVF   x7C,F
230A:  BNZ   2326
230C:  DECFSZ x6B,W
230E:  BRA    2326
2310:  MOVF   x6C,F
2312:  BNZ   2326
2314:  MOVF   x7E,F
2316:  BNZ   2326
2318:  DECFSZ x7F,W
231A:  BRA    2326
....................    { // CASI TERMINA DE SALIR 
....................       edo2 = 10; 
231C:  MOVLW  0A
231E:  MOVWF  x7D
....................       entra_act2 = 1; 
2320:  MOVLW  01
2322:  MOVWF  x7C
....................    } 
2324:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 0) && (entra2 == 0) && (sale2 == 1)) 
2326:  MOVF   x7C,F
2328:  BNZ   237E
232A:  MOVF   x6B,F
232C:  BNZ   237E
232E:  MOVF   x6C,F
2330:  BNZ   237E
2332:  MOVF   x80,F
2334:  BNZ   237E
2336:  MOVF   x7E,F
2338:  BNZ   237E
233A:  DECFSZ x7F,W
233C:  BRA    237E
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 3); 
233E:  MOVLW  08
2340:  MOVLB  1
2342:  MOVWF  x94
2344:  MOVLW  03
2346:  MOVWF  x95
2348:  MOVLB  0
234A:  CALL   0822
....................       lcd_putc(" "); 
234E:  MOVLW  5A
2350:  MOVWF  FF6
2352:  MOVLW  03
2354:  MOVWF  FF7
2356:  CALL   09F8
....................       if (entra_temp2 == 10) 
235A:  MOVF   x82,W
235C:  SUBLW  0A
235E:  BNZ   236E
....................       { 
....................          des2 = 0; 
2360:  CLRF   x99
....................          edo2 = 11; 
2362:  MOVLW  0B
2364:  MOVWF  x7D
....................          sale2 = 0; 
2366:  CLRF   x7F
....................          entra_act2 = 1; 
2368:  MOVLW  01
236A:  MOVWF  x7C
....................       } 
236C:  BRA    237C
....................       else 
....................       { 
....................          des2 = 0; 
236E:  CLRF   x99
....................          edo2 = 12; 
2370:  MOVLW  0C
2372:  MOVWF  x7D
....................          sale2 = 0; 
2374:  CLRF   x7F
....................          edoa2 = 0; 
2376:  CLRF   x80
....................          entra_act2 = 1; 
2378:  MOVLW  01
237A:  MOVWF  x7C
....................       } 
....................    } 
237C:  BRA    23C0
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 1) && (entra2 == 0) && (sale2 == 1)) 
237E:  MOVF   x7C,F
2380:  BNZ   23C0
2382:  MOVF   x6B,F
2384:  BNZ   23C0
2386:  MOVF   x6C,F
2388:  BNZ   23C0
238A:  DECFSZ x80,W
238C:  BRA    23C0
238E:  MOVF   x7E,F
2390:  BNZ   23C0
2392:  DECFSZ x7F,W
2394:  BRA    23C0
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 3); 
2396:  MOVLW  08
2398:  MOVLB  1
239A:  MOVWF  x94
239C:  MOVLW  03
239E:  MOVWF  x95
23A0:  MOVLB  0
23A2:  CALL   0822
....................       lcd_putc(" "); 
23A6:  MOVLW  5C
23A8:  MOVWF  FF6
23AA:  MOVLW  03
23AC:  MOVWF  FF7
23AE:  CALL   09F8
....................       des2 = 0; 
23B2:  CLRF   x99
....................       edo2 = 12; 
23B4:  MOVLW  0C
23B6:  MOVWF  x7D
....................       sale2 = 0; 
23B8:  CLRF   x7F
....................       edoa2 = 0; 
23BA:  CLRF   x80
....................       entra_act2 = 1; 
23BC:  MOVLW  01
23BE:  MOVWF  x7C
....................    } 
23C0:  RETURN 0
.................... } 
....................  
.................... void sensando3() 
.................... { // Define estados para la maquina de estados del par 3 
....................    /////normal/////// 
....................    if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 0) && (sale3 == 0)) 
*
2444:  MOVF   x83,F
2446:  BNZ   248C
2448:  DECFSZ x6D,W
244A:  BRA    248C
244C:  MOVF   x6E,F
244E:  BNZ   248C
2450:  MOVF   x85,F
2452:  BNZ   248C
2454:  MOVF   x86,F
2456:  BNZ   248C
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
2458:  MOVF   5B,F
245A:  BNZ   2462
245C:  MOVF   5C,F
245E:  BNZ   2462
....................          sentidos(); 
2460:  RCALL  1C68
....................       lcd_gotoxy(8, 4); 
2462:  MOVLW  08
2464:  MOVLB  1
2466:  MOVWF  x94
2468:  MOVLW  04
246A:  MOVWF  x95
246C:  MOVLB  0
246E:  CALL   0822
....................       lcd_putc(0x7F); 
2472:  MOVLW  7F
2474:  MOVLB  1
2476:  MOVWF  x93
2478:  MOVLB  0
247A:  CALL   0874
....................       des3 = 1; 
247E:  MOVLW  01
2480:  MOVWF  x9A
....................       edo3 = 1; 
2482:  MOVWF  x84
....................       entra3 = 1; 
2484:  MOVWF  x85
....................       edoa3 = 1; 
2486:  MOVWF  x87
....................       entra_act3 = 1; 
2488:  MOVWF  x83
....................    } 
248A:  BRA    26CA
....................    /// prioridad 
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 1) && (entra3 == 1) && (sale3 == 0)) 
248C:  MOVF   x83,F
248E:  BNZ   24AC
2490:  DECFSZ x6D,W
2492:  BRA    24AC
2494:  DECFSZ x6E,W
2496:  BRA    24AC
2498:  DECFSZ x85,W
249A:  BRA    24AC
249C:  MOVF   x86,F
249E:  BNZ   24AC
....................    { // PERSONA ENTRANDO 
....................       edo3 = 3; 
24A0:  MOVLW  03
24A2:  MOVWF  x84
....................       edoa3 = 0; 
24A4:  CLRF   x87
....................       entra_act3 = 1; 
24A6:  MOVLW  01
24A8:  MOVWF  x83
....................    } 
24AA:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 1) && (sale3 == 0)) 
24AC:  MOVF   x83,F
24AE:  BNZ   24CA
24B0:  MOVF   x6D,F
24B2:  BNZ   24CA
24B4:  DECFSZ x6E,W
24B6:  BRA    24CA
24B8:  DECFSZ x85,W
24BA:  BRA    24CA
24BC:  MOVF   x86,F
24BE:  BNZ   24CA
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo3 = 4; 
24C0:  MOVLW  04
24C2:  MOVWF  x84
....................       entra_act3 = 1; 
24C4:  MOVLW  01
24C6:  MOVWF  x83
....................    } 
24C8:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 0) && (entra3 == 1) && (sale3 == 0)) 
24CA:  MOVF   x83,F
24CC:  BNZ   2522
24CE:  MOVF   x6D,F
24D0:  BNZ   2522
24D2:  MOVF   x6E,F
24D4:  BNZ   2522
24D6:  MOVF   x87,F
24D8:  BNZ   2522
24DA:  DECFSZ x85,W
24DC:  BRA    2522
24DE:  MOVF   x86,F
24E0:  BNZ   2522
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 4); 
24E2:  MOVLW  08
24E4:  MOVLB  1
24E6:  MOVWF  x94
24E8:  MOVLW  04
24EA:  MOVWF  x95
24EC:  MOVLB  0
24EE:  CALL   0822
....................       lcd_putc(" "); 
24F2:  MOVLW  5E
24F4:  MOVWF  FF6
24F6:  MOVLW  03
24F8:  MOVWF  FF7
24FA:  CALL   09F8
....................       if (entra_temp3 == 4) 
24FE:  MOVF   x89,W
2500:  SUBLW  04
2502:  BNZ   2512
....................       { 
....................          des3 = 0; 
2504:  CLRF   x9A
....................          edo3 = 5; 
2506:  MOVLW  05
2508:  MOVWF  x84
....................          entra3 = 0; 
250A:  CLRF   x85
....................          entra_act3 = 1; 
250C:  MOVLW  01
250E:  MOVWF  x83
....................       } 
2510:  BRA    2520
....................       else 
....................       { 
....................          des3 = 0; 
2512:  CLRF   x9A
....................          edo3 = 6; 
2514:  MOVLW  06
2516:  MOVWF  x84
....................          entra3 = 0; 
2518:  CLRF   x85
....................          edoa3 = 0; 
251A:  CLRF   x87
....................          entra_act3 = 1; 
251C:  MOVLW  01
251E:  MOVWF  x83
....................       } 
....................    } 
2520:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 1) && (entra3 == 1) && (sale3 == 0)) 
2522:  MOVF   x83,F
2524:  BNZ   2566
2526:  MOVF   x6D,F
2528:  BNZ   2566
252A:  MOVF   x6E,F
252C:  BNZ   2566
252E:  DECFSZ x87,W
2530:  BRA    2566
2532:  DECFSZ x85,W
2534:  BRA    2566
2536:  MOVF   x86,F
2538:  BNZ   2566
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 4); 
253A:  MOVLW  08
253C:  MOVLB  1
253E:  MOVWF  x94
2540:  MOVLW  04
2542:  MOVWF  x95
2544:  MOVLB  0
2546:  CALL   0822
....................       lcd_putc(" "); 
254A:  MOVLW  60
254C:  MOVWF  FF6
254E:  MOVLW  03
2550:  MOVWF  FF7
2552:  CALL   09F8
....................       des3 = 0; 
2556:  CLRF   x9A
....................       edo3 = 6; 
2558:  MOVLW  06
255A:  MOVWF  x84
....................       entra3 = 0; 
255C:  CLRF   x85
....................       edoa3 = 0; 
255E:  CLRF   x87
....................       entra_act3 = 1; 
2560:  MOVLW  01
2562:  MOVWF  x83
....................    } 
2564:  BRA    26CA
....................    ///// 
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 1) && (sale3 == 0)) 
2566:  MOVF   x83,F
2568:  BNZ   2586
256A:  DECFSZ x6D,W
256C:  BRA    2586
256E:  MOVF   x6E,F
2570:  BNZ   2586
2572:  DECFSZ x85,W
2574:  BRA    2586
2576:  MOVF   x86,F
2578:  BNZ   2586
....................    { 
....................       // sentidos(); 
....................       edo3 = 2; 
257A:  MOVLW  02
257C:  MOVWF  x84
....................       edoa3 = 1; 
257E:  MOVLW  01
2580:  MOVWF  x87
....................       entra_act3 = 1; 
2582:  MOVWF  x83
....................    } // checar prioridad 
2584:  BRA    26CA
....................    //////sentido inverso/// 
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 0) && (sale3 == 0)) 
2586:  MOVF   x83,F
2588:  BNZ   25D2
258A:  MOVF   x6D,F
258C:  BNZ   25D2
258E:  DECFSZ x6E,W
2590:  BRA    25D2
2592:  MOVF   x85,F
2594:  BNZ   25D2
2596:  MOVF   x86,F
2598:  BNZ   25D2
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
259A:  MOVF   5B,F
259C:  BNZ   25A6
259E:  MOVF   5C,F
25A0:  BNZ   25A6
....................          sentidos(); 
25A2:  CALL   1C68
....................       lcd_gotoxy(8, 4); 
25A6:  MOVLW  08
25A8:  MOVLB  1
25AA:  MOVWF  x94
25AC:  MOVLW  04
25AE:  MOVWF  x95
25B0:  MOVLB  0
25B2:  CALL   0822
....................       lcd_putc(0x7E); // flecha del sentido 
25B6:  MOVLW  7E
25B8:  MOVLB  1
25BA:  MOVWF  x93
25BC:  MOVLB  0
25BE:  CALL   0874
....................       des3 = 1; 
25C2:  MOVLW  01
25C4:  MOVWF  x9A
....................       edo3 = 7; 
25C6:  MOVLW  07
25C8:  MOVWF  x84
....................       sale3 = 1; 
25CA:  MOVLW  01
25CC:  MOVWF  x86
....................       entra_act3 = 1; 
25CE:  MOVWF  x83
....................    } 
25D0:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 0) && (sale3 == 1)) 
25D2:  MOVF   x83,F
25D4:  BNZ   25F2
25D6:  MOVF   x6D,F
25D8:  BNZ   25F2
25DA:  DECFSZ x6E,W
25DC:  BRA    25F2
25DE:  MOVF   x85,F
25E0:  BNZ   25F2
25E2:  DECFSZ x86,W
25E4:  BRA    25F2
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo3 = 8; 
25E6:  MOVLW  08
25E8:  MOVWF  x84
....................       edoa3 = 1; 
25EA:  MOVLW  01
25EC:  MOVWF  x87
....................       entra_act3 = 1; 
25EE:  MOVWF  x83
....................    } 
25F0:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 1) && (entra3 == 0) && (sale3 == 1)) 
25F2:  MOVF   x83,F
25F4:  BNZ   2612
25F6:  DECFSZ x6D,W
25F8:  BRA    2612
25FA:  DECFSZ x6E,W
25FC:  BRA    2612
25FE:  MOVF   x85,F
2600:  BNZ   2612
2602:  DECFSZ x86,W
2604:  BRA    2612
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo3 = 9; 
2606:  MOVLW  09
2608:  MOVWF  x84
....................       edoa3 = 0; 
260A:  CLRF   x87
....................       entra_act3 = 1; 
260C:  MOVLW  01
260E:  MOVWF  x83
....................    } 
2610:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 0) && (sale3 == 1)) 
2612:  MOVF   x83,F
2614:  BNZ   2630
2616:  DECFSZ x6D,W
2618:  BRA    2630
261A:  MOVF   x6E,F
261C:  BNZ   2630
261E:  MOVF   x85,F
2620:  BNZ   2630
2622:  DECFSZ x86,W
2624:  BRA    2630
....................    { // CASI TERMINA DE SALIR 
....................       edo3 = 10; 
2626:  MOVLW  0A
2628:  MOVWF  x84
....................       entra_act3 = 1; 
262A:  MOVLW  01
262C:  MOVWF  x83
....................    } 
262E:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 0) && (entra3 == 0) && (sale3 == 1)) 
2630:  MOVF   x83,F
2632:  BNZ   2688
2634:  MOVF   x6D,F
2636:  BNZ   2688
2638:  MOVF   x6E,F
263A:  BNZ   2688
263C:  MOVF   x87,F
263E:  BNZ   2688
2640:  MOVF   x85,F
2642:  BNZ   2688
2644:  DECFSZ x86,W
2646:  BRA    2688
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 4); 
2648:  MOVLW  08
264A:  MOVLB  1
264C:  MOVWF  x94
264E:  MOVLW  04
2650:  MOVWF  x95
2652:  MOVLB  0
2654:  CALL   0822
....................       lcd_putc(" "); 
2658:  MOVLW  62
265A:  MOVWF  FF6
265C:  MOVLW  03
265E:  MOVWF  FF7
2660:  CALL   09F8
....................       if (entra_temp3 == 10) 
2664:  MOVF   x89,W
2666:  SUBLW  0A
2668:  BNZ   2678
....................       { 
....................          des3 = 0; 
266A:  CLRF   x9A
....................          edo3 = 11; 
266C:  MOVLW  0B
266E:  MOVWF  x84
....................          sale3 = 0; 
2670:  CLRF   x86
....................          entra_act3 = 1; 
2672:  MOVLW  01
2674:  MOVWF  x83
....................       } 
2676:  BRA    2686
....................       else 
....................       { 
....................          des3 = 0; 
2678:  CLRF   x9A
....................          edo3 = 12; 
267A:  MOVLW  0C
267C:  MOVWF  x84
....................          sale3 = 0; 
267E:  CLRF   x86
....................          edoa3 = 0; 
2680:  CLRF   x87
....................          entra_act3 = 1; 
2682:  MOVLW  01
2684:  MOVWF  x83
....................       } 
....................    } 
2686:  BRA    26CA
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 1) && (entra3 == 0) && (sale3 == 1)) 
2688:  MOVF   x83,F
268A:  BNZ   26CA
268C:  MOVF   x6D,F
268E:  BNZ   26CA
2690:  MOVF   x6E,F
2692:  BNZ   26CA
2694:  DECFSZ x87,W
2696:  BRA    26CA
2698:  MOVF   x85,F
269A:  BNZ   26CA
269C:  DECFSZ x86,W
269E:  BRA    26CA
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 4); 
26A0:  MOVLW  08
26A2:  MOVLB  1
26A4:  MOVWF  x94
26A6:  MOVLW  04
26A8:  MOVWF  x95
26AA:  MOVLB  0
26AC:  CALL   0822
....................       lcd_putc(" "); 
26B0:  MOVLW  64
26B2:  MOVWF  FF6
26B4:  MOVLW  03
26B6:  MOVWF  FF7
26B8:  CALL   09F8
....................       des3 = 0; 
26BC:  CLRF   x9A
....................       edo3 = 12; 
26BE:  MOVLW  0C
26C0:  MOVWF  x84
....................       sale3 = 0; 
26C2:  CLRF   x86
....................       edoa3 = 0; 
26C4:  CLRF   x87
....................       entra_act3 = 1; 
26C6:  MOVLW  01
26C8:  MOVWF  x83
....................    } 
26CA:  RETURN 0
.................... } 
....................  
.................... void sensores() 
.................... { // Detecta estado (bloqueado o libre) de los sensores 
....................    // sensor1 
....................    ent1 = input(entrada01); 
*
274E:  BSF    F93.4
2750:  CLRF   55
2752:  BTFSC  F81.4
2754:  INCF   55,F
....................    if (ent1 == 1) 
2756:  DECFSZ 55,W
2758:  BRA    2772
....................    { 
....................       sub_cta1 = 0; 
275A:  CLRF   5E
275C:  CLRF   5D
....................       detec1 = 0; 
275E:  CLRF   x69
....................       bloq_p1 = 0; // deshabilita bloqueo par1 
2760:  CLRF   x9B
....................       tim_p1 = 0; 
2762:  CLRF   xA2
2764:  CLRF   xA1
....................       if (en_b1) 
2766:  MOVF   x9E,F
2768:  BZ    2770
....................       {                        // pregunta si esta sonando el par1 
....................          output_low(salida01); // apaga alarma bloqueo 
276A:  BCF    F94.3
276C:  BCF    F8B.3
....................          en_b1 = 0; 
276E:  CLRF   x9E
....................       } 
....................    } 
2770:  BRA    27CC
....................    else 
....................    { 
....................       if (sub_cta1 >= s_cta) 
2772:  MOVF   5E,F
2774:  BNZ   277C
2776:  MOVF   5D,W
2778:  SUBLW  04
277A:  BC    2780
....................          detec1 = 1; // revisa si se interumpio la luz en (5ms*4) 
277C:  MOVLW  01
277E:  MOVWF  x69
....................       if (sub_d1 != detec1) 
2780:  MOVF   x69,W
2782:  SUBWF  x6F,W
2784:  BZ    27CC
....................       { // si, cambia de estado el sensor 
....................          sub_d1 = detec1; 
2786:  MOVFF  69,6F
....................          enable1 = 1; 
278A:  MOVLW  01
278C:  MOVWF  x7A
....................          lcd_gotoxy(5, 2); 
278E:  MOVLW  05
2790:  MOVLB  1
2792:  MOVWF  x94
2794:  MOVLW  02
2796:  MOVWF  x95
2798:  MOVLB  0
279A:  CALL   0822
....................          printf(lcd_putc, "1:%d", sub_d1); 
279E:  MOVLW  31
27A0:  MOVLB  1
27A2:  MOVWF  x93
27A4:  MOVLB  0
27A6:  CALL   0874
27AA:  MOVLW  3A
27AC:  MOVLB  1
27AE:  MOVWF  x93
27B0:  MOVLB  0
27B2:  CALL   0874
27B6:  MOVFF  6F,18A
27BA:  MOVLW  18
27BC:  MOVLB  1
27BE:  MOVWF  x8B
27C0:  MOVLB  0
27C2:  CALL   0FC0
....................          sensando1(); 
27C6:  CALL   1CB2
....................          contando1(); 
27CA:  RCALL  20BA
....................       } 
....................    } 
....................    // sensor2 
....................    ent2 = input(entrada02); 
27CC:  BSF    F95.4
27CE:  CLRF   56
27D0:  BTFSC  F83.4
27D2:  INCF   56,F
....................    if (ent2 == 1) 
27D4:  DECFSZ 56,W
27D6:  BRA    27F4
....................    { 
....................       output_high(salida02); // 
27D8:  BCF    F94.4
27DA:  BSF    F8B.4
....................       sub_cta2 = 0; 
27DC:  CLRF   x60
27DE:  CLRF   5F
....................       detec2 = 0; 
27E0:  CLRF   x6A
....................       bloq_p1 = 0; // deshabilita bloqueo 
27E2:  CLRF   x9B
....................       tim_p1 = 0; 
27E4:  CLRF   xA2
27E6:  CLRF   xA1
....................       if (en_b1) 
27E8:  MOVF   x9E,F
27EA:  BZ    27F2
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
27EC:  BCF    F94.3
27EE:  BCF    F8B.3
....................          en_b1 = 0; 
27F0:  CLRF   x9E
....................       } 
....................    } 
27F2:  BRA    285C
....................    else 
....................    { 
....................       output_low(salida02); 
27F4:  BCF    F94.4
27F6:  BCF    F8B.4
....................       if (sub_cta2 >= s_cta) 
27F8:  MOVF   x60,F
27FA:  BNZ   2802
27FC:  MOVF   5F,W
27FE:  SUBLW  04
2800:  BC    2806
....................          detec2 = 1; 
2802:  MOVLW  01
2804:  MOVWF  x6A
....................       if (sub_d2 != detec2) 
2806:  MOVF   x6A,W
2808:  SUBWF  x70,W
280A:  BZ    285C
....................       { 
....................          sub_d2 = detec2; 
280C:  MOVFF  6A,70
....................          enable1 = 1; 
2810:  MOVLW  01
2812:  MOVWF  x7A
....................          lcd_gotoxy(1, 2); 
2814:  MOVLB  1
2816:  MOVWF  x94
2818:  MOVLW  02
281A:  MOVWF  x95
281C:  MOVLB  0
281E:  CALL   0822
....................          printf(lcd_putc, "2:%d ", sub_d2); 
2822:  MOVLW  32
2824:  MOVLB  1
2826:  MOVWF  x93
2828:  MOVLB  0
282A:  CALL   0874
282E:  MOVLW  3A
2830:  MOVLB  1
2832:  MOVWF  x93
2834:  MOVLB  0
2836:  CALL   0874
283A:  MOVFF  70,18A
283E:  MOVLW  18
2840:  MOVLB  1
2842:  MOVWF  x8B
2844:  MOVLB  0
2846:  CALL   0FC0
284A:  MOVLW  20
284C:  MOVLB  1
284E:  MOVWF  x93
2850:  MOVLB  0
2852:  CALL   0874
....................          sensando1(); 
2856:  CALL   1CB2
....................          contando1(); 
285A:  RCALL  20BA
....................       } 
....................    } 
....................    // sensor3 
....................    ent3 = input(entrada03); 
285C:  BSF    F93.2
285E:  CLRF   57
2860:  BTFSC  F81.2
2862:  INCF   57,F
....................    if (ent3 == 1) 
2864:  DECFSZ 57,W
2866:  BRA    2880
....................    { 
....................       sub_cta3 = 0; 
2868:  CLRF   x62
286A:  CLRF   x61
....................       detec3 = 0; 
286C:  CLRF   x6B
....................       bloq_p2 = 0; // deshabilita bloqueo 
286E:  CLRF   x9C
....................       tim_p2 = 0; 
2870:  CLRF   xA4
2872:  CLRF   xA3
....................       if (en_b2) 
2874:  MOVF   x9F,F
2876:  BZ    287E
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2878:  BCF    F94.3
287A:  BCF    F8B.3
....................          en_b2 = 0; 
287C:  CLRF   x9F
....................       } 
....................    } 
287E:  BRA    28D8
....................    else 
....................    { 
....................       if (sub_cta3 >= s_cta) 
2880:  MOVF   x62,F
2882:  BNZ   288A
2884:  MOVF   x61,W
2886:  SUBLW  04
2888:  BC    288E
....................          detec3 = 1; 
288A:  MOVLW  01
288C:  MOVWF  x6B
....................       if (sub_d3 != detec3) 
288E:  MOVF   x6B,W
2890:  SUBWF  x71,W
2892:  BZ    28D8
....................       { 
....................          sub_d3 = detec3; 
2894:  MOVFF  6B,71
....................          enable2 = 1; 
2898:  MOVLW  01
289A:  MOVWF  x81
....................          lcd_gotoxy(5, 3); 
289C:  MOVLW  05
289E:  MOVLB  1
28A0:  MOVWF  x94
28A2:  MOVLW  03
28A4:  MOVWF  x95
28A6:  MOVLB  0
28A8:  CALL   0822
....................          printf(lcd_putc, "3:%d", sub_d3); 
28AC:  MOVLW  33
28AE:  MOVLB  1
28B0:  MOVWF  x93
28B2:  MOVLB  0
28B4:  CALL   0874
28B8:  MOVLW  3A
28BA:  MOVLB  1
28BC:  MOVWF  x93
28BE:  MOVLB  0
28C0:  CALL   0874
28C4:  MOVFF  71,18A
28C8:  MOVLW  18
28CA:  MOVLB  1
28CC:  MOVWF  x8B
28CE:  MOVLB  0
28D0:  CALL   0FC0
....................          sensando2(); 
28D4:  RCALL  213C
....................          contando2(); 
28D6:  RCALL  23C2
....................       } 
....................    } 
....................    // sensor4 
....................    ent4 = input(entrada04); 
28D8:  BSF    F93.3
28DA:  CLRF   58
28DC:  BTFSC  F81.3
28DE:  INCF   58,F
....................    if (ent4 == 1) 
28E0:  DECFSZ 58,W
28E2:  BRA    2900
....................    { 
....................       output_high(salida02); // 
28E4:  BCF    F94.4
28E6:  BSF    F8B.4
....................       sub_cta4 = 0; 
28E8:  CLRF   x64
28EA:  CLRF   x63
....................       detec4 = 0; 
28EC:  CLRF   x6C
....................       bloq_p2 = 0; // deshabilita bloqueo 
28EE:  CLRF   x9C
....................       tim_p2 = 0; 
28F0:  CLRF   xA4
28F2:  CLRF   xA3
....................       if (en_b2) 
28F4:  MOVF   x9F,F
28F6:  BZ    28FE
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
28F8:  BCF    F94.3
28FA:  BCF    F8B.3
....................          en_b2 = 0; 
28FC:  CLRF   x9F
....................       } 
....................    } 
28FE:  BRA    2968
....................    else 
....................    { 
....................       output_low(salida02); 
2900:  BCF    F94.4
2902:  BCF    F8B.4
....................       if (sub_cta4 >= s_cta) 
2904:  MOVF   x64,F
2906:  BNZ   290E
2908:  MOVF   x63,W
290A:  SUBLW  04
290C:  BC    2912
....................          detec4 = 1; 
290E:  MOVLW  01
2910:  MOVWF  x6C
....................       if (sub_d4 != detec4) 
2912:  MOVF   x6C,W
2914:  SUBWF  x72,W
2916:  BZ    2968
....................       { 
....................          sub_d4 = detec4; 
2918:  MOVFF  6C,72
....................          enable2 = 1; 
291C:  MOVLW  01
291E:  MOVWF  x81
....................          lcd_gotoxy(1, 3); 
2920:  MOVLB  1
2922:  MOVWF  x94
2924:  MOVLW  03
2926:  MOVWF  x95
2928:  MOVLB  0
292A:  CALL   0822
....................          printf(lcd_putc, "4:%d ", sub_d4); 
292E:  MOVLW  34
2930:  MOVLB  1
2932:  MOVWF  x93
2934:  MOVLB  0
2936:  CALL   0874
293A:  MOVLW  3A
293C:  MOVLB  1
293E:  MOVWF  x93
2940:  MOVLB  0
2942:  CALL   0874
2946:  MOVFF  72,18A
294A:  MOVLW  18
294C:  MOVLB  1
294E:  MOVWF  x8B
2950:  MOVLB  0
2952:  CALL   0FC0
2956:  MOVLW  20
2958:  MOVLB  1
295A:  MOVWF  x93
295C:  MOVLB  0
295E:  CALL   0874
....................          sensando2(); 
2962:  CALL   213C
....................          contando2(); 
2966:  RCALL  23C2
....................       } 
....................    } 
....................    // sensor5 
....................    ent5 = input(entrada05); 
2968:  BSF    F93.0
296A:  CLRF   59
296C:  BTFSC  F81.0
296E:  INCF   59,F
....................    if (ent5 == 1) 
2970:  DECFSZ 59,W
2972:  BRA    298C
....................    { 
....................       sub_cta5 = 0; 
2974:  CLRF   x66
2976:  CLRF   x65
....................       detec5 = 0; 
2978:  CLRF   x6D
....................       bloq_p3 = 0; // deshabilita bloqueo 
297A:  CLRF   x9D
....................       tim_p3 = 0; 
297C:  CLRF   xA6
297E:  CLRF   xA5
....................       if (en_b3) 
2980:  MOVF   xA0,F
2982:  BZ    298A
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2984:  BCF    F94.3
2986:  BCF    F8B.3
....................          en_b3 = 0; 
2988:  CLRF   xA0
....................       } 
....................    } 
298A:  BRA    29E4
....................    else 
....................    { 
....................       if (sub_cta5 >= s_cta) 
298C:  MOVF   x66,F
298E:  BNZ   2996
2990:  MOVF   x65,W
2992:  SUBLW  04
2994:  BC    299A
....................          detec5 = 1; 
2996:  MOVLW  01
2998:  MOVWF  x6D
....................       if (sub_d5 != detec5) 
299A:  MOVF   x6D,W
299C:  SUBWF  x73,W
299E:  BZ    29E4
....................       { 
....................          sub_d5 = detec5; 
29A0:  MOVFF  6D,73
....................          enable3 = 1; 
29A4:  MOVLW  01
29A6:  MOVWF  x88
....................          lcd_gotoxy(5, 4); 
29A8:  MOVLW  05
29AA:  MOVLB  1
29AC:  MOVWF  x94
29AE:  MOVLW  04
29B0:  MOVWF  x95
29B2:  MOVLB  0
29B4:  CALL   0822
....................          printf(lcd_putc, "5:%d", sub_d5); 
29B8:  MOVLW  35
29BA:  MOVLB  1
29BC:  MOVWF  x93
29BE:  MOVLB  0
29C0:  CALL   0874
29C4:  MOVLW  3A
29C6:  MOVLB  1
29C8:  MOVWF  x93
29CA:  MOVLB  0
29CC:  CALL   0874
29D0:  MOVFF  73,18A
29D4:  MOVLW  18
29D6:  MOVLB  1
29D8:  MOVWF  x8B
29DA:  MOVLB  0
29DC:  CALL   0FC0
....................          sensando3(); 
29E0:  RCALL  2444
....................          contando3(); 
29E2:  RCALL  26CC
....................       } 
....................    } 
....................    // sensor6 
....................    ent6 = input(entrada06); 
29E4:  BSF    F93.1
29E6:  CLRF   5A
29E8:  BTFSC  F81.1
29EA:  INCF   5A,F
....................    if (ent6 == 1) 
29EC:  DECFSZ 5A,W
29EE:  BRA    2A0C
....................    { 
....................       output_high(salida02); // 
29F0:  BCF    F94.4
29F2:  BSF    F8B.4
....................       sub_cta6 = 0; 
29F4:  CLRF   x68
29F6:  CLRF   x67
....................       detec6 = 0; 
29F8:  CLRF   x6E
....................       bloq_p3 = 0; // deshabilita bloqueo 
29FA:  CLRF   x9D
....................       tim_p3 = 0; 
29FC:  CLRF   xA6
29FE:  CLRF   xA5
....................       if (en_b3) 
2A00:  MOVF   xA0,F
2A02:  BZ    2A0A
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2A04:  BCF    F94.3
2A06:  BCF    F8B.3
....................          en_b3 = 0; 
2A08:  CLRF   xA0
....................       } 
....................    } 
2A0A:  BRA    2A72
....................    else 
....................    { 
....................       output_low(salida02); // 
2A0C:  BCF    F94.4
2A0E:  BCF    F8B.4
....................       if (sub_cta6 >= s_cta) 
2A10:  MOVF   x68,F
2A12:  BNZ   2A1A
2A14:  MOVF   x67,W
2A16:  SUBLW  04
2A18:  BC    2A1E
....................          detec6 = 1; 
2A1A:  MOVLW  01
2A1C:  MOVWF  x6E
....................       if (sub_d6 != detec6) 
2A1E:  MOVF   x6E,W
2A20:  SUBWF  x74,W
2A22:  BZ    2A72
....................       { 
....................          sub_d6 = detec6; 
2A24:  MOVFF  6E,74
....................          enable3 = 1; 
2A28:  MOVLW  01
2A2A:  MOVWF  x88
....................          lcd_gotoxy(1, 4); 
2A2C:  MOVLB  1
2A2E:  MOVWF  x94
2A30:  MOVLW  04
2A32:  MOVWF  x95
2A34:  MOVLB  0
2A36:  CALL   0822
....................          printf(lcd_putc, "6:%d ", sub_d6); 
2A3A:  MOVLW  36
2A3C:  MOVLB  1
2A3E:  MOVWF  x93
2A40:  MOVLB  0
2A42:  CALL   0874
2A46:  MOVLW  3A
2A48:  MOVLB  1
2A4A:  MOVWF  x93
2A4C:  MOVLB  0
2A4E:  CALL   0874
2A52:  MOVFF  74,18A
2A56:  MOVLW  18
2A58:  MOVLB  1
2A5A:  MOVWF  x8B
2A5C:  MOVLB  0
2A5E:  CALL   0FC0
2A62:  MOVLW  20
2A64:  MOVLB  1
2A66:  MOVWF  x93
2A68:  MOVLB  0
2A6A:  CALL   0874
....................          sensando3(); 
2A6E:  RCALL  2444
....................          contando3(); 
2A70:  RCALL  26CC
....................       } 
....................    } 
....................    ////////////////////////// 
....................    if ((detec1 == 1) && (detec2 == 1) && (bloq_p1 == 0)) 
2A72:  DECFSZ x69,W
2A74:  BRA    2A86
2A76:  DECFSZ x6A,W
2A78:  BRA    2A86
2A7A:  MOVF   x9B,F
2A7C:  BNZ   2A86
....................    { 
....................       bloq_p1 = 1; 
2A7E:  MOVLW  01
2A80:  MOVWF  x9B
....................       tim_p1 = 0; 
2A82:  CLRF   xA2
2A84:  CLRF   xA1
....................    } 
....................    if ((detec3 == 1) && (detec4 == 1) && (bloq_p2 == 0)) 
2A86:  DECFSZ x6B,W
2A88:  BRA    2A9A
2A8A:  DECFSZ x6C,W
2A8C:  BRA    2A9A
2A8E:  MOVF   x9C,F
2A90:  BNZ   2A9A
....................    { 
....................       bloq_p2 = 1; 
2A92:  MOVLW  01
2A94:  MOVWF  x9C
....................       tim_p2 = 0; 
2A96:  CLRF   xA4
2A98:  CLRF   xA3
....................    } 
....................    if ((detec5 == 1) && (detec6 == 1) && (bloq_p3 == 0)) 
2A9A:  DECFSZ x6D,W
2A9C:  BRA    2AAE
2A9E:  DECFSZ x6E,W
2AA0:  BRA    2AAE
2AA2:  MOVF   x9D,F
2AA4:  BNZ   2AAE
....................    { 
....................       bloq_p3 = 1; 
2AA6:  MOVLW  01
2AA8:  MOVWF  x9D
....................       tim_p3 = 0; 
2AAA:  CLRF   xA6
2AAC:  CLRF   xA5
....................    } 
2AAE:  GOTO   32B0 (RETURN)
.................... } // end sensores 
....................  
.................... void sentidos() 
.................... { // Define si la persona esta entrando o saliendo 
....................    if ((!sen_ent) && (!sen_sal)) 
*
1C68:  MOVF   5B,F
1C6A:  BNZ   1CB0
1C6C:  MOVF   5C,F
1C6E:  BNZ   1CB0
....................    { 
....................       if (((detec1 == 1) && (detec3 == 1)) || ((detec1 == 1) && (detec5 == 1)) || ((detec3 == 1) && (detec5 == 1))) 
1C70:  DECFSZ x69,W
1C72:  BRA    1C7A
1C74:  DECFSZ x6B,W
1C76:  BRA    1C7A
1C78:  BRA    1C8C
1C7A:  DECFSZ x69,W
1C7C:  BRA    1C84
1C7E:  DECFSZ x6D,W
1C80:  BRA    1C84
1C82:  BRA    1C8C
1C84:  DECFSZ x6B,W
1C86:  BRA    1C90
1C88:  DECFSZ x6D,W
1C8A:  BRA    1C90
....................       { 
....................          sen_ent = 1; 
1C8C:  MOVLW  01
1C8E:  MOVWF  5B
....................          //!      lcd_gotoxy(17,4); 
....................          //!      lcd_putc("Sub"); 
....................       } 
....................       if (((detec2 == 1) && (detec4 == 1)) || ((detec2 == 1) && (detec6 == 1)) || ((detec4 == 1) && (detec6 == 1))) 
1C90:  DECFSZ x6A,W
1C92:  BRA    1C9A
1C94:  DECFSZ x6C,W
1C96:  BRA    1C9A
1C98:  BRA    1CAC
1C9A:  DECFSZ x6A,W
1C9C:  BRA    1CA4
1C9E:  DECFSZ x6E,W
1CA0:  BRA    1CA4
1CA2:  BRA    1CAC
1CA4:  DECFSZ x6C,W
1CA6:  BRA    1CB0
1CA8:  DECFSZ x6E,W
1CAA:  BRA    1CB0
....................       { 
....................          sen_sal = 1; 
1CAC:  MOVLW  01
1CAE:  MOVWF  5C
....................          //!      lcd_gotoxy(17,4); 
....................          //!      lcd_putc("Baj"); 
....................       } 
....................    } 
1CB0:  RETURN 0
.................... } 
....................  
.................... void rd_eeprom() 
.................... { // Revisa si cadena recibida es un instruccion 
....................    a = b = 0; 
....................    n = word_size; // 
....................    // i=0; 
....................    // i=2; 
....................    while ((b <= data_set) && (a == 0)) 
....................    { // NUMERO TOTAL DE INSTRUCCIONES 
....................       i = 0; 
....................       b++; 
....................       while (i < word_size) 
....................       { // word_size=10 
....................          memory[i] = read_eeprom(n + i); 
....................  
....................          if (memory[i] != XX[i]) 
....................             break; 
....................          i++; 
....................          if (i == word_size) 
....................             a = 1; 
....................       } 
....................       // fprintf(monitor,"memory:%s\r",memory); 
....................       n = n + word_size; // WORD_SIZE=30 
....................       restart_wdt(); 
....................    } 
.................... } 
....................  
.................... void rd_eeprom_inicio() 
.................... { // 
....................    a = b = 0; 
....................    n = word_size; // 
....................  
....................    while (b <= data_set) 
....................    { // NUMERO TOTAL DE INSTRUCCIONES 
....................       i = 0; 
....................       b++; 
....................       while (i < word_size) 
....................       { // word_size=10 
....................          memory[i] = read_eeprom(n + i); 
....................          i++; 
....................          if (i == word_size) 
....................             a = 1; 
....................       } 
....................       fprintf(monitor, "memory:%s\r", memory); 
....................       n = n + word_size; // WORD_SIZE=30 
....................       // restart_wdt(); 
....................    } 
.................... } 
....................  
.................... void lcd_cuentas() 
.................... { // Escribe las cuenta en LCD 
....................    lcd_gotoxy(1, 1); 
*
0A18:  MOVLW  01
0A1A:  MOVLB  1
0A1C:  MOVWF  x94
0A1E:  MOVWF  x95
0A20:  MOVLB  0
0A22:  RCALL  0822
....................    if (master) 
0A24:  MOVF   45,F
0A26:  BTFSC  FD8.2
0A28:  BRA    0B48
....................    { 
....................       printf(lcd_putc, "1 %c%c%c%c%c ", version[0], version[1], version[2], version[3], version[4]); 
0A2A:  MOVLW  31
0A2C:  MOVLB  1
0A2E:  MOVWF  x93
0A30:  MOVLB  0
0A32:  RCALL  0874
0A34:  MOVLW  20
0A36:  MOVLB  1
0A38:  MOVWF  x93
0A3A:  MOVLB  0
0A3C:  RCALL  0874
0A3E:  MOVFF  14C,193
0A42:  RCALL  0874
0A44:  MOVFF  14D,193
0A48:  RCALL  0874
0A4A:  MOVFF  14E,193
0A4E:  RCALL  0874
0A50:  MOVFF  14F,193
0A54:  RCALL  0874
0A56:  MOVFF  150,193
0A5A:  RCALL  0874
0A5C:  MOVLW  20
0A5E:  MOVLB  1
0A60:  MOVWF  x93
0A62:  MOVLB  0
0A64:  RCALL  0874
....................       lcd_gotoxy(14, 1); 
0A66:  MOVLW  0E
0A68:  MOVLB  1
0A6A:  MOVWF  x94
0A6C:  MOVLW  01
0A6E:  MOVWF  x95
0A70:  MOVLB  0
0A72:  RCALL  0822
....................       printf(lcd_putc, "S1:%Ld ", entraront); 
0A74:  MOVLW  72
0A76:  MOVWF  FF6
0A78:  MOVLW  03
0A7A:  MOVWF  FF7
0A7C:  MOVLW  03
0A7E:  MOVLB  1
0A80:  MOVWF  x8A
0A82:  MOVLB  0
0A84:  RCALL  08D4
0A86:  MOVLW  10
0A88:  MOVWF  FE9
0A8A:  MOVFF  8B,18B
0A8E:  MOVFF  8A,18A
0A92:  RCALL  08FC
0A94:  MOVLW  20
0A96:  MOVLB  1
0A98:  MOVWF  x93
0A9A:  MOVLB  0
0A9C:  RCALL  0874
....................       lcd_gotoxy(14, 2); 
0A9E:  MOVLW  0E
0AA0:  MOVLB  1
0AA2:  MOVWF  x94
0AA4:  MOVLW  02
0AA6:  MOVWF  x95
0AA8:  MOVLB  0
0AAA:  RCALL  0822
....................       printf(lcd_putc, "B1:%Ld ", salieront); 
0AAC:  MOVLW  7A
0AAE:  MOVWF  FF6
0AB0:  MOVLW  03
0AB2:  MOVWF  FF7
0AB4:  MOVLW  03
0AB6:  MOVLB  1
0AB8:  MOVWF  x8A
0ABA:  MOVLB  0
0ABC:  RCALL  08D4
0ABE:  MOVLW  10
0AC0:  MOVWF  FE9
0AC2:  MOVFF  8D,18B
0AC6:  MOVFF  8C,18A
0ACA:  RCALL  08FC
0ACC:  MOVLW  20
0ACE:  MOVLB  1
0AD0:  MOVWF  x93
0AD2:  MOVLB  0
0AD4:  RCALL  0874
....................       lcd_gotoxy(14, 3); 
0AD6:  MOVLW  0E
0AD8:  MOVLB  1
0ADA:  MOVWF  x94
0ADC:  MOVLW  03
0ADE:  MOVWF  x95
0AE0:  MOVLB  0
0AE2:  RCALL  0822
....................       printf(lcd_putc, "S2:%Ld ", sub_atras); 
0AE4:  MOVLW  82
0AE6:  MOVWF  FF6
0AE8:  MOVLW  03
0AEA:  MOVWF  FF7
0AEC:  MOVLW  03
0AEE:  MOVLB  1
0AF0:  MOVWF  x8A
0AF2:  MOVLB  0
0AF4:  RCALL  08D4
0AF6:  MOVLW  10
0AF8:  MOVWF  FE9
0AFA:  MOVFF  35,18B
0AFE:  MOVFF  34,18A
0B02:  RCALL  08FC
0B04:  MOVLW  20
0B06:  MOVLB  1
0B08:  MOVWF  x93
0B0A:  MOVLB  0
0B0C:  RCALL  0874
....................       lcd_gotoxy(14, 4); 
0B0E:  MOVLW  0E
0B10:  MOVLB  1
0B12:  MOVWF  x94
0B14:  MOVLW  04
0B16:  MOVWF  x95
0B18:  MOVLB  0
0B1A:  RCALL  0822
....................       printf(lcd_putc, "B2:%Ld ", baj_atras); 
0B1C:  MOVLW  8A
0B1E:  MOVWF  FF6
0B20:  MOVLW  03
0B22:  MOVWF  FF7
0B24:  MOVLW  03
0B26:  MOVLB  1
0B28:  MOVWF  x8A
0B2A:  MOVLB  0
0B2C:  RCALL  08D4
0B2E:  MOVLW  10
0B30:  MOVWF  FE9
0B32:  MOVFF  37,18B
0B36:  MOVFF  36,18A
0B3A:  RCALL  08FC
0B3C:  MOVLW  20
0B3E:  MOVLB  1
0B40:  MOVWF  x93
0B42:  MOVLB  0
0B44:  RCALL  0874
....................    } 
0B46:  BRA    0C24
....................    else 
....................    { 
....................       printf(lcd_putc, "2 %c%c%c%c%c ", version[0], version[1], version[2], version[3], version[4]); 
0B48:  MOVLW  32
0B4A:  MOVLB  1
0B4C:  MOVWF  x93
0B4E:  MOVLB  0
0B50:  RCALL  0874
0B52:  MOVLW  20
0B54:  MOVLB  1
0B56:  MOVWF  x93
0B58:  MOVLB  0
0B5A:  RCALL  0874
0B5C:  MOVFF  14C,193
0B60:  RCALL  0874
0B62:  MOVFF  14D,193
0B66:  RCALL  0874
0B68:  MOVFF  14E,193
0B6C:  RCALL  0874
0B6E:  MOVFF  14F,193
0B72:  RCALL  0874
0B74:  MOVFF  150,193
0B78:  RCALL  0874
0B7A:  MOVLW  20
0B7C:  MOVLB  1
0B7E:  MOVWF  x93
0B80:  MOVLB  0
0B82:  RCALL  0874
....................       lcd_gotoxy(14, 1); 
0B84:  MOVLW  0E
0B86:  MOVLB  1
0B88:  MOVWF  x94
0B8A:  MOVLW  01
0B8C:  MOVWF  x95
0B8E:  MOVLB  0
0B90:  RCALL  0822
....................       lcd_putc("S1:    "); 
0B92:  MOVLW  92
0B94:  MOVWF  FF6
0B96:  MOVLW  03
0B98:  MOVWF  FF7
0B9A:  RCALL  09F8
....................       lcd_gotoxy(14, 2); 
0B9C:  MOVLW  0E
0B9E:  MOVLB  1
0BA0:  MOVWF  x94
0BA2:  MOVLW  02
0BA4:  MOVWF  x95
0BA6:  MOVLB  0
0BA8:  RCALL  0822
....................       lcd_putc("B1:    "); 
0BAA:  MOVLW  9A
0BAC:  MOVWF  FF6
0BAE:  MOVLW  03
0BB0:  MOVWF  FF7
0BB2:  RCALL  09F8
....................       lcd_gotoxy(14, 3); 
0BB4:  MOVLW  0E
0BB6:  MOVLB  1
0BB8:  MOVWF  x94
0BBA:  MOVLW  03
0BBC:  MOVWF  x95
0BBE:  MOVLB  0
0BC0:  RCALL  0822
....................       printf(lcd_putc, "S2:%Ld ", entraront); 
0BC2:  MOVLW  A2
0BC4:  MOVWF  FF6
0BC6:  MOVLW  03
0BC8:  MOVWF  FF7
0BCA:  MOVLW  03
0BCC:  MOVLB  1
0BCE:  MOVWF  x8A
0BD0:  MOVLB  0
0BD2:  RCALL  08D4
0BD4:  MOVLW  10
0BD6:  MOVWF  FE9
0BD8:  MOVFF  8B,18B
0BDC:  MOVFF  8A,18A
0BE0:  RCALL  08FC
0BE2:  MOVLW  20
0BE4:  MOVLB  1
0BE6:  MOVWF  x93
0BE8:  MOVLB  0
0BEA:  RCALL  0874
....................       lcd_gotoxy(14, 4); 
0BEC:  MOVLW  0E
0BEE:  MOVLB  1
0BF0:  MOVWF  x94
0BF2:  MOVLW  04
0BF4:  MOVWF  x95
0BF6:  MOVLB  0
0BF8:  RCALL  0822
....................       printf(lcd_putc, "B2:%Ld ", salieront); 
0BFA:  MOVLW  AA
0BFC:  MOVWF  FF6
0BFE:  MOVLW  03
0C00:  MOVWF  FF7
0C02:  MOVLW  03
0C04:  MOVLB  1
0C06:  MOVWF  x8A
0C08:  MOVLB  0
0C0A:  RCALL  08D4
0C0C:  MOVLW  10
0C0E:  MOVWF  FE9
0C10:  MOVFF  8D,18B
0C14:  MOVFF  8C,18A
0C18:  RCALL  08FC
0C1A:  MOVLW  20
0C1C:  MOVLB  1
0C1E:  MOVWF  x93
0C20:  MOVLB  0
0C22:  RCALL  0874
....................    } 
0C24:  RETURN 0
.................... } 
....................  
.................... void write_ent() 
.................... { // Graba en eeprom las subidas del poste 
....................    disable_interrupts(GLOBAL); 
*
0C64:  BCF    FF2.6
0C66:  BCF    FF2.7
0C68:  BTFSC  FF2.7
0C6A:  BRA    0C66
....................    write_ext_eeprom(2, entraront);        // parte baja 
0C6C:  MOVLB  1
0C6E:  CLRF   x8F
0C70:  MOVLW  02
0C72:  MOVWF  x8E
0C74:  MOVFF  8A,190
0C78:  MOVLB  0
0C7A:  RCALL  0568
....................    write_ext_eeprom(1, (entraront >> 8)); // parte alta 
0C7C:  MOVFF  8B,18A
0C80:  MOVLB  1
0C82:  CLRF   x8B
0C84:  CLRF   x8F
0C86:  MOVLW  01
0C88:  MOVWF  x8E
0C8A:  MOVFF  8B,190
0C8E:  MOVLB  0
0C90:  RCALL  0568
....................    enable_interrupts(GLOBAL); 
0C92:  MOVLW  C0
0C94:  IORWF  FF2,F
....................    finsuma(); 
0C96:  RCALL  0C26
0C98:  RETURN 0
.................... } 
....................  
.................... void write_sal() 
.................... { // Graba en eeprom las bajadas del poste 
....................    disable_interrupts(GLOBAL); 
0C9A:  BCF    FF2.6
0C9C:  BCF    FF2.7
0C9E:  BTFSC  FF2.7
0CA0:  BRA    0C9C
....................    write_ext_eeprom(4, salieront);        // parte baja 
0CA2:  MOVLB  1
0CA4:  CLRF   x8F
0CA6:  MOVLW  04
0CA8:  MOVWF  x8E
0CAA:  MOVFF  8C,190
0CAE:  MOVLB  0
0CB0:  RCALL  0568
....................    write_ext_eeprom(3, (salieront >> 8)); // parte alta 
0CB2:  MOVFF  8D,18A
0CB6:  MOVLB  1
0CB8:  CLRF   x8B
0CBA:  CLRF   x8F
0CBC:  MOVLW  03
0CBE:  MOVWF  x8E
0CC0:  MOVFF  8D,190
0CC4:  MOVLB  0
0CC6:  RCALL  0568
....................    enable_interrupts(GLOBAL); 
0CC8:  MOVLW  C0
0CCA:  IORWF  FF2,F
....................    finsuma(); 
0CCC:  RCALL  0C26
0CCE:  RETURN 0
.................... } 
....................  
.................... void entraron_total() 
.................... { // Graba en eeprom el total de subidas 
....................    disable_interrupts(GLOBAL); 
*
0D3C:  BCF    FF2.6
0D3E:  BCF    FF2.7
0D40:  BTFSC  FF2.7
0D42:  BRA    0D3E
....................    unsigned int reg_h = 0, reg_l = 0; 
....................    unsigned int16 total = 0; 
0D44:  MOVLB  1
0D46:  CLRF   x8A
0D48:  CLRF   x8B
0D4A:  CLRF   x8D
0D4C:  CLRF   x8C
....................  
....................    reg_h = read_ext_eeprom(1); 
0D4E:  CLRF   x8F
0D50:  MOVLW  01
0D52:  MOVWF  x8E
0D54:  MOVLB  0
0D56:  RCALL  0728
0D58:  MOVFF  01,18A
....................    reg_l = read_ext_eeprom(2); 
0D5C:  MOVLB  1
0D5E:  CLRF   x8F
0D60:  MOVLW  02
0D62:  MOVWF  x8E
0D64:  MOVLB  0
0D66:  RCALL  0728
0D68:  MOVFF  01,18B
....................    total = reg_h; 
0D6C:  MOVLB  1
0D6E:  CLRF   x8D
0D70:  MOVFF  18A,18C
....................    total = (total << 8) | reg_l; 
0D74:  MOVFF  18C,18F
0D78:  CLRF   x8E
0D7A:  MOVF   x8E,W
0D7C:  IORWF  x8B,W
0D7E:  MOVWF  x8C
0D80:  MOVFF  18F,18D
....................    entraront = total; 
0D84:  MOVFF  18D,8B
0D88:  MOVFF  18C,8A
....................    enable_interrupts(GLOBAL); 
0D8C:  MOVLW  C0
0D8E:  IORWF  FF2,F
0D90:  MOVLB  0
0D92:  GOTO   2D06 (RETURN)
.................... } 
....................  
.................... void salieron_total() 
.................... { // Graba en eeprom el total de bajadas 
....................    disable_interrupts(GLOBAL); 
0D96:  BCF    FF2.6
0D98:  BCF    FF2.7
0D9A:  BTFSC  FF2.7
0D9C:  BRA    0D98
....................    unsigned int reg_h = 0, reg_l = 0; 
....................    unsigned int16 total = 0; 
0D9E:  MOVLB  1
0DA0:  CLRF   x8A
0DA2:  CLRF   x8B
0DA4:  CLRF   x8D
0DA6:  CLRF   x8C
....................  
....................    reg_h = read_ext_eeprom(3); 
0DA8:  CLRF   x8F
0DAA:  MOVLW  03
0DAC:  MOVWF  x8E
0DAE:  MOVLB  0
0DB0:  RCALL  0728
0DB2:  MOVFF  01,18A
....................    reg_l = read_ext_eeprom(4); 
0DB6:  MOVLB  1
0DB8:  CLRF   x8F
0DBA:  MOVLW  04
0DBC:  MOVWF  x8E
0DBE:  MOVLB  0
0DC0:  RCALL  0728
0DC2:  MOVFF  01,18B
....................    total = reg_h; 
0DC6:  MOVLB  1
0DC8:  CLRF   x8D
0DCA:  MOVFF  18A,18C
....................    total = (total << 8) | reg_l; 
0DCE:  MOVFF  18C,18F
0DD2:  CLRF   x8E
0DD4:  MOVF   x8E,W
0DD6:  IORWF  x8B,W
0DD8:  MOVWF  x8C
0DDA:  MOVFF  18F,18D
....................    salieront = total; 
0DDE:  MOVFF  18D,8D
0DE2:  MOVFF  18C,8C
....................    enable_interrupts(GLOBAL); 
0DE6:  MOVLW  C0
0DE8:  IORWF  FF2,F
0DEA:  MOVLB  0
0DEC:  GOTO   2D0A (RETURN)
.................... } 
....................  
.................... void graba_conta2() 
.................... { // Graba en eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
066E:  BCF    FF2.6
0670:  BCF    FF2.7
0672:  BTFSC  FF2.7
0674:  BRA    0670
....................    unsigned int reg_hc = 0, reg_lc = 0; 
....................    unsigned int16 totalc = 0; 
0676:  MOVLB  1
0678:  CLRF   x8A
067A:  CLRF   x8B
067C:  CLRF   x8D
067E:  CLRF   x8C
....................    totalc = 0; 
0680:  CLRF   x8D
0682:  CLRF   x8C
....................    reg_lc = 0; 
0684:  CLRF   x8B
....................    reg_hc = 0; 
0686:  CLRF   x8A
....................  
....................    totalc = salian; 
0688:  MOVFF  3D,18D
068C:  MOVFF  3C,18C
....................    reg_lc = totalc; 
0690:  MOVFF  18C,18B
....................    reg_hc = totalc >> 8; 
0694:  MOVFF  18D,18A
....................    write_ext_eeprom(20, reg_hc); 
0698:  CLRF   x8F
069A:  MOVLW  14
069C:  MOVWF  x8E
069E:  MOVFF  18A,190
06A2:  MOVLB  0
06A4:  RCALL  0568
....................    write_ext_eeprom(21, reg_lc); 
06A6:  MOVLB  1
06A8:  CLRF   x8F
06AA:  MOVLW  15
06AC:  MOVWF  x8E
06AE:  MOVFF  18B,190
06B2:  MOVLB  0
06B4:  RCALL  0568
....................    enable_interrupts(GLOBAL); 
06B6:  MOVLW  C0
06B8:  IORWF  FF2,F
06BA:  RETURN 0
.................... } 
....................  
.................... void leer_conta2() 
.................... { // Carga de eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
07D0:  BCF    FF2.6
07D2:  BCF    FF2.7
07D4:  BTFSC  FF2.7
07D6:  BRA    07D2
....................    unsigned int reg_hc = 0, reg_lc = 0; 
....................    unsigned int16 totalc = 0; 
07D8:  MOVLB  1
07DA:  CLRF   x8A
07DC:  CLRF   x8B
07DE:  CLRF   x8D
07E0:  CLRF   x8C
....................  
....................    reg_hc = read_ext_eeprom(20); 
07E2:  CLRF   x8F
07E4:  MOVLW  14
07E6:  MOVWF  x8E
07E8:  MOVLB  0
07EA:  RCALL  0728
07EC:  MOVFF  01,18A
....................    reg_lc = read_ext_eeprom(21); 
07F0:  MOVLB  1
07F2:  CLRF   x8F
07F4:  MOVLW  15
07F6:  MOVWF  x8E
07F8:  MOVLB  0
07FA:  RCALL  0728
07FC:  MOVFF  01,18B
....................    totalc = reg_hc; 
0800:  MOVLB  1
0802:  CLRF   x8D
0804:  MOVFF  18A,18C
....................    totalc = totalc << 8; 
0808:  MOVFF  18C,18D
080C:  CLRF   x8C
....................    totalc = totalc | reg_lc; 
080E:  MOVF   x8B,W
0810:  IORWF  x8C,F
....................    salian = totalc; 
0812:  MOVFF  18D,3D
0816:  MOVFF  18C,3C
....................    enable_interrupts(GLOBAL); 
081A:  MOVLW  C0
081C:  IORWF  FF2,F
081E:  MOVLB  0
0820:  RETURN 0
.................... } 
....................  
.................... void reset() 
.................... { 
....................    switch (restart_cause()) 
*
0E12:  MOVF   FD0,W
0E14:  ANDLW  0F
0E16:  BTFSS  FD0.4
0E18:  MOVLW  00
0E1A:  BSF    FD0.0
0E1C:  BSF    FD0.1
0E1E:  BSF    FD0.4
0E20:  BSF    FD8.3
0E22:  BSF    FD8.4
0E24:  XORLW  07
0E26:  BZ    0E36
0E28:  XORLW  08
0E2A:  BZ    0E38
0E2C:  XORLW  01
0E2E:  BZ    0E44
0E30:  XORLW  02
0E32:  BZ    0E46
0E34:  BRA    0E46
....................    { 
....................    case WDT_TIMEOUT: 
....................    { // lcd_putc("REINICIO-WD");// 
....................       break; 
0E36:  BRA    0E46
....................    } 
....................    case MCLR_FROM_RUN: // avisa que reinicio por master clear 
....................    { 
....................       fprintf(monitor, "SERIALTEST\r"); 
0E38:  MOVLW  B2
0E3A:  MOVWF  FF6
0E3C:  MOVLW  03
0E3E:  MOVWF  FF7
0E40:  RCALL  0DF0
....................       // fprintf(monitor,"0\r"); 
....................       break; 
0E42:  BRA    0E46
....................    } 
....................    case BROWNOUT_RESTART: // avisa que el pic reinicio por un voltaje menor a 4v 
....................    { 
....................       break; 
0E44:  BRA    0E46
....................    } 
....................    case NORMAL_POWER_UP: 
....................    { 
....................       break; 
....................    } // END MODO 
....................    } 
0E46:  GOTO   2DE8 (RETURN)
.................... } 
....................  
.................... int evaluar_string(char *command[]) 
*
0F3A:  MOVLB  1
0F3C:  CLRF   x8C
.................... { 
....................    int conteo_command = 0; 
....................    int iresult; 
....................    while (conteo_command <= 10) 
0F3E:  MOVF   x8C,W
0F40:  SUBLW  0A
0F42:  BNC   0F8A
....................    { 
....................       iresult = strcoll(textosearch[conteo_command], command); 
0F44:  CLRF   03
0F46:  MOVFF  18C,02
0F4A:  BCF    FD8.0
0F4C:  RLCF   02,F
0F4E:  RLCF   03,F
0F50:  MOVF   02,W
0F52:  ADDLW  B2
0F54:  MOVWF  FE9
0F56:  MOVLW  00
0F58:  ADDWFC 03,W
0F5A:  MOVWF  FEA
0F5C:  MOVFF  FEC,18F
0F60:  MOVF   FED,F
0F62:  MOVFF  FEF,18E
0F66:  MOVFF  18F,191
0F6A:  MOVFF  18E,190
0F6E:  MOVFF  18B,193
0F72:  MOVFF  18A,192
0F76:  MOVLB  0
0F78:  BRA    0EC0
0F7A:  MOVFF  01,18D
....................       if (iresult == 0) 
0F7E:  MOVLB  1
0F80:  MOVF   x8D,F
0F82:  BNZ   0F86
....................       { 
....................          break; 
0F84:  BRA    0F8A
....................       } 
....................       conteo_command++; 
0F86:  INCF   x8C,F
0F88:  BRA    0F3E
....................    } 
....................  
....................    return conteo_command; 
0F8A:  MOVFF  18C,01
0F8E:  MOVLB  0
0F90:  GOTO   2EF6 (RETURN)
.................... } 
....................  
....................  
.................... void cuenta_pulsos() 
.................... { // Pulsos de subida para impresion (flanco alto) 
....................    output_high(salida03); 
*
152E:  BCF    F94.5
1530:  BSF    F8B.5
....................    rev_suben(); 
1532:  RCALL  1528
....................    time_s3 = 0; 
1534:  CLRF   xAF
....................    fls3 = 1; 
1536:  MOVLW  01
1538:  MOVWF  xB0
....................    cta_pulsos++; 
153A:  INCF   xB1,F
153C:  RETURN 0
.................... } 
....................  
.................... void rev_suben() 
.................... { 
....................    if (!master) 
*
1528:  MOVF   45,F
152A:  BNZ   152C
....................    { 
....................       //fprintf(monitor, "SUBIENDOC2\r"); // 
....................    } 
152C:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 181E   PUT BROWNOUT BORV21 NOWDT WDT4096
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
