CCS PCH C Compiler, Version 5.025, 24934               16-may.-22 08:52

               Filename:   D:\PROYECTOS\TRANSPORTE\CONTADORES\3 en 1\BIA-DISPLAY\CONTADOR\MASTER\CONTADOR_V1.0.lst

               ROM used:   13274 bytes (41%)
                           Largest free fragment is 19490
               RAM used:   465 (30%) at main() level
                           490 (32%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2B52
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0232
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   010A
006C:  BTFSS  FA0.1
006E:  GOTO   0078
0072:  BTFSC  FA1.1
0074:  GOTO   01C0
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
....................  
.................... #include <18F4580.h> 
.................... //////////// Standard Header file for the PIC18F4580 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4580 
00C6:  CLRF   FF7
00C8:  ADDLW  D6
00CA:  MOVWF  FF6
00CC:  MOVLW  00
00CE:  ADDWFC FF7,F
00D0:  TBLRD*+
00D2:  MOVF   FF5,W
00D4:  RETURN 0
00D6:  DATA 28,0C
00D8:  DATA 01,06
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 42,4F
00EC:  DATA 52,52
00EE:  DATA 41,52
00F0:  DATA 5F,41
00F2:  DATA 4C,4C
00F4:  DATA 0D,00
00F6:  CLRF   FF7
00F8:  ADDLW  06
00FA:  MOVWF  FF6
00FC:  MOVLW  01
00FE:  ADDWFC FF7,F
0100:  TBLRD*+
0102:  MOVF   FF5,W
0104:  RETURN 0
0106:  DATA 3A,2F
0108:  DATA 00,00
*
028C:  DATA 0C,42
028E:  DATA 4F,52
0290:  DATA 52,41
0292:  DATA 52,5F
0294:  DATA 41,4C
0296:  DATA 4C,00
0298:  DATA 42,4F
029A:  DATA 52,52
029C:  DATA 41,52
029E:  DATA 5F,41
02A0:  DATA 4C,4C
02A2:  DATA 0D,00
02A4:  DATA 52,45
02A6:  DATA 53,45
02A8:  DATA 54,5F
02AA:  DATA 4F,4B
02AC:  DATA 0D,0A
02AE:  DATA 00,00
02B0:  DATA 52,45
02B2:  DATA 53,45
02B4:  DATA 54,5F
02B6:  DATA 4F,4B
02B8:  DATA 0D,0A
02BA:  DATA 00,00
02BC:  DATA 42,4F
02BE:  DATA 52,52
02C0:  DATA 41,52
02C2:  DATA 5F,41
02C4:  DATA 4C,4C
02C6:  DATA 0D,00
02C8:  DATA 43,32
02CA:  DATA 4F,4B
02CC:  DATA 00,00
02CE:  DATA 43,31
02D0:  DATA 4F,4B
02D2:  DATA 00,00
02D4:  DATA 53,45
02D6:  DATA 52,49
02D8:  DATA 41,4C
02DA:  DATA 5F,54
02DC:  DATA 4F,4B
02DE:  DATA 0D,00
02E0:  DATA 43,32
02E2:  DATA 4F,4B
02E4:  DATA 00,00
02E6:  DATA 53,75
02E8:  DATA 62,32
02EA:  DATA 00,00
02EC:  DATA 63,3D
02EE:  DATA 30,00
02F0:  DATA 20,20
02F2:  DATA 20,20
02F4:  DATA 00,00
02F6:  DATA 20,20
02F8:  DATA 20,20
02FA:  DATA 00,00
02FC:  DATA 20,20
02FE:  DATA 20,20
0300:  DATA 00,00
0302:  DATA 42,4C
0304:  DATA 00,00
0306:  DATA 42,4C
0308:  DATA 00,00
030A:  DATA 42,4C
030C:  DATA 00,00
030E:  DATA 20,20
0310:  DATA 00,00
0312:  DATA 53,4F
0314:  DATA 4C,49
0316:  DATA 43,49
0318:  DATA 54,41
031A:  DATA 44,4F
031C:  DATA 0D,00
031E:  DATA 50,41
0320:  DATA 53,41
0322:  DATA 4A,45
0324:  DATA 52,4F
0326:  DATA 53,3A
0328:  DATA 0D,00
032A:  DATA 53,32
032C:  DATA 3A,25
032E:  DATA 4C,64
0330:  DATA 20,00
0332:  DATA 42,32
0334:  DATA 3A,25
0336:  DATA 4C,64
0338:  DATA 20,00
033A:  DATA 41,43
033C:  DATA 43,2B
033E:  DATA 30,31
0340:  DATA 3A,25
0342:  DATA 30,34
0344:  DATA 4C,75
0346:  DATA 2C,25
0348:  DATA 30,34
034A:  DATA 4C,75
034C:  DATA 2C,25
034E:  DATA 30,34
0350:  DATA 4C,75
0352:  DATA 2C,25
0354:  DATA 30,33
0356:  DATA 4C,75
0358:  DATA 2C,25
035A:  DATA 30,33
035C:  DATA 4C,75
035E:  DATA 2C,25
0360:  DATA 30,32
0362:  DATA 75,2C
0364:  DATA 0D,0A
0366:  DATA 00,00
0368:  DATA 41,43
036A:  DATA 43,2B
036C:  DATA 30,31
036E:  DATA 3A,25
0370:  DATA 30,34
0372:  DATA 4C,75
0374:  DATA 2C,25
0376:  DATA 30,34
0378:  DATA 4C,75
037A:  DATA 2C,44
037C:  DATA 45,53
037E:  DATA 43,2C
0380:  DATA 25,30
0382:  DATA 33,4C
0384:  DATA 75,2C
0386:  DATA 30,30
0388:  DATA 30,2C
038A:  DATA 25,30
038C:  DATA 32,75
038E:  DATA 2C,0D
0390:  DATA 0A,00
0392:  DATA 44,45
0394:  DATA 53,43
0396:  DATA 00,00
0398:  DATA 0C,00
039A:  DATA 20,00
039C:  DATA 20,00
039E:  DATA 20,00
03A0:  DATA 20,00
03A2:  DATA 20,00
03A4:  DATA 20,00
03A6:  DATA 20,00
03A8:  DATA 20,00
03AA:  DATA 20,00
03AC:  DATA 20,00
03AE:  DATA 20,00
03B0:  DATA 20,00
03B2:  DATA 6D,65
03B4:  DATA 6D,6F
03B6:  DATA 72,79
03B8:  DATA 3A,25
03BA:  DATA 73,0D
03BC:  DATA 00,00
03BE:  DATA 53,31
03C0:  DATA 3A,25
03C2:  DATA 4C,64
03C4:  DATA 20,00
03C6:  DATA 42,31
03C8:  DATA 3A,25
03CA:  DATA 4C,64
03CC:  DATA 20,00
03CE:  DATA 53,32
03D0:  DATA 3A,25
03D2:  DATA 4C,64
03D4:  DATA 20,00
03D6:  DATA 42,32
03D8:  DATA 3A,25
03DA:  DATA 4C,64
03DC:  DATA 20,00
03DE:  DATA 53,31
03E0:  DATA 3A,20
03E2:  DATA 20,20
03E4:  DATA 20,00
03E6:  DATA 42,31
03E8:  DATA 3A,20
03EA:  DATA 20,20
03EC:  DATA 20,00
03EE:  DATA 53,32
03F0:  DATA 3A,25
03F2:  DATA 4C,64
03F4:  DATA 20,00
03F6:  DATA 42,32
03F8:  DATA 3A,25
03FA:  DATA 4C,64
03FC:  DATA 20,00
03FE:  DATA 53,45
0400:  DATA 52,49
0402:  DATA 41,4C
0404:  DATA 54,45
0406:  DATA 53,54
0408:  DATA 0D,0A
040A:  DATA 00,00
040C:  DATA 53,55
040E:  DATA 42,49
0410:  DATA 45,4E
0412:  DATA 44,4F
0414:  DATA 43,32
0416:  DATA 00,00
*
092E:  TBLRD*+
0930:  MOVFF  FF6,1D2
0934:  MOVFF  FF7,1D3
0938:  MOVFF  FF5,1DA
093C:  RCALL  08CE
093E:  MOVFF  1D2,FF6
0942:  MOVFF  1D3,FF7
0946:  MOVLB  1
0948:  DECFSZ xD1,F
094A:  BRA    094E
094C:  BRA    0952
094E:  MOVLB  0
0950:  BRA    092E
0952:  MOVLB  0
0954:  RETURN 0
0956:  MOVFF  FEA,1D9
095A:  MOVFF  FE9,1D8
095E:  MOVLB  1
0960:  BTFSS  xD2.7
0962:  BRA    0974
0964:  BSF    xD8.7
0966:  BTFSS  xD8.4
0968:  INCF   xD8,F
096A:  COMF   xD1,F
096C:  COMF   xD2,F
096E:  INCF   xD1,F
0970:  BTFSC  FD8.2
0972:  INCF   xD2,F
0974:  SWAPF  xD2,W
0976:  IORLW  F0
0978:  MOVWF  xD4
097A:  ADDWF  xD4,F
097C:  ADDLW  E2
097E:  MOVWF  xD5
0980:  ADDLW  32
0982:  MOVWF  xD7
0984:  MOVF   xD2,W
0986:  ANDLW  0F
0988:  ADDWF  xD5,F
098A:  ADDWF  xD5,F
098C:  ADDWF  xD7,F
098E:  ADDLW  E9
0990:  MOVWF  xD6
0992:  ADDWF  xD6,F
0994:  ADDWF  xD6,F
0996:  SWAPF  xD1,W
0998:  ANDLW  0F
099A:  ADDWF  xD6,F
099C:  ADDWF  xD7,F
099E:  RLCF   xD6,F
09A0:  RLCF   xD7,F
09A2:  COMF   xD7,F
09A4:  RLCF   xD7,F
09A6:  MOVF   xD1,W
09A8:  ANDLW  0F
09AA:  ADDWF  xD7,F
09AC:  RLCF   xD4,F
09AE:  MOVLW  07
09B0:  MOVWF  xD3
09B2:  MOVLW  0A
09B4:  DECF   xD6,F
09B6:  ADDWF  xD7,F
09B8:  BNC   09B4
09BA:  DECF   xD5,F
09BC:  ADDWF  xD6,F
09BE:  BNC   09BA
09C0:  DECF   xD4,F
09C2:  ADDWF  xD5,F
09C4:  BNC   09C0
09C6:  DECF   xD3,F
09C8:  ADDWF  xD4,F
09CA:  BNC   09C6
09CC:  MOVLW  01
09CE:  MOVWF  FEA
09D0:  MOVLW  D3
09D2:  MOVWF  FE9
09D4:  MOVLW  07
09D6:  ANDWF  xD8,W
09D8:  BCF    xD8.6
09DA:  MOVF   FED,F
09DC:  ANDWF  xD8,W
09DE:  BNZ   09EE
09E0:  BTFSC  xD8.4
09E2:  MOVF   FEE,F
09E4:  BTFSC  xD8.4
09E6:  BRA    09EE
09E8:  MOVLW  20
09EA:  MOVWF  00
09EC:  BRA    0A2E
09EE:  ADDWF  FE9,F
09F0:  MOVLW  00
09F2:  ADDWFC FEA,F
09F4:  MOVF   FE9,W
09F6:  SUBLW  D7
09F8:  BNZ   0A00
09FA:  DECFSZ FEA,W
09FC:  BRA    0A00
09FE:  BSF    xD8.6
0A00:  MOVF   FEF,W
0A02:  MOVWF  00
0A04:  BNZ   0A16
0A06:  BTFSC  xD8.6
0A08:  BRA    0A16
0A0A:  BTFSC  xD8.4
0A0C:  BRA    0A48
0A0E:  BTFSC  xD8.3
0A10:  BRA    0A16
0A12:  MOVLW  20
0A14:  BRA    0A2C
0A16:  BTFSS  xD8.7
0A18:  BRA    0A26
0A1A:  MOVLW  2D
0A1C:  MOVWF  00
0A1E:  MOVF   FED,W
0A20:  BCF    xD8.6
0A22:  BCF    xD8.7
0A24:  BRA    0A2E
0A26:  BSF    xD8.3
0A28:  BCF    xD8.4
0A2A:  MOVLW  30
0A2C:  ADDWF  00,F
0A2E:  MOVFF  FEA,1D2
0A32:  MOVFF  FE9,1D1
0A36:  MOVFF  00,1DA
0A3A:  MOVLB  0
0A3C:  RCALL  08CE
0A3E:  MOVFF  1D2,FEA
0A42:  MOVFF  1D1,FE9
0A46:  MOVLB  1
0A48:  MOVF   FEE,W
0A4A:  BTFSS  xD8.6
0A4C:  BRA    09F4
0A4E:  MOVLB  0
0A50:  RETURN 0
0A52:  TBLRD*+
0A54:  MOVF   FF5,F
0A56:  BZ    0A70
0A58:  MOVFF  FF6,1D0
0A5C:  MOVFF  FF7,1D1
0A60:  MOVFF  FF5,1DA
0A64:  RCALL  08CE
0A66:  MOVFF  1D0,FF6
0A6A:  MOVFF  1D1,FF7
0A6E:  BRA    0A52
0A70:  RETURN 0
*
0E4A:  TBLRD*+
0E4C:  MOVF   FF5,F
0E4E:  BZ    0E6A
0E50:  MOVFF  FF6,1D2
0E54:  MOVFF  FF7,1D3
0E58:  MOVF   FF5,W
0E5A:  BTFSS  F9E.4
0E5C:  BRA    0E5A
0E5E:  MOVWF  FAD
0E60:  MOVFF  1D2,FF6
0E64:  MOVFF  1D3,FF7
0E68:  BRA    0E4A
0E6A:  RETURN 0
*
1024:  MOVLB  1
1026:  MOVF   xD7,W
1028:  CLRF   01
102A:  SUBWF  xD6,W
102C:  BC    1034
102E:  MOVFF  1D6,00
1032:  BRA    104C
1034:  CLRF   00
1036:  MOVLW  08
1038:  MOVWF  xD8
103A:  RLCF   xD6,F
103C:  RLCF   00,F
103E:  MOVF   xD7,W
1040:  SUBWF  00,W
1042:  BTFSC  FD8.0
1044:  MOVWF  00
1046:  RLCF   01,F
1048:  DECFSZ xD8,F
104A:  BRA    103A
104C:  MOVLB  0
104E:  RETURN 0
1050:  MOVLW  20
1052:  MOVLB  1
1054:  BTFSS  xD1.4
1056:  MOVLW  30
1058:  MOVWF  xD2
105A:  MOVFF  1D0,00
105E:  BTFSS  xD0.7
1060:  BRA    1072
1062:  COMF   00,F
1064:  INCF   00,F
1066:  MOVFF  00,1D0
106A:  MOVLW  2D
106C:  MOVWF  xD2
106E:  BSF    xD1.7
1070:  BSF    xD1.0
1072:  MOVF   01,W
1074:  MOVFF  1D0,1D6
1078:  MOVLW  64
107A:  MOVWF  xD7
107C:  MOVLB  0
107E:  RCALL  1024
1080:  MOVFF  00,1D0
1084:  MOVLW  30
1086:  ADDWF  01,W
1088:  MOVLB  1
108A:  MOVWF  xD3
108C:  MOVFF  1D0,1D6
1090:  MOVLW  0A
1092:  MOVWF  xD7
1094:  MOVLB  0
1096:  RCALL  1024
1098:  MOVLW  30
109A:  ADDWF  00,W
109C:  MOVLB  1
109E:  MOVWF  xD5
10A0:  MOVLW  30
10A2:  ADDWF  01,W
10A4:  MOVWF  xD4
10A6:  MOVFF  1D2,00
10AA:  MOVLW  30
10AC:  SUBWF  xD3,W
10AE:  BZ    10B8
10B0:  BSF    xD1.1
10B2:  BTFSC  xD1.7
10B4:  BSF    xD1.2
10B6:  BRA    10DC
10B8:  MOVFF  1D2,1D3
10BC:  MOVLW  20
10BE:  MOVWF  xD2
10C0:  MOVLW  30
10C2:  SUBWF  xD4,W
10C4:  BZ    10CE
10C6:  BSF    xD1.0
10C8:  BTFSC  xD1.7
10CA:  BSF    xD1.1
10CC:  BRA    10DC
10CE:  BTFSS  FD8.2
10D0:  BSF    xD1.0
10D2:  BNZ   10DC
10D4:  MOVFF  1D3,1D4
10D8:  MOVLW  20
10DA:  MOVWF  xD3
10DC:  BTFSC  xD1.2
10DE:  BRA    10EA
10E0:  BTFSC  xD1.1
10E2:  BRA    10F4
10E4:  BTFSC  xD1.0
10E6:  BRA    10FE
10E8:  BRA    1108
10EA:  MOVFF  1D2,1DA
10EE:  MOVLB  0
10F0:  CALL   08CE
10F4:  MOVFF  1D3,1DA
10F8:  MOVLB  0
10FA:  CALL   08CE
10FE:  MOVFF  1D4,1DA
1102:  MOVLB  0
1104:  CALL   08CE
1108:  MOVFF  1D5,1DA
110C:  MOVLB  0
110E:  CALL   08CE
1112:  RETURN 0
*
1162:  TBLRD*+
1164:  MOVF   FF5,F
1166:  BZ    1180
1168:  MOVFF  FF6,1D0
116C:  MOVFF  FF7,1D1
1170:  MOVFF  FF5,1D9
1174:  RCALL  1114
1176:  MOVFF  1D0,FF6
117A:  MOVFF  1D1,FF7
117E:  BRA    1162
1180:  RETURN 0
*
11F0:  TSTFSZ 01
11F2:  BRA    11FA
11F4:  TSTFSZ 02
11F6:  BRA    11FC
11F8:  BRA    1208
11FA:  INCF   02,F
11FC:  MOVFF  00,FEE
1200:  DECFSZ 01,F
1202:  BRA    11FC
1204:  DECFSZ 02,F
1206:  BRA    11FC
1208:  RETURN 0
*
18D8:  TBLRD*+
18DA:  MOVFF  FF6,1D1
18DE:  MOVFF  FF7,1D2
18E2:  MOVFF  FF5,1D9
18E6:  RCALL  1114
18E8:  MOVFF  1D1,FF6
18EC:  MOVFF  1D2,FF7
18F0:  MOVLB  1
18F2:  DECFSZ xD0,F
18F4:  BRA    18F8
18F6:  BRA    18FC
18F8:  MOVLB  0
18FA:  BRA    18D8
18FC:  MOVLB  0
18FE:  RETURN 0
1900:  MOVFF  FEA,1D8
1904:  MOVFF  FE9,1D7
1908:  MOVLB  1
190A:  SWAPF  xD1,W
190C:  IORLW  F0
190E:  MOVWF  xD3
1910:  ADDWF  xD3,F
1912:  ADDLW  E2
1914:  MOVWF  xD4
1916:  ADDLW  32
1918:  MOVWF  xD6
191A:  MOVF   xD1,W
191C:  ANDLW  0F
191E:  ADDWF  xD4,F
1920:  ADDWF  xD4,F
1922:  ADDWF  xD6,F
1924:  ADDLW  E9
1926:  MOVWF  xD5
1928:  ADDWF  xD5,F
192A:  ADDWF  xD5,F
192C:  SWAPF  xD0,W
192E:  ANDLW  0F
1930:  ADDWF  xD5,F
1932:  ADDWF  xD6,F
1934:  RLCF   xD5,F
1936:  RLCF   xD6,F
1938:  COMF   xD6,F
193A:  RLCF   xD6,F
193C:  MOVF   xD0,W
193E:  ANDLW  0F
1940:  ADDWF  xD6,F
1942:  RLCF   xD3,F
1944:  MOVLW  07
1946:  MOVWF  xD2
1948:  MOVLW  0A
194A:  DECF   xD5,F
194C:  ADDWF  xD6,F
194E:  BNC   194A
1950:  DECF   xD4,F
1952:  ADDWF  xD5,F
1954:  BNC   1950
1956:  DECF   xD3,F
1958:  ADDWF  xD4,F
195A:  BNC   1956
195C:  DECF   xD2,F
195E:  ADDWF  xD3,F
1960:  BNC   195C
1962:  MOVLW  01
1964:  MOVWF  FEA
1966:  MOVLW  D2
1968:  MOVWF  FE9
196A:  MOVLW  07
196C:  ANDWF  xD7,W
196E:  BCF    xD7.6
1970:  ADDWF  FE9,F
1972:  MOVLW  00
1974:  ADDWFC FEA,F
1976:  MOVF   FE9,W
1978:  SUBLW  D6
197A:  BNZ   1982
197C:  DECFSZ FEA,W
197E:  BRA    1982
1980:  BSF    xD7.6
1982:  MOVF   FEF,W
1984:  MOVWF  00
1986:  BNZ   1998
1988:  BTFSC  xD7.6
198A:  BRA    1998
198C:  BTFSC  xD7.4
198E:  BRA    19BC
1990:  BTFSC  xD7.3
1992:  BRA    1998
1994:  MOVLW  20
1996:  BRA    199E
1998:  BSF    xD7.3
199A:  BCF    xD7.4
199C:  MOVLW  30
199E:  ADDWF  00,F
19A0:  MOVFF  FEA,1D1
19A4:  MOVFF  FE9,1D0
19A8:  MOVFF  00,1D9
19AC:  MOVLB  0
19AE:  CALL   1114
19B2:  MOVFF  1D1,FEA
19B6:  MOVFF  1D0,FE9
19BA:  MOVLB  1
19BC:  MOVF   FEE,W
19BE:  BTFSS  xD7.6
19C0:  BRA    1976
19C2:  MOVLB  0
19C4:  RETURN 0
19C6:  MOVF   01,W
19C8:  MOVFF  1D0,1D6
19CC:  MOVLW  64
19CE:  MOVLB  1
19D0:  MOVWF  xD7
19D2:  MOVLB  0
19D4:  CALL   1024
19D8:  MOVFF  00,1D0
19DC:  MOVF   01,W
19DE:  MOVLW  30
19E0:  BNZ   19F2
19E2:  MOVLB  1
19E4:  BTFSS  xD1.1
19E6:  BRA    1A08
19E8:  BTFSC  xD1.3
19EA:  BRA    1A08
19EC:  BTFSC  xD1.4
19EE:  MOVLW  20
19F0:  BRA    19FA
19F2:  MOVLB  1
19F4:  BCF    xD1.3
19F6:  BCF    xD1.4
19F8:  BSF    xD1.0
19FA:  ADDWF  01,F
19FC:  MOVFF  01,1D9
1A00:  MOVLB  0
1A02:  CALL   1114
1A06:  MOVLB  1
1A08:  MOVFF  1D0,1D6
1A0C:  MOVLW  0A
1A0E:  MOVWF  xD7
1A10:  MOVLB  0
1A12:  CALL   1024
1A16:  MOVFF  00,1D0
1A1A:  MOVF   01,W
1A1C:  MOVLW  30
1A1E:  BNZ   1A30
1A20:  MOVLB  1
1A22:  BTFSC  xD1.3
1A24:  BRA    1A3C
1A26:  BTFSS  xD1.0
1A28:  BRA    1A3C
1A2A:  BTFSC  xD1.4
1A2C:  MOVLW  20
1A2E:  MOVLB  0
1A30:  ADDWF  01,F
1A32:  MOVFF  01,1D9
1A36:  CALL   1114
1A3A:  MOVLB  1
1A3C:  MOVLW  30
1A3E:  ADDWF  xD0,F
1A40:  MOVFF  1D0,1D9
1A44:  MOVLB  0
1A46:  CALL   1114
1A4A:  RETURN 0
*
21AA:  ADDWF  FE8,W
21AC:  CLRF   FF7
21AE:  RLCF   FF7,F
21B0:  ADDLW  C5
21B2:  MOVWF  FF6
21B4:  MOVLW  21
21B6:  ADDWFC FF7,F
21B8:  TBLRD*-
21BA:  MOVF   FF5,W
21BC:  MOVWF  FFA
21BE:  TBLRD*
21C0:  MOVF   FF5,W
21C2:  MOVWF  FF9
21C4:  DATA 7A,21
21C6:  DATA A4,21
21C8:  DATA A4,21
21CA:  DATA A4,21
21CC:  DATA 7C,21
21CE:  DATA 8C,21
21D0:  DATA 90,21
21D2:  DATA A4,21
21D4:  DATA A4,21
21D6:  DATA A4,21
21D8:  DATA 92,21
21DA:  DATA A2,21
*
24B2:  ADDWF  FE8,W
24B4:  CLRF   FF7
24B6:  RLCF   FF7,F
24B8:  ADDLW  CD
24BA:  MOVWF  FF6
24BC:  MOVLW  24
24BE:  ADDWFC FF7,F
24C0:  TBLRD*-
24C2:  MOVF   FF5,W
24C4:  MOVWF  FFA
24C6:  TBLRD*
24C8:  MOVF   FF5,W
24CA:  MOVWF  FF9
24CC:  DATA 82,24
24CE:  DATA AC,24
24D0:  DATA AC,24
24D2:  DATA AC,24
24D4:  DATA 84,24
24D6:  DATA 94,24
24D8:  DATA 98,24
24DA:  DATA AC,24
24DC:  DATA AC,24
24DE:  DATA AC,24
24E0:  DATA 9A,24
24E2:  DATA AA,24
*
27BC:  ADDWF  FE8,W
27BE:  CLRF   FF7
27C0:  RLCF   FF7,F
27C2:  ADDLW  D7
27C4:  MOVWF  FF6
27C6:  MOVLW  27
27C8:  ADDWFC FF7,F
27CA:  TBLRD*-
27CC:  MOVF   FF5,W
27CE:  MOVWF  FFA
27D0:  TBLRD*
27D2:  MOVF   FF5,W
27D4:  MOVWF  FF9
27D6:  DATA 8C,27
27D8:  DATA B6,27
27DA:  DATA B6,27
27DC:  DATA B6,27
27DE:  DATA 8E,27
27E0:  DATA 9E,27
27E2:  DATA A2,27
27E4:  DATA B6,27
27E6:  DATA B6,27
27E8:  DATA B6,27
27EA:  DATA A4,27
27EC:  DATA B4,27
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0F1C:  MOVLB  1
0F1E:  MOVFF  1D6,FE9
0F22:  MOVFF  1D7,FEA
0F26:  MOVFF  FEF,1DA
0F2A:  MOVFF  1D9,03
0F2E:  MOVFF  1D8,FE9
0F32:  MOVFF  1D9,FEA
0F36:  MOVF   FEF,W
0F38:  SUBWF  xDA,W
0F3A:  BNZ   0F66
....................       if (*s1 == '\0') 
0F3C:  MOVFF  1D7,03
0F40:  MOVFF  1D6,FE9
0F44:  MOVFF  03,FEA
0F48:  MOVF   FEF,F
0F4A:  BNZ   0F52
....................          return(0); 
0F4C:  MOVLW  00
0F4E:  MOVWF  01
0F50:  BRA    0F90
0F52:  MOVFF  1D7,03
0F56:  MOVF   xD6,W
0F58:  INCF   xD6,F
0F5A:  BTFSC  FD8.2
0F5C:  INCF   xD7,F
0F5E:  INCF   xD8,F
0F60:  BTFSC  FD8.2
0F62:  INCF   xD9,F
0F64:  BRA    0F1E
....................    return((*s1 < *s2) ? -1: 1); 
0F66:  MOVFF  1D7,03
0F6A:  MOVFF  1D6,FE9
0F6E:  MOVFF  1D7,FEA
0F72:  MOVFF  FEF,1DA
0F76:  MOVFF  1D9,03
0F7A:  MOVFF  1D8,FE9
0F7E:  MOVFF  1D9,FEA
0F82:  MOVF   FEF,W
0F84:  SUBWF  xDA,W
0F86:  BC    0F8C
0F88:  MOVLW  FF
0F8A:  BRA    0F8E
0F8C:  MOVLW  01
0F8E:  MOVWF  01
0F90:  MOVLB  0
0F92:  GOTO   0FD6 (RETURN)
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
129A:  MOVFF  1DA,1DE
129E:  MOVFF  1D9,1DD
12A2:  MOVFF  1DE,03
12A6:  MOVLB  1
12A8:  MOVFF  1DD,FE9
12AC:  MOVFF  1DE,FEA
12B0:  MOVF   FEF,F
12B2:  BZ    1308
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
12B4:  MOVFF  1DC,1E0
12B8:  MOVFF  1DB,1DF
12BC:  MOVFF  1E0,03
12C0:  MOVFF  1DF,FE9
12C4:  MOVFF  1E0,FEA
12C8:  MOVF   FEF,F
12CA:  BZ    12FC
....................          if (*sc1 == *sc2) 
12CC:  MOVFF  1DD,FE9
12D0:  MOVFF  1DE,FEA
12D4:  MOVFF  FEF,1E1
12D8:  MOVFF  1E0,03
12DC:  MOVFF  1DF,FE9
12E0:  MOVFF  1E0,FEA
12E4:  MOVF   FEF,W
12E6:  SUBWF  xE1,W
12E8:  BNZ   12F4
....................             return(sc1); 
12EA:  MOVFF  1DD,01
12EE:  MOVFF  1DE,02
12F2:  BRA    130E
12F4:  INCF   xDF,F
12F6:  BTFSC  FD8.2
12F8:  INCF   xE0,F
12FA:  BRA    12BC
12FC:  INCF   xDD,F
12FE:  BTFSC  FD8.2
1300:  INCF   xDE,F
1302:  MOVLB  0
1304:  BRA    12A2
1306:  MOVLB  1
....................    return(0); 
1308:  MOVLW  00
130A:  MOVWF  01
130C:  MOVWF  02
130E:  MOVLB  0
1310:  GOTO   1386 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
120A:  MOVFF  1DA,1DE
120E:  MOVFF  1D9,1DD
1212:  MOVFF  1DE,03
1216:  MOVLB  1
1218:  MOVFF  1DD,FE9
121C:  MOVFF  1DE,FEA
1220:  MOVF   FEF,F
1222:  BZ    1284
....................       for (sc2 = s2; ; sc2++) 
1224:  MOVFF  1DC,1E0
1228:  MOVFF  1DB,1DF
....................     if (*sc2 == '\0') 
122C:  MOVFF  1E0,03
1230:  MOVFF  1DF,FE9
1234:  MOVFF  1E0,FEA
1238:  MOVF   FEF,F
123A:  BNZ   1250
....................        return(sc1 - s1); 
123C:  MOVF   xD9,W
123E:  SUBWF  xDD,W
1240:  MOVWF  00
1242:  MOVF   xDA,W
1244:  SUBWFB xDE,W
1246:  MOVWF  03
1248:  MOVFF  00,01
124C:  BRA    1294
124E:  BRA    1270
....................          else if (*sc1 == *sc2) 
1250:  MOVFF  1DD,FE9
1254:  MOVFF  1DE,FEA
1258:  MOVFF  FEF,1E1
125C:  MOVFF  1E0,03
1260:  MOVFF  1DF,FE9
1264:  MOVFF  1E0,FEA
1268:  MOVF   FEF,W
126A:  SUBWF  xE1,W
126C:  BNZ   1270
....................             break; 
126E:  BRA    1278
1270:  INCF   xDF,F
1272:  BTFSC  FD8.2
1274:  INCF   xE0,F
1276:  BRA    122C
1278:  INCF   xDD,F
127A:  BTFSC  FD8.2
127C:  INCF   xDE,F
127E:  MOVLB  0
1280:  BRA    1212
1282:  MOVLB  1
....................    return(sc1 - s1); 
1284:  MOVF   xD9,W
1286:  SUBWF  xDD,W
1288:  MOVWF  00
128A:  MOVF   xDA,W
128C:  SUBWFB xDE,W
128E:  MOVWF  03
1290:  MOVFF  00,01
1294:  MOVLB  0
1296:  GOTO   1344 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
1314:  MOVLB  1
1316:  MOVF   xD1,W
1318:  IORWF  xD2,W
131A:  BZ    1324
131C:  MOVFF  1D2,03
1320:  MOVF   xD1,W
1322:  BRA    132A
1324:  MOVFF  1A,03
1328:  MOVF   19,W
132A:  MOVWF  xD5
132C:  MOVFF  03,1D6
....................    beg += strspn(beg, s2); 
1330:  MOVFF  1D6,1DA
1334:  MOVFF  1D5,1D9
1338:  MOVFF  1D4,1DC
133C:  MOVFF  1D3,1DB
1340:  MOVLB  0
1342:  BRA    120A
1344:  MOVF   01,W
1346:  MOVLB  1
1348:  ADDWF  xD5,F
134A:  MOVLW  00
134C:  ADDWFC xD6,F
....................    if (*beg == '\0') 
134E:  MOVFF  1D6,03
1352:  MOVFF  1D5,FE9
1356:  MOVFF  1D6,FEA
135A:  MOVF   FEF,F
135C:  BNZ   1372
....................    { 
....................       *save = ' '; 
135E:  MOVFF  19,FE9
1362:  MOVFF  1A,FEA
1366:  MOVLW  20
1368:  MOVWF  FEF
....................       return(0); 
136A:  MOVLW  00
136C:  MOVWF  01
136E:  MOVWF  02
1370:  BRA    13C0
....................    } 
....................    end = strpbrk(beg, s2); 
1372:  MOVFF  1D6,1DA
1376:  MOVFF  1D5,1D9
137A:  MOVFF  1D4,1DC
137E:  MOVFF  1D3,1DB
1382:  MOVLB  0
1384:  BRA    129A
1386:  MOVFF  02,1D8
138A:  MOVFF  01,1D7
....................    if (*end != '\0') 
138E:  MOVFF  1D8,03
1392:  MOVLB  1
1394:  MOVFF  1D7,FE9
1398:  MOVFF  1D8,FEA
139C:  MOVF   FEF,F
139E:  BZ    13B0
....................    { 
....................       *end = '\0'; 
13A0:  MOVFF  1D7,FE9
13A4:  MOVFF  1D8,FEA
13A8:  CLRF   FEF
....................       end++; 
13AA:  INCF   xD7,F
13AC:  BTFSC  FD8.2
13AE:  INCF   xD8,F
....................    } 
....................    save = end; 
13B0:  MOVFF  1D8,1A
13B4:  MOVFF  1D7,19
....................    return(beg); 
13B8:  MOVFF  1D5,01
13BC:  MOVFF  1D6,02
13C0:  MOVLB  0
13C2:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
13C4:  MOVLB  1
13C6:  CLRF   xD9
....................    sign = 0; 
13C8:  CLRF   xD7
....................    base = 10; 
13CA:  MOVLW  0A
13CC:  MOVWF  xD8
....................    result = 0; 
13CE:  CLRF   xD6
13D0:  CLRF   xD5
13D2:  CLRF   xD4
13D4:  CLRF   xD3
....................  
....................    if (!s) 
13D6:  MOVF   xD1,W
13D8:  IORWF  xD2,W
13DA:  BNZ   13E6
....................       return 0; 
13DC:  CLRF   00
13DE:  CLRF   01
13E0:  CLRF   02
13E2:  CLRF   03
13E4:  BRA    1654
....................    c = s[index++]; 
13E6:  MOVF   xD9,W
13E8:  INCF   xD9,F
13EA:  ADDWF  xD1,W
13EC:  MOVWF  FE9
13EE:  MOVLW  00
13F0:  ADDWFC xD2,W
13F2:  MOVWF  FEA
13F4:  MOVFF  FEF,1DA
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
13F8:  MOVF   xDA,W
13FA:  SUBLW  2D
13FC:  BNZ   1416
....................    { 
....................       sign = 1;         // Set the sign to negative 
13FE:  MOVLW  01
1400:  MOVWF  xD7
....................       c = s[index++]; 
1402:  MOVF   xD9,W
1404:  INCF   xD9,F
1406:  ADDWF  xD1,W
1408:  MOVWF  FE9
140A:  MOVLW  00
140C:  ADDWFC xD2,W
140E:  MOVWF  FEA
1410:  MOVFF  FEF,1DA
....................    } 
1414:  BRA    142E
....................    else if (c == '+') 
1416:  MOVF   xDA,W
1418:  SUBLW  2B
141A:  BNZ   142E
....................    { 
....................       c = s[index++]; 
141C:  MOVF   xD9,W
141E:  INCF   xD9,F
1420:  ADDWF  xD1,W
1422:  MOVWF  FE9
1424:  MOVLW  00
1426:  ADDWFC xD2,W
1428:  MOVWF  FEA
142A:  MOVFF  FEF,1DA
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
142E:  MOVF   xDA,W
1430:  SUBLW  2F
1432:  BTFSC  FD8.0
1434:  BRA    1624
1436:  MOVF   xDA,W
1438:  SUBLW  39
143A:  BTFSS  FD8.0
143C:  BRA    1624
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
143E:  MOVF   xDA,W
1440:  SUBLW  30
1442:  BNZ   1480
1444:  MOVF   xD9,W
1446:  ADDWF  xD1,W
1448:  MOVWF  FE9
144A:  MOVLW  00
144C:  ADDWFC xD2,W
144E:  MOVWF  FEA
1450:  MOVF   FEF,W
1452:  SUBLW  78
1454:  BZ    1468
1456:  MOVF   xD9,W
1458:  ADDWF  xD1,W
145A:  MOVWF  FE9
145C:  MOVLW  00
145E:  ADDWFC xD2,W
1460:  MOVWF  FEA
1462:  MOVF   FEF,W
1464:  SUBLW  58
1466:  BNZ   1480
....................       { 
....................          base = 16; 
1468:  MOVLW  10
146A:  MOVWF  xD8
....................          index++; 
146C:  INCF   xD9,F
....................          c = s[index++]; 
146E:  MOVF   xD9,W
1470:  INCF   xD9,F
1472:  ADDWF  xD1,W
1474:  MOVWF  FE9
1476:  MOVLW  00
1478:  ADDWFC xD2,W
147A:  MOVWF  FEA
147C:  MOVFF  FEF,1DA
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1480:  MOVF   xD8,W
1482:  SUBLW  0A
1484:  BNZ   150C
....................       { 
....................          while (c >= '0' && c <= '9') { 
1486:  MOVF   xDA,W
1488:  SUBLW  2F
148A:  BC    150A
148C:  MOVF   xDA,W
148E:  SUBLW  39
1490:  BNC   150A
....................             result = (result << 1) + (result << 3);  // result *= 10; 
1492:  BCF    FD8.0
1494:  RLCF   xD3,W
1496:  MOVWF  xDC
1498:  RLCF   xD4,W
149A:  MOVWF  xDD
149C:  RLCF   xD5,W
149E:  MOVWF  xDE
14A0:  RLCF   xD6,W
14A2:  MOVWF  xDF
14A4:  RLCF   xD3,W
14A6:  MOVWF  00
14A8:  RLCF   xD4,W
14AA:  MOVWF  01
14AC:  RLCF   xD5,W
14AE:  MOVWF  02
14B0:  RLCF   xD6,W
14B2:  MOVWF  03
14B4:  RLCF   00,F
14B6:  RLCF   01,F
14B8:  RLCF   02,F
14BA:  RLCF   03,F
14BC:  RLCF   00,F
14BE:  RLCF   01,F
14C0:  RLCF   02,F
14C2:  RLCF   03,F
14C4:  MOVLW  F8
14C6:  ANDWF  00,F
14C8:  MOVF   xDC,W
14CA:  ADDWF  00,F
14CC:  MOVF   xDD,W
14CE:  ADDWFC 01,F
14D0:  MOVF   xDE,W
14D2:  ADDWFC 02,F
14D4:  MOVF   xDF,W
14D6:  ADDWFC 03,F
14D8:  MOVFF  03,1D6
14DC:  MOVFF  02,1D5
14E0:  MOVFF  01,1D4
14E4:  MOVFF  00,1D3
....................             result += (c - '0'); 
14E8:  MOVLW  30
14EA:  SUBWF  xDA,W
14EC:  ADDWF  xD3,F
14EE:  MOVLW  00
14F0:  ADDWFC xD4,F
14F2:  ADDWFC xD5,F
14F4:  ADDWFC xD6,F
....................             c = s[index++]; 
14F6:  MOVF   xD9,W
14F8:  INCF   xD9,F
14FA:  ADDWF  xD1,W
14FC:  MOVWF  FE9
14FE:  MOVLW  00
1500:  ADDWFC xD2,W
1502:  MOVWF  FEA
1504:  MOVFF  FEF,1DA
1508:  BRA    1486
....................          } 
....................       } 
150A:  BRA    1624
....................       else if (base == 16)    // The number is a hexa number 
150C:  MOVF   xD8,W
150E:  SUBLW  10
1510:  BTFSS  FD8.2
1512:  BRA    1624
....................       { 
....................          c = toupper(c); 
1514:  MOVF   xDA,W
1516:  SUBLW  60
1518:  BC    1526
151A:  MOVF   xDA,W
151C:  SUBLW  7A
151E:  BNC   1526
1520:  MOVF   xDA,W
1522:  ANDLW  DF
1524:  BRA    1528
1526:  MOVF   xDA,W
1528:  MOVWF  xDA
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
152A:  MOVF   xDA,W
152C:  SUBLW  2F
152E:  BC    1536
1530:  MOVF   xDA,W
1532:  SUBLW  39
1534:  BC    1544
1536:  MOVF   xDA,W
1538:  SUBLW  40
153A:  BTFSC  FD8.0
153C:  BRA    1624
153E:  MOVF   xDA,W
1540:  SUBLW  46
1542:  BNC   1624
....................          { 
....................             if (c >= '0' && c <= '9') 
1544:  MOVF   xDA,W
1546:  SUBLW  2F
1548:  BC    15A6
154A:  MOVF   xDA,W
154C:  SUBLW  39
154E:  BNC   15A6
....................                result = (result << 4) + (c - '0'); 
1550:  RLCF   xD3,W
1552:  MOVWF  xDC
1554:  RLCF   xD4,W
1556:  MOVWF  xDD
1558:  RLCF   xD5,W
155A:  MOVWF  xDE
155C:  RLCF   xD6,W
155E:  MOVWF  xDF
1560:  RLCF   xDC,F
1562:  RLCF   xDD,F
1564:  RLCF   xDE,F
1566:  RLCF   xDF,F
1568:  RLCF   xDC,F
156A:  RLCF   xDD,F
156C:  RLCF   xDE,F
156E:  RLCF   xDF,F
1570:  RLCF   xDC,F
1572:  RLCF   xDD,F
1574:  RLCF   xDE,F
1576:  RLCF   xDF,F
1578:  MOVLW  F0
157A:  ANDWF  xDC,F
157C:  MOVLW  30
157E:  SUBWF  xDA,W
1580:  ADDWF  xDC,W
1582:  MOVWF  00
1584:  MOVLW  00
1586:  ADDWFC xDD,W
1588:  MOVWF  01
158A:  MOVLW  00
158C:  ADDWFC xDE,W
158E:  MOVWF  02
1590:  MOVLW  00
1592:  ADDWFC xDF,W
1594:  MOVWF  03
1596:  MOVWF  xD6
1598:  MOVFF  02,1D5
159C:  MOVFF  01,1D4
15A0:  MOVFF  00,1D3
15A4:  BRA    15FA
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
15A6:  RLCF   xD3,W
15A8:  MOVWF  xDC
15AA:  RLCF   xD4,W
15AC:  MOVWF  xDD
15AE:  RLCF   xD5,W
15B0:  MOVWF  xDE
15B2:  RLCF   xD6,W
15B4:  MOVWF  xDF
15B6:  RLCF   xDC,F
15B8:  RLCF   xDD,F
15BA:  RLCF   xDE,F
15BC:  RLCF   xDF,F
15BE:  RLCF   xDC,F
15C0:  RLCF   xDD,F
15C2:  RLCF   xDE,F
15C4:  RLCF   xDF,F
15C6:  RLCF   xDC,F
15C8:  RLCF   xDD,F
15CA:  RLCF   xDE,F
15CC:  RLCF   xDF,F
15CE:  MOVLW  F0
15D0:  ANDWF  xDC,F
15D2:  MOVLW  41
15D4:  SUBWF  xDA,W
15D6:  ADDLW  0A
15D8:  ADDWF  xDC,W
15DA:  MOVWF  00
15DC:  MOVLW  00
15DE:  ADDWFC xDD,W
15E0:  MOVWF  01
15E2:  MOVLW  00
15E4:  ADDWFC xDE,W
15E6:  MOVWF  02
15E8:  MOVLW  00
15EA:  ADDWFC xDF,W
15EC:  MOVWF  xD6
15EE:  MOVFF  02,1D5
15F2:  MOVFF  01,1D4
15F6:  MOVFF  00,1D3
....................  
....................             c = s[index++];c = toupper(c); 
15FA:  MOVF   xD9,W
15FC:  INCF   xD9,F
15FE:  ADDWF  xD1,W
1600:  MOVWF  FE9
1602:  MOVLW  00
1604:  ADDWFC xD2,W
1606:  MOVWF  FEA
1608:  MOVFF  FEF,1DA
160C:  MOVF   xDA,W
160E:  SUBLW  60
1610:  BC    161E
1612:  MOVF   xDA,W
1614:  SUBLW  7A
1616:  BNC   161E
1618:  MOVF   xDA,W
161A:  ANDLW  DF
161C:  BRA    1620
161E:  MOVF   xDA,W
1620:  MOVWF  xDA
1622:  BRA    152A
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1624:  MOVF   xD8,W
1626:  SUBLW  0A
1628:  BNZ   1644
162A:  DECFSZ xD7,W
162C:  BRA    1644
....................       result = -result; 
162E:  COMF   xD3,F
1630:  COMF   xD4,F
1632:  COMF   xD5,F
1634:  COMF   xD6,F
1636:  INCF   xD3,F
1638:  BTFSC  FD8.2
163A:  INCF   xD4,F
163C:  BTFSC  FD8.2
163E:  INCF   xD5,F
1640:  BTFSC  FD8.2
1642:  INCF   xD6,F
....................  
....................    return(result); 
1644:  MOVFF  1D3,00
1648:  MOVFF  1D4,01
164C:  MOVFF  1D5,02
1650:  MOVFF  1D6,03
1654:  MOVLB  0
1656:  RETURN 0
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock = 20000000) 
*
01D4:  MOVLW  03
01D6:  MOVLB  1
01D8:  SUBWF  xE9,F
01DA:  BNC   01F0
01DC:  MOVLW  01
01DE:  MOVWF  FEA
01E0:  MOVLW  E9
01E2:  MOVWF  FE9
01E4:  MOVF   FEF,W
01E6:  BZ    01F0
01E8:  BRA    01EC
01EA:  BRA    01EC
01EC:  DECFSZ FEF,F
01EE:  BRA    01EA
01F0:  MOVLB  0
01F2:  GOTO   0208 (RETURN)
*
0418:  MOVLW  01
041A:  MOVWF  FEA
041C:  MOVLW  DB
041E:  MOVWF  FE9
0420:  MOVF   FEF,W
0422:  BZ    043E
0424:  MOVLW  06
0426:  MOVWF  01
0428:  CLRF   00
042A:  DECFSZ 00,F
042C:  BRA    042A
042E:  DECFSZ 01,F
0430:  BRA    0428
0432:  MOVLW  7B
0434:  MOVWF  00
0436:  DECFSZ 00,F
0438:  BRA    0436
043A:  DECFSZ FEF,F
043C:  BRA    0424
043E:  RETURN 0
.................... #use rs232(uart1, baud = 9600, TIMEOUT = 10, stream = monitor) // pic to pic 
*
01F6:  MOVLW  20
01F8:  MOVLB  1
01FA:  MOVWF  xE7
01FC:  MOVLW  02
01FE:  MOVWF  xE8
0200:  MOVLW  9B
0202:  MOVWF  xE9
0204:  MOVLB  0
0206:  BRA    01D4
0208:  MOVLB  1
020A:  DECFSZ xE8,F
020C:  BRA    0200
020E:  DECFSZ xE7,F
0210:  BRA    0218
0212:  CLRF   1F
0214:  CLRF   01
0216:  BRA    022C
0218:  BTFSS  F9E.5
021A:  BRA    01FC
021C:  MOVF   FAB,W
021E:  MOVWF  1F
0220:  MOVF   FAE,W
0222:  MOVWF  01
0224:  BTFSS  1F.1
0226:  BRA    022C
0228:  BCF    FAB.4
022A:  BSF    FAB.4
022C:  MOVLB  0
022E:  GOTO   025A (RETURN)
.................... //#use rs232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C0,rcv=PIN_C1,TIMEOUT=40,stream=GPS,DISABLE_INTS)// 
.................... #use rs232(BAUD = 9600, BITS = 8, PARITY = N, XMIT = PIN_C1, rcv = PIN_C0, TIMEOUT = 40, stream = GPS, DISABLE_INTS) // 
*
0EA4:  MOVLW  10
0EA6:  MOVLB  1
0EA8:  MOVWF  xD1
0EAA:  MOVLW  01
0EAC:  MOVWF  xD0
0EAE:  BSF    20.6
0EB0:  BSF    F94.0
0EB2:  MOVLW  10
0EB4:  MOVWF  00
0EB6:  DECFSZ 00,F
0EB8:  BRA    0EB6
0EBA:  NOP   
0EBC:  DECFSZ xD0,F
0EBE:  BRA    0ECA
0EC0:  DECFSZ xD1,F
0EC2:  BRA    0ECA
0EC4:  CLRF   20
0EC6:  CLRF   01
0EC8:  BRA    0F12
0ECA:  BTFSC  F82.0
0ECC:  BRA    0EB2
0ECE:  MOVLW  08
0ED0:  MOVWF  00
0ED2:  CLRF   xD2
0ED4:  MOVFF  FF2,1D3
0ED8:  BCF    FF2.7
0EDA:  BSF    00.7
0EDC:  BRA    0EFA
0EDE:  BCF    00.7
0EE0:  BRA    0EFA
0EE2:  BCF    FD8.0
0EE4:  BTFSC  F82.0
0EE6:  BSF    FD8.0
0EE8:  RRCF   xD2,F
0EEA:  BSF    00.6
0EEC:  BRA    0EFA
0EEE:  BCF    00.6
0EF0:  DECFSZ 00,F
0EF2:  BRA    0EE2
0EF4:  MOVF   xD2,W
0EF6:  MOVWF  01
0EF8:  BRA    0F12
0EFA:  MOVLW  A7
0EFC:  BTFSC  00.7
0EFE:  MOVLW  2D
0F00:  MOVWF  01
0F02:  DECFSZ 01,F
0F04:  BRA    0F02
0F06:  NOP   
0F08:  BTFSC  00.7
0F0A:  BRA    0EDE
0F0C:  BTFSC  00.6
0F0E:  BRA    0EEE
0F10:  BRA    0EE2
0F12:  BTFSC  xD3.7
0F14:  BSF    FF2.7
0F16:  MOVLB  0
0F18:  GOTO   2F4E (RETURN)
*
1114:  MOVFF  FF2,03
1118:  BCF    FF2.7
111A:  BCF    F94.1
111C:  BCF    F8B.1
111E:  MOVLW  08
1120:  MOVWF  01
1122:  BRA    1124
1124:  NOP   
1126:  BSF    01.7
1128:  BRA    114A
112A:  BCF    01.7
112C:  MOVLB  1
112E:  RRCF   xD9,F
1130:  MOVLB  0
1132:  BTFSC  FD8.0
1134:  BSF    F8B.1
1136:  BTFSS  FD8.0
1138:  BCF    F8B.1
113A:  BSF    01.6
113C:  BRA    114A
113E:  BCF    01.6
1140:  DECFSZ 01,F
1142:  BRA    112C
1144:  BRA    1146
1146:  NOP   
1148:  BSF    F8B.1
114A:  MOVLW  A7
114C:  MOVWF  FE9
114E:  DECFSZ FE9,F
1150:  BRA    114E
1152:  BRA    1154
1154:  BTFSC  01.7
1156:  BRA    112A
1158:  BTFSC  01.6
115A:  BRA    113E
115C:  BTFSC  03.7
115E:  BSF    FF2.7
1160:  RETURN 0
.................... #fuses HS, NOLVP, PUT, PROTECT, NODEBUG, NOWDT, WDT4096                                                              // pin D5 rx, tx_d0 
.................... #priority int_rda 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0440:  MOVLB  1
0442:  BTFSC  xE2.0
0444:  BRA    044A
0446:  BCF    F89.4
0448:  BRA    044C
044A:  BSF    F89.4
044C:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
044E:  BTFSC  xE2.1
0450:  BRA    0456
0452:  BCF    F89.2
0454:  BRA    0458
0456:  BSF    F89.2
0458:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
045A:  BTFSC  xE2.2
045C:  BRA    0462
045E:  BCF    F89.1
0460:  BRA    0464
0462:  BSF    F89.1
0464:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0466:  BTFSC  xE2.3
0468:  BRA    046E
046A:  BCF    F89.0
046C:  BRA    0470
046E:  BSF    F89.0
0470:  BCF    F92.0
....................  
....................  delay_cycles(1);  
0472:  NOP   
....................  output_high(LCD_E);  
0474:  BCF    F92.3
0476:  BSF    F89.3
....................  delay_us(2);  
0478:  MOVLW  02
047A:  MOVWF  00
047C:  DECFSZ 00,F
047E:  BRA    047C
0480:  BRA    0482
0482:  NOP   
....................  output_low(LCD_E);  
0484:  BCF    F92.3
0486:  BCF    F89.3
0488:  MOVLB  0
048A:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
048C:  BCF    F96.2
048E:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0490:  MOVLW  63
0492:  MOVWF  00
0494:  DECFSZ 00,F
0496:  BRA    0494
0498:  BRA    049A
.................... #endif  
....................  
.................... if(address)  
049A:  MOVLB  1
049C:  MOVF   xDF,F
049E:  BZ    04A6
....................    output_high(LCD_RS);  
04A0:  BCF    F96.2
04A2:  BSF    F8D.2
04A4:  BRA    04AA
.................... else  
....................    output_low(LCD_RS);  
04A6:  BCF    F96.2
04A8:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
04AA:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
04AC:  BCF    F92.3
04AE:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
04B0:  SWAPF  xE0,W
04B2:  MOVWF  xE1
04B4:  MOVLW  0F
04B6:  ANDWF  xE1,F
04B8:  MOVFF  1E1,1E2
04BC:  MOVLB  0
04BE:  RCALL  0440
.................... lcd_send_nibble(n & 0xf);  
04C0:  MOVLB  1
04C2:  MOVF   xE0,W
04C4:  ANDLW  0F
04C6:  MOVWF  xE1
04C8:  MOVWF  xE2
04CA:  MOVLB  0
04CC:  RCALL  0440
04CE:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
04D0:  MOVLW  01
04D2:  MOVWF  21
....................  
....................    output_low(LCD_RS);  
04D4:  BCF    F96.2
04D6:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
04D8:  BCF    F92.3
04DA:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
04DC:  MOVLW  23
04DE:  MOVLB  1
04E0:  MOVWF  xDB
04E2:  MOVLB  0
04E4:  RCALL  0418
....................  
....................    for(i=0 ;i < 3; i++)  
04E6:  MOVLB  1
04E8:  CLRF   xD0
04EA:  MOVF   xD0,W
04EC:  SUBLW  02
04EE:  BNC   0508
....................    {  
....................       lcd_send_nibble(0x03);  
04F0:  MOVLW  03
04F2:  MOVWF  xE2
04F4:  MOVLB  0
04F6:  RCALL  0440
....................       delay_ms(5);  
04F8:  MOVLW  05
04FA:  MOVLB  1
04FC:  MOVWF  xDB
04FE:  MOVLB  0
0500:  RCALL  0418
0502:  MOVLB  1
0504:  INCF   xD0,F
0506:  BRA    04EA
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
0508:  MOVLW  02
050A:  MOVWF  xE2
050C:  MOVLB  0
050E:  RCALL  0440
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
0510:  MOVLB  1
0512:  CLRF   xD0
0514:  MOVF   xD0,W
0516:  SUBLW  03
0518:  BNC   053E
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
051A:  CLRF   03
051C:  MOVF   xD0,W
051E:  MOVLB  0
0520:  RCALL  00C6
0522:  MOVLB  1
0524:  MOVWF  xD1
0526:  CLRF   xDF
0528:  MOVWF  xE0
052A:  MOVLB  0
052C:  RCALL  048C
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
052E:  MOVLW  05
0530:  MOVLB  1
0532:  MOVWF  xDB
0534:  MOVLB  0
0536:  RCALL  0418
....................       #endif  
0538:  MOVLB  1
053A:  INCF   xD0,F
053C:  BRA    0514
....................    }  
053E:  MOVLB  0
0540:  GOTO   2D1E (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
087C:  MOVLB  1
087E:  MOVF   xDC,W
0880:  XORLW  01
0882:  MOVLB  0
0884:  BZ    0894
0886:  XORLW  03
0888:  BZ    089A
088A:  XORLW  01
088C:  BZ    08A2
088E:  XORLW  07
0890:  BZ    08AA
0892:  BRA    08B4
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
0894:  MOVLB  1
0896:  CLRF   xDD
....................      break;  
0898:  BRA    08B8
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
089A:  MOVLW  40
089C:  MOVLB  1
089E:  MOVWF  xDD
....................      break;  
08A0:  BRA    08B8
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
08A2:  MOVLW  14
08A4:  MOVLB  1
08A6:  MOVWF  xDD
....................      break;  
08A8:  BRA    08B8
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
08AA:  MOVLW  54
08AC:  MOVLB  1
08AE:  MOVWF  xDD
....................      break;  
08B0:  BRA    08B8
08B2:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
08B4:  MOVLB  1
08B6:  CLRF   xDD
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
08B8:  MOVLW  01
08BA:  SUBWF  xDB,W
08BC:  ADDWF  xDD,F
.................... lcd_send_byte(0, 0x80 | address);  
08BE:  MOVF   xDD,W
08C0:  IORLW  80
08C2:  MOVWF  xDE
08C4:  CLRF   xDF
08C6:  MOVWF  xE0
08C8:  MOVLB  0
08CA:  RCALL  048C
08CC:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
08CE:  MOVLB  1
08D0:  MOVF   xDA,W
08D2:  XORLW  0C
08D4:  MOVLB  0
08D6:  BZ    08E2
08D8:  XORLW  06
08DA:  BZ    08FE
08DC:  XORLW  02
08DE:  BZ    0910
08E0:  BRA    091E
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
08E2:  MOVLB  1
08E4:  CLRF   xDF
08E6:  MOVLW  01
08E8:  MOVWF  xE0
08EA:  MOVLB  0
08EC:  RCALL  048C
....................       lcd_line = 1;  
08EE:  MOVLW  01
08F0:  MOVWF  21
....................       delay_ms(2);  
08F2:  MOVLW  02
08F4:  MOVLB  1
08F6:  MOVWF  xDB
08F8:  MOVLB  0
08FA:  RCALL  0418
....................       break;  
08FC:  BRA    092C
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
08FE:  INCF   21,F
0900:  MOVLW  01
0902:  MOVLB  1
0904:  MOVWF  xDB
0906:  MOVFF  21,1DC
090A:  MOVLB  0
090C:  RCALL  087C
....................        break;  
090E:  BRA    092C
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
0910:  MOVLB  1
0912:  CLRF   xDF
0914:  MOVLW  10
0916:  MOVWF  xE0
0918:  MOVLB  0
091A:  RCALL  048C
....................        break;  
091C:  BRA    092C
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
091E:  MOVLW  01
0920:  MOVLB  1
0922:  MOVWF  xDF
0924:  MOVFF  1DA,1E0
0928:  MOVLB  0
092A:  RCALL  048C
....................        break;  
....................    }  
092C:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_eeprom.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_D6//PIN_B7 
.................... #define EEPROM_SCL  PIN_D7//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
054C:  MOVLW  08
054E:  MOVWF  01
0550:  MOVLW  05
0552:  MOVWF  00
0554:  DECFSZ 00,F
0556:  BRA    0554
0558:  BCF    F8C.7
055A:  BCF    F95.7
055C:  MOVLW  06
055E:  MOVWF  00
0560:  DECFSZ 00,F
0562:  BRA    0560
0564:  MOVLB  1
0566:  RLCF   xDA,F
0568:  BCF    F8C.6
056A:  BTFSC  FD8.0
056C:  BSF    F95.6
056E:  BTFSS  FD8.0
0570:  BCF    F95.6
0572:  BSF    F95.7
0574:  BTFSS  F83.7
0576:  BRA    0574
0578:  DECFSZ 01,F
057A:  BRA    057E
057C:  BRA    0582
057E:  MOVLB  0
0580:  BRA    0550
0582:  MOVLW  05
0584:  MOVWF  00
0586:  DECFSZ 00,F
0588:  BRA    0586
058A:  BCF    F8C.7
058C:  BCF    F95.7
058E:  NOP   
0590:  BSF    F95.6
0592:  MOVLW  06
0594:  MOVWF  00
0596:  DECFSZ 00,F
0598:  BRA    0596
059A:  MOVLW  06
059C:  MOVWF  00
059E:  DECFSZ 00,F
05A0:  BRA    059E
05A2:  BSF    F95.7
05A4:  BTFSS  F83.7
05A6:  BRA    05A4
05A8:  CLRF   01
05AA:  MOVLW  06
05AC:  MOVWF  00
05AE:  DECFSZ 00,F
05B0:  BRA    05AE
05B2:  BTFSC  F83.6
05B4:  BSF    01.0
05B6:  BCF    F8C.7
05B8:  BCF    F95.7
05BA:  BCF    F8C.6
05BC:  BCF    F95.6
05BE:  MOVLB  0
05C0:  RETURN 0
*
0716:  MOVLW  08
0718:  MOVLB  1
071A:  MOVWF  xD8
071C:  MOVFF  00,1D9
0720:  BSF    F95.6
0722:  MOVLW  06
0724:  MOVWF  00
0726:  DECFSZ 00,F
0728:  BRA    0726
072A:  BSF    F95.7
072C:  BTFSS  F83.7
072E:  BRA    072C
0730:  BTFSC  F83.6
0732:  BSF    FD8.0
0734:  BTFSS  F83.6
0736:  BCF    FD8.0
0738:  RLCF   01,F
073A:  MOVLW  05
073C:  MOVWF  00
073E:  DECFSZ 00,F
0740:  BRA    073E
0742:  BCF    F95.7
0744:  BCF    F8C.7
0746:  DECFSZ xD8,F
0748:  BRA    0720
074A:  BSF    F95.6
074C:  MOVLW  06
074E:  MOVWF  00
0750:  DECFSZ 00,F
0752:  BRA    0750
0754:  BCF    F8C.6
0756:  MOVF   xD9,W
0758:  BTFSS  FD8.2
075A:  BCF    F95.6
075C:  NOP   
075E:  BSF    F95.7
0760:  BTFSS  F83.7
0762:  BRA    0760
0764:  MOVLW  05
0766:  MOVWF  00
0768:  DECFSZ 00,F
076A:  BRA    0768
076C:  BCF    F8C.7
076E:  BCF    F95.7
0770:  MOVLW  06
0772:  MOVWF  00
0774:  DECFSZ 00,F
0776:  BRA    0774
0778:  BCF    F8C.6
077A:  BCF    F95.6
077C:  MOVLB  0
077E:  GOTO   07FC (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
0544:  BSF    F95.7
....................    output_float(EEPROM_SDA); 
0546:  BSF    F95.6
0548:  GOTO   2D22 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
05C2:  BSF    F95.6
05C4:  MOVLW  05
05C6:  MOVWF  00
05C8:  DECFSZ 00,F
05CA:  BRA    05C8
05CC:  BSF    F95.7
05CE:  MOVLW  06
05D0:  MOVWF  00
05D2:  DECFSZ 00,F
05D4:  BRA    05D2
05D6:  BCF    F8C.6
05D8:  BCF    F95.6
05DA:  MOVLW  05
05DC:  MOVWF  00
05DE:  DECFSZ 00,F
05E0:  BRA    05DE
05E2:  BCF    F8C.7
05E4:  BCF    F95.7
....................    i2c_write(0xa0); 
05E6:  MOVLW  A0
05E8:  MOVLB  1
05EA:  MOVWF  xDA
05EC:  MOVLB  0
05EE:  RCALL  054C
....................    i2c_write(address>>8); 
05F0:  MOVFF  1D5,1D8
05F4:  MOVLB  1
05F6:  CLRF   xD9
05F8:  MOVFF  1D5,1DA
05FC:  MOVLB  0
05FE:  RCALL  054C
....................    i2c_write(address); 
0600:  MOVFF  1D4,1DA
0604:  RCALL  054C
....................    i2c_write(data); 
0606:  MOVFF  1D6,1DA
060A:  RCALL  054C
....................    i2c_stop(); 
060C:  BCF    F95.6
060E:  NOP   
0610:  BSF    F95.7
0612:  BTFSS  F83.7
0614:  BRA    0612
0616:  MOVLW  05
0618:  MOVWF  00
061A:  DECFSZ 00,F
061C:  BRA    061A
061E:  BRA    0620
0620:  NOP   
0622:  BSF    F95.6
0624:  MOVLW  05
0626:  MOVWF  00
0628:  DECFSZ 00,F
062A:  BRA    0628
....................    i2c_start(); 
062C:  BSF    F95.6
062E:  MOVLW  05
0630:  MOVWF  00
0632:  DECFSZ 00,F
0634:  BRA    0632
0636:  BSF    F95.7
0638:  MOVLW  06
063A:  MOVWF  00
063C:  DECFSZ 00,F
063E:  BRA    063C
0640:  BCF    F8C.6
0642:  BCF    F95.6
0644:  MOVLW  05
0646:  MOVWF  00
0648:  DECFSZ 00,F
064A:  BRA    0648
064C:  BCF    F8C.7
064E:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0650:  MOVLW  A0
0652:  MOVLB  1
0654:  MOVWF  xDA
0656:  MOVLB  0
0658:  RCALL  054C
065A:  MOVF   01,W
065C:  MOVLB  1
065E:  BCF    xD7.0
0660:  BTFSC  01.0
0662:  BSF    xD7.0
....................    while(status==1) 
0664:  BTFSS  xD7.0
0666:  BRA    06A4
....................    { 
....................    i2c_start(); 
0668:  BSF    F95.6
066A:  MOVLW  05
066C:  MOVWF  00
066E:  DECFSZ 00,F
0670:  BRA    066E
0672:  BSF    F95.7
0674:  MOVLW  06
0676:  MOVWF  00
0678:  DECFSZ 00,F
067A:  BRA    0678
067C:  BTFSS  F83.7
067E:  BRA    067C
0680:  BCF    F8C.6
0682:  BCF    F95.6
0684:  MOVLW  05
0686:  MOVWF  00
0688:  DECFSZ 00,F
068A:  BRA    0688
068C:  BCF    F8C.7
068E:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0690:  MOVLW  A0
0692:  MOVWF  xDA
0694:  MOVLB  0
0696:  RCALL  054C
0698:  MOVF   01,W
069A:  MOVLB  1
069C:  BCF    xD7.0
069E:  BTFSC  01.0
06A0:  BSF    xD7.0
06A2:  BRA    0664
....................    } 
....................    i2c_stop(); 
06A4:  BCF    F95.6
06A6:  NOP   
06A8:  BSF    F95.7
06AA:  BTFSS  F83.7
06AC:  BRA    06AA
06AE:  MOVLW  05
06B0:  MOVWF  00
06B2:  DECFSZ 00,F
06B4:  BRA    06B2
06B6:  BRA    06B8
06B8:  NOP   
06BA:  BSF    F95.6
06BC:  MOVLW  05
06BE:  MOVWF  00
06C0:  DECFSZ 00,F
06C2:  BRA    06C0
06C4:  MOVLB  0
06C6:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0782:  BSF    F95.6
0784:  MOVLW  05
0786:  MOVWF  00
0788:  DECFSZ 00,F
078A:  BRA    0788
078C:  BSF    F95.7
078E:  MOVLW  06
0790:  MOVWF  00
0792:  DECFSZ 00,F
0794:  BRA    0792
0796:  BCF    F8C.6
0798:  BCF    F95.6
079A:  MOVLW  05
079C:  MOVWF  00
079E:  DECFSZ 00,F
07A0:  BRA    079E
07A2:  BCF    F8C.7
07A4:  BCF    F95.7
....................    i2c_write(0xa0); 
07A6:  MOVLW  A0
07A8:  MOVLB  1
07AA:  MOVWF  xDA
07AC:  MOVLB  0
07AE:  RCALL  054C
....................    i2c_write(address>>8); 
07B0:  MOVFF  1D5,1D7
07B4:  MOVLB  1
07B6:  CLRF   xD8
07B8:  MOVFF  1D5,1DA
07BC:  MOVLB  0
07BE:  RCALL  054C
....................    i2c_write(address); 
07C0:  MOVFF  1D4,1DA
07C4:  RCALL  054C
....................    i2c_start(); 
07C6:  BSF    F95.6
07C8:  MOVLW  05
07CA:  MOVWF  00
07CC:  DECFSZ 00,F
07CE:  BRA    07CC
07D0:  BSF    F95.7
07D2:  MOVLW  06
07D4:  MOVWF  00
07D6:  DECFSZ 00,F
07D8:  BRA    07D6
07DA:  BTFSS  F83.7
07DC:  BRA    07DA
07DE:  BCF    F8C.6
07E0:  BCF    F95.6
07E2:  MOVLW  05
07E4:  MOVWF  00
07E6:  DECFSZ 00,F
07E8:  BRA    07E6
07EA:  BCF    F8C.7
07EC:  BCF    F95.7
....................    i2c_write(0xa1); 
07EE:  MOVLW  A1
07F0:  MOVLB  1
07F2:  MOVWF  xDA
07F4:  MOVLB  0
07F6:  RCALL  054C
....................    data=i2c_read(0); 
07F8:  CLRF   00
07FA:  BRA    0716
07FC:  MOVFF  01,1D6
....................    i2c_stop(); 
0800:  BCF    F95.6
0802:  NOP   
0804:  BSF    F95.7
0806:  BTFSS  F83.7
0808:  BRA    0806
080A:  MOVLW  05
080C:  MOVWF  00
080E:  DECFSZ 00,F
0810:  BRA    080E
0812:  BRA    0814
0814:  NOP   
0816:  BSF    F95.6
0818:  MOVLW  05
081A:  MOVWF  00
081C:  DECFSZ 00,F
081E:  BRA    081C
....................    return(data); 
0820:  MOVLB  1
0822:  MOVFF  1D6,01
0826:  MOVLB  0
0828:  RETURN 0
.................... } 
....................  
.................... //****************************************************************************** 
.................... // entradas 
.................... #define entrada01 PIN_B4 ////SENSOR 1              2  1 
.................... #define entrada02 PIN_D4 ////SENSOR 2              4  3 
.................... #define entrada03 PIN_B2 ////SENSOR 3              6  5 
.................... #define entrada04 PIN_B3 ////SENSOR 4 
.................... #define entrada05 PIN_B0 ////SENSOR 5 
.................... #define entrada06 PIN_B1 ////SENSOR 6 
....................  
.................... #define rst_cta PIN_D3    ////REINICIAR CONTADOR 
.................... #define frente PIN_D2     /// INDICADOR DE MAESTRO 
.................... #define B_silencio PIN_D1 /// BOTON PARA SILENCIAR (eliminado) 
.................... // salidas 
.................... #define salida01 PIN_C3 // Buzzer 
.................... #define salida02 PIN_C4 // Indicador de Sensado 
.................... #define salida03 PIN_C5 // Relay 
....................  
.................... #define HB PIN_E0 // habilita recepcion de datos en gprs  pin 25->D39 
.................... #define EN PIN_E1 // monitor de "envio listo" desde gprs  pin 26->D38 
....................  
.................... const int s_cta = 5; // numero de veces para verificar obsturbcion (sensibilidad de deteccion) 
.................... int size_s;          // Tama�o de trama que espera leer el puerto serial (se utiliza para agilizar la captura de datos) 
.................... ///////VARIABLES DE CONEXION///// 
.................... int error, transmitir; // variable para indicar un error al escuchar la cuenta del poste trasero, bandera para inciar transmision a gprs 
.................... ///////GENERALES////////////////////// 
.................... int sumae1, sumas1;                                                  // Variables temporales de suma de entradas y salidas 
.................... int lim_b;                                                           // cuenta de sensores bloqueados 
.................... int fse1, fse2, fse3, fss1, fss2, fss3;                              // banderas que indican si los pares de sensores detectaron entrada o salida 
.................... unsigned int16 temporal1, temporal2, tempo_tn, sub_atras, baj_atras; // variables temporales para hacer calculos. 
.................... int16 entran1, salen1;                                               // variables temporales para hacer calculos. 
.................... ///////--------------------/////////// 
.................... int16 salian, time_clr; // variable temporal para guardar salidas 
.................... int ini, i, ii, j = 0, a, master = 0, flag_enviar, f_clr; 
.................... int16 b, n, cta_bloqueo, cta_enviar, total2_t;                                                //,envia_ent,envia_sal; 
.................... int cta_bloq1 = 0, cta_bloq2 = 0, cta_bloq3 = 0;                                              // variables para contar bloqueos por pares 
.................... int ent1 = 0, ent2 = 0, ent3 = 0, ent4 = 0, ent5 = 0, ent6 = 0;                               // variables de estado de sensores 
.................... int sen_ent = 0, sen_sal = 0;                                                                 // variables para definir el sentido (subio o bajo) 
.................... int16 sub_cta1 = 0, sub_cta2 = 0, sub_cta3 = 0, sub_cta4 = 0, sub_cta5 = 0, sub_cta6 = 0;     // variables para calculos de cuentas 
.................... int detec1, detec2, detec3, detec4, detec5, detec6;                                           // variables para determinar el cambio de estado de los sensores 
.................... int sub_d1, sub_d2, sub_d3, sub_d4, sub_d5, sub_d6;                                           // variables para determinar el cambio de estado de los sensores 
.................... int entra_act1 = 0, edo1 = 0, entra1 = 0, sale1 = 0, edoa1 = 0, enable1 = 0, entra_temp1 = 0; // variables para la maquina de estados de sensores par1 
.................... int entra_act2 = 0, edo2 = 0, entra2 = 0, sale2 = 0, edoa2 = 0, enable2 = 0, entra_temp2 = 0; // variables para la maquina de estados de sensores par2 
.................... int entra_act3 = 0, edo3 = 0, entra3 = 0, sale3 = 0, edoa3 = 0, enable3 = 0, entra_temp3 = 0; // variables para la maquina de estados de sensores par3 
.................... int16 entraront = 0, salieront = 0, pasaje = 0, pasajet = 0;                                  // cuenta total de entradas y salidas 
.................... int16 tem_entraront = 0, tem_salieront = 0, temporal3;                                        // cuenta total de entradas y salidas recibidas de cuentas del poste trasero. 
.................... int des1 = 0, des2 = 0, des3 = 0; 
.................... int bloq_p1, bloq_p2, bloq_p3, en_b1, en_b2, en_b3; 
.................... int16 tim_p1, tim_p2, tim_p3, segundoen, time_envio; 
.................... const int32 set_timer = 59286;  // 10ms 
.................... const int16 time_bloqueo = 500; // 5seg. 100=1seg. 
.................... int clear_lcd1, time_lcd1; 
.................... int y = 0; 
.................... int bandera_revision = 0; 
.................... int16 cntbnd = 0; 
.................... int nuevo_pulso = 0; 
.................... int time_s3 = 0; 
.................... int fls3 = 0; 
.................... int cta_pulsos = 0; 
....................  
.................... // variables temporales para la conversion de string a entero de datos seriales de la cuenta de pasajeros del poste trasero/// 
.................... char term[3], *ptr; 
.................... char data1[14]; 
.................... char data2[10]; 
.................... char data3[10]; 
.................... char data4[10]; 
.................... char data5[10]; 
.................... int caso_valor = 0; 
.................... int solicitud_reset_gps = 0; 
....................  
.................... // lista de comandos para contadores /// 
.................... char *textosearch[11] = {"V5.01     \r", 
....................                          "BORRAR_ALL\r", 
....................                          "GRABAR_DAT\r", 
....................                          "LEERCUENTA\r", // 
....................                          "SOLICITADO\r", 
....................                          "PASAJEROS:\r", 
....................                          "SERIALTEST\r", 
....................                          "SERIAL_TOK\r", 
....................                          "SUBIENDOC2\r", 
....................                          "SINFUNCION\r", 
....................                          "          \r"}; 
....................  
.................... char version[] = "V1.0"; //<---Version de codigo de contador 
....................  
.................... /////EEPROM/////////// 
.................... const int word_size = 10; // TAMA�O DE LOS DATOS EN EEPROM//antes 8 
.................... const int data_set = 9; 
.................... // char XX[word_size+19];// ARREGLO SERIAL 
.................... char XX[word_size + 22]; // ARREGLO SERIAL 
.................... char entran[5]; 
.................... char salen[5]; 
.................... char bloqueado[5]; 
.................... char memory[word_size]; 
.................... //*******************************// 
.................... char tempo_tc[5]; 
.................... /////////////FUNCIONES///////////// 
.................... void rev_suben(); 
.................... void cuenta_pulsos(); 
.................... void rev_suben(); 
.................... void enviop1(); 
.................... void finsuma(); 
.................... void leer_conta2(); 
.................... void graba_conta2(); 
....................  
.................... //int convertir_to_entero(char *cadena); 
.................... int evaluar_string(char *command[]); 
.................... void envia2(); 
.................... void solicitar(); 
.................... void envio_master(); 
.................... void envio(); 
.................... void limpiar(); 
.................... void detecta_suma(); 
.................... void write_ent(); 
.................... void write_sal(); 
.................... void entraron_total(); 
.................... void salieron_total(); 
.................... //void rd_eeprom(); 
.................... void rd_eeprom_inicio(); 
.................... // void llaves(); 
....................  
.................... void lcd_cuentas(); 
.................... void sentidos(); 
.................... void sensores(); 
.................... void sensando1(); 
.................... void sensando2(); 
.................... void sensando3(); 
.................... void contando1(); 
.................... void contando2(); 
.................... void contando3(); 
.................... void dar_dato(); 
.................... void reset(); 
.................... //------------------------------------------------------------------------------ 
.................... // Rutina de gesti�n de interrupciones 
.................... //------------------------------------------------------------------------------ 
.................... #int_TIMER1 // se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void) 
.................... { 
....................    time_clr++; 
*
010A:  INCF   3E,F
010C:  BTFSC  FD8.2
010E:  INCF   3F,F
....................    time_s3++; 
0110:  INCF   xB2,F
....................    segundoen++; 
0112:  INCF   xA7,F
0114:  BTFSC  FD8.2
0116:  INCF   xA8,F
....................    if (segundoen >= 100) 
0118:  MOVF   xA8,F
011A:  BNZ   0122
011C:  MOVF   xA7,W
011E:  SUBLW  63
0120:  BC    012E
....................    { 
....................       segundoen = 0; 
0122:  CLRF   xA8
0124:  CLRF   xA7
....................       time_envio++; 
0126:  INCF   xA9,F
0128:  BTFSC  FD8.2
012A:  INCF   xAA,F
....................       time_lcd1++; 
012C:  INCF   xAC,F
....................    } 
....................    //****Se definen los estados de los sensores (deteccion)***// 
....................    // sensor1 
....................    ent1 = input(entrada01); 
012E:  BSF    F93.4
0130:  CLRF   55
0132:  BTFSC  F81.4
0134:  INCF   55,F
....................    if (ent1 == 0) 
0136:  MOVF   55,F
0138:  BNZ   0140
....................       sub_cta1++; // ent1 =0 (no pulso) 
013A:  INCF   5D,F
013C:  BTFSC  FD8.2
013E:  INCF   5E,F
....................    // sensor2 
....................    ent2 = input(entrada02); 
0140:  BSF    F95.4
0142:  CLRF   56
0144:  BTFSC  F83.4
0146:  INCF   56,F
....................    if (ent2 == 0) 
0148:  MOVF   56,F
014A:  BNZ   0152
....................       sub_cta2++; 
014C:  INCF   5F,F
014E:  BTFSC  FD8.2
0150:  INCF   x60,F
....................    // sensor3 
....................    ent3 = input(entrada03); 
0152:  BSF    F93.2
0154:  CLRF   57
0156:  BTFSC  F81.2
0158:  INCF   57,F
....................    if (ent3 == 0) 
015A:  MOVF   57,F
015C:  BNZ   0164
....................       sub_cta3++; 
015E:  INCF   x61,F
0160:  BTFSC  FD8.2
0162:  INCF   x62,F
....................    // sensor4 
....................    ent4 = input(entrada04); 
0164:  BSF    F93.3
0166:  CLRF   58
0168:  BTFSC  F81.3
016A:  INCF   58,F
....................    if (ent4 == 0) 
016C:  MOVF   58,F
016E:  BNZ   0176
....................       sub_cta4++; 
0170:  INCF   x63,F
0172:  BTFSC  FD8.2
0174:  INCF   x64,F
....................    // sensor5 
....................    ent5 = input(entrada05); 
0176:  BSF    F93.0
0178:  CLRF   59
017A:  BTFSC  F81.0
017C:  INCF   59,F
....................    if (ent5 == 0) 
017E:  MOVF   59,F
0180:  BNZ   0188
....................       sub_cta5++; 
0182:  INCF   x65,F
0184:  BTFSC  FD8.2
0186:  INCF   x66,F
....................    // sensor6 
....................    ent6 = input(entrada06); 
0188:  BSF    F93.1
018A:  CLRF   5A
018C:  BTFSC  F81.1
018E:  INCF   5A,F
....................    if (ent6 == 0) 
0190:  MOVF   5A,F
0192:  BNZ   019A
....................       sub_cta6++; 
0194:  INCF   x67,F
0196:  BTFSC  FD8.2
0198:  INCF   x68,F
....................    //****************************************// 
....................    tim_p1++; 
019A:  INCF   xA1,F
019C:  BTFSC  FD8.2
019E:  INCF   xA2,F
....................    tim_p2++; 
01A0:  INCF   xA3,F
01A2:  BTFSC  FD8.2
01A4:  INCF   xA4,F
....................    tim_p3++; 
01A6:  INCF   xA5,F
01A8:  BTFSC  FD8.2
01AA:  INCF   xA6,F
....................    cta_enviar++; 
01AC:  INCF   4E,F
01AE:  BTFSC  FD8.2
01B0:  INCF   4F,F
....................    set_timer1(set_timer); // 10ms 
01B2:  MOVLW  E7
01B4:  MOVWF  FCF
01B6:  MOVLW  96
01B8:  MOVWF  FCE
.................... } 
.................... //****************************************************************************// 
....................  
.................... //----------------------------------------------------------------------------- 
.................... // timer para la el tiempo de espera del puerto serial emulado, datos del gprs// 
01BA:  BCF    F9E.0
01BC:  GOTO   0078
.................... #int_TIMER3 
.................... void TIMER3_isr(void) 
.................... { 
....................    cntbnd++; // bandera de conteo de timepo de espera de para puerto serial emlado 
01C0:  INCF   xAF,F
01C2:  BTFSC  FD8.2
01C4:  INCF   xB0,F
....................    set_timer3(65036); 
01C6:  MOVLW  FE
01C8:  MOVWF  FB3
01CA:  MOVLW  0C
01CC:  MOVWF  FB2
.................... } 
....................  
.................... //----------------------------------------------------------------------------- 
.................... // captura de datos seriales entre postes, delantero y trasero ///////////// 
01CE:  BCF    FA1.1
01D0:  GOTO   0078
.................... #int_rda 
.................... void isr_rs232() 
.................... {                              // escucha segundo poste 
....................    disable_interrupts(GLOBAL); // deshabilita interrupciones globales 
*
0232:  BCF    FF2.6
0234:  BCF    FF2.7
0236:  BTFSC  FF2.7
0238:  BRA    0234
....................    i = 0;                      // CONTADOR DE ARREGLO SERIAL INICIADO 
023A:  CLRF   41
....................    while (i <= 30) 
023C:  MOVF   41,W
023E:  SUBLW  1E
0240:  BNC   0280
....................    { 
....................       XX[i] = fgetc(monitor); 
0242:  CLRF   03
0244:  MOVF   41,W
0246:  ADDLW  91
0248:  MOVWF  FE9
024A:  MOVLW  01
024C:  ADDWFC 03,W
024E:  MOVWF  FEA
0250:  MOVFF  FEA,1E6
0254:  MOVFF  FE9,1E5
0258:  BRA    01F6
025A:  MOVFF  1E6,FEA
025E:  MOVFF  1E5,FE9
0262:  MOVFF  01,FEF
....................       i++; 
0266:  INCF   41,F
....................       if (XX[i] == 13) 
0268:  CLRF   03
026A:  MOVF   41,W
026C:  ADDLW  91
026E:  MOVWF  FE9
0270:  MOVLW  01
0272:  ADDWFC 03,W
0274:  MOVWF  FEA
0276:  MOVF   FEF,W
0278:  SUBLW  0D
027A:  BNZ   027E
....................          break; 
027C:  BRA    0280
027E:  BRA    023C
....................    } // se captura el dato del serial monitor(comunicacion entre pics) 
....................    j = 1; 
0280:  MOVLW  01
0282:  MOVWF  43
....................    y = 1; 
0284:  MOVWF  xAD
....................    // sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
....................  
0286:  BCF    F9E.5
0288:  GOTO   0078
.................... #ZERO_RAM 
.................... void main() 
*
2B52:  CLRF   FF8
2B54:  BCF    FD0.7
2B56:  BSF    07.7
2B58:  MOVLW  FE
2B5A:  MOVWF  00
2B5C:  MOVLW  06
2B5E:  MOVWF  01
2B60:  MOVLW  02
2B62:  MOVWF  FE9
2B64:  MOVLW  00
2B66:  MOVWF  FEA
2B68:  CLRF   FEE
2B6A:  DECFSZ 00,F
2B6C:  BRA    2B68
2B6E:  DECFSZ 01,F
2B70:  BRA    2B68
2B72:  CLRF   1F
2B74:  BSF    FB8.3
2B76:  MOVLW  08
2B78:  MOVWF  FAF
2B7A:  MOVLW  02
2B7C:  MOVWF  FB0
2B7E:  MOVLW  A6
2B80:  MOVWF  FAC
2B82:  MOVLW  90
2B84:  MOVWF  FAB
2B86:  CLRF   20
2B88:  BCF    F94.1
2B8A:  BSF    F8B.1
2B8C:  CLRF   43
2B8E:  CLRF   45
2B90:  CLRF   52
2B92:  CLRF   53
2B94:  CLRF   54
2B96:  CLRF   55
2B98:  CLRF   56
2B9A:  CLRF   57
2B9C:  CLRF   58
2B9E:  CLRF   59
2BA0:  CLRF   5A
2BA2:  CLRF   5B
2BA4:  CLRF   5C
2BA6:  CLRF   5E
2BA8:  CLRF   5D
2BAA:  CLRF   x60
2BAC:  CLRF   5F
2BAE:  CLRF   x62
2BB0:  CLRF   x61
2BB2:  CLRF   x64
2BB4:  CLRF   x63
2BB6:  CLRF   x66
2BB8:  CLRF   x65
2BBA:  CLRF   x68
2BBC:  CLRF   x67
2BBE:  CLRF   x75
2BC0:  CLRF   x76
2BC2:  CLRF   x77
2BC4:  CLRF   x78
2BC6:  CLRF   x79
2BC8:  CLRF   x7A
2BCA:  CLRF   x7B
2BCC:  CLRF   x7C
2BCE:  CLRF   x7D
2BD0:  CLRF   x7E
2BD2:  CLRF   x7F
2BD4:  CLRF   x80
2BD6:  CLRF   x81
2BD8:  CLRF   x82
2BDA:  CLRF   x83
2BDC:  CLRF   x84
2BDE:  CLRF   x85
2BE0:  CLRF   x86
2BE2:  CLRF   x87
2BE4:  CLRF   x88
2BE6:  CLRF   x89
2BE8:  CLRF   x8B
2BEA:  CLRF   x8A
2BEC:  CLRF   x8D
2BEE:  CLRF   x8C
2BF0:  CLRF   x8F
2BF2:  CLRF   x8E
2BF4:  CLRF   x91
2BF6:  CLRF   x90
2BF8:  CLRF   x93
2BFA:  CLRF   x92
2BFC:  CLRF   x95
2BFE:  CLRF   x94
2C00:  CLRF   x98
2C02:  CLRF   x99
2C04:  CLRF   x9A
2C06:  CLRF   xAD
2C08:  CLRF   xAE
2C0A:  CLRF   xB0
2C0C:  CLRF   xAF
2C0E:  CLRF   xB1
2C10:  CLRF   xB2
2C12:  CLRF   xB3
2C14:  CLRF   xB4
2C16:  CLRF   xF0
2C18:  CLRF   xF1
2C1A:  MOVF   FC1,W
2C1C:  ANDLW  C0
2C1E:  IORLW  0F
2C20:  MOVWF  FC1
2C22:  MOVLW  07
2C24:  MOVWF  FB4
2C26:  BRA    2CD2
2C28:  DATA 02,00
2C2A:  DATA 19,00
2C2C:  DATA 00,05
2C2E:  DATA 01,08
2C30:  DATA 56,35
2C32:  DATA 2E,30
2C34:  DATA 31,05
2C36:  DATA C0,20
2C38:  DATA 6E,80
2C3A:  DATA 0D,00
2C3C:  DATA 42,4F
2C3E:  DATA 52,52
2C40:  DATA 41,52
2C42:  DATA 5F,41
2C44:  DATA 4C,4C
2C46:  DATA 0D,00
2C48:  DATA 47,52
2C4A:  DATA 41,42
2C4C:  DATA 41,52
2C4E:  DATA 5F,44
2C50:  DATA 41,54
2C52:  DATA 0D,00
2C54:  DATA 4C,45
2C56:  DATA 45,52
2C58:  DATA 43,55
2C5A:  DATA 45,4E
2C5C:  DATA 54,41
2C5E:  DATA 0D,00
2C60:  DATA 53,4F
2C62:  DATA 4C,49
2C64:  DATA 43,49
2C66:  DATA 54,41
2C68:  DATA 44,4F
2C6A:  DATA 0D,00
2C6C:  DATA 50,41
2C6E:  DATA 53,41
2C70:  DATA 4A,45
2C72:  DATA 52,4F
2C74:  DATA 53,3A
2C76:  DATA 0D,00
2C78:  DATA 53,45
2C7A:  DATA 52,49
2C7C:  DATA 41,4C
2C7E:  DATA 54,45
2C80:  DATA 53,54
2C82:  DATA 0D,00
2C84:  DATA 53,45
2C86:  DATA 52,49
2C88:  DATA 41,4C
2C8A:  DATA 5F,54
2C8C:  DATA 4F,4B
2C8E:  DATA 0D,00
2C90:  DATA 53,55
2C92:  DATA 42,49
2C94:  DATA 45,4E
2C96:  DATA 44,4F
2C98:  DATA 43,32
2C9A:  DATA 0D,00
2C9C:  DATA 53,49
2C9E:  DATA 4E,46
2CA0:  DATA 55,4E
2CA2:  DATA 43,49
2CA4:  DATA 4F,4E
2CA6:  DATA 0D,00
2CA8:  DATA 0A,C0
2CAA:  DATA 20,02
2CAC:  DATA 80,0D
2CAE:  DATA 00,16
2CB0:  DATA 00,F2
2CB2:  DATA 08,01
2CB4:  DATA 14,01
2CB6:  DATA 20,01
2CB8:  DATA 2C,01
2CBA:  DATA 38,01
2CBC:  DATA 44,01
2CBE:  DATA 50,01
2CC0:  DATA 5C,01
2CC2:  DATA 68,01
2CC4:  DATA 74,01
2CC6:  DATA 80,01
2CC8:  DATA 05,01
2CCA:  DATA 8C,56
2CCC:  DATA 31,2E
2CCE:  DATA 30,00
2CD0:  DATA 00,00
2CD2:  MOVLW  00
2CD4:  MOVWF  FF8
2CD6:  MOVLW  2C
2CD8:  MOVWF  FF7
2CDA:  MOVLW  28
2CDC:  MOVWF  FF6
2CDE:  TBLRD*+
2CE0:  MOVF   FF5,W
2CE2:  MOVWF  00
2CE4:  XORLW  00
2CE6:  BZ    2D0E
2CE8:  TBLRD*+
2CEA:  MOVF   FF5,W
2CEC:  MOVWF  01
2CEE:  BTFSC  FE8.7
2CF0:  BRA    2CFC
2CF2:  ANDLW  0F
2CF4:  MOVWF  FEA
2CF6:  TBLRD*+
2CF8:  MOVFF  FF5,FE9
2CFC:  BTFSC  01.6
2CFE:  TBLRD*+
2D00:  BTFSS  01.6
2D02:  TBLRD*+
2D04:  MOVFF  FF5,FEE
2D08:  DCFSNZ 00,F
2D0A:  BRA    2CDE
2D0C:  BRA    2D00
2D0E:  CLRF   FF8
.................... { 
....................    // Apaga entradas analogicas 
....................    setup_adc_ports(NO_ANALOGS); 
2D10:  MOVF   FC1,W
2D12:  ANDLW  C0
2D14:  IORLW  0F
2D16:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
2D18:  BCF    FC2.0
....................    lcd_init();                               // inicia LCD 
2D1A:  GOTO   04D0
....................    init_ext_eeprom();                        // Inicia EEPROM 
2D1E:  GOTO   0544
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); // Configura timer1:Reloj interno, preescaler=8 
2D22:  MOVLW  B5
2D24:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);            // Habilito interrupci�n particular del TIMER1 
2D26:  BSF    F9D.0
....................    set_timer1(set_timer);                    // Setea cuenta para la interrupcion. 
2D28:  MOVLW  E7
2D2A:  MOVWF  FCF
2D2C:  MOVLW  96
2D2E:  MOVWF  FCE
....................    disable_interrupts(INT_EXT);              // desabilita interrupciones externas 
2D30:  BCF    FF2.4
....................    enable_interrupts(GLOBAL);                // habilita interrupciones globales 
2D32:  MOVLW  C0
2D34:  IORWF  FF2,F
....................    ///**************************************************************************/// 
....................    ////////Confuguracion de PWM//////// 
....................    output_low(PIN_C2); // CCP1 
2D36:  BCF    F94.2
2D38:  BCF    F8B.2
....................    setup_ccp1(CCP_PWM); 
2D3A:  BCF    F94.2
2D3C:  BCF    F8B.2
2D3E:  MOVLW  0C
2D40:  MOVWF  FBD
....................    setup_timer_2(t2_div_By_1, 131, 1); // frecuencia 38khz 
2D42:  MOVLW  00
2D44:  IORLW  04
2D46:  MOVWF  FCA
2D48:  MOVLW  83
2D4A:  MOVWF  FCB
....................    // set_pwm1_duty(26);//(5%) alto 
....................    set_pwm1_duty(279); //(10%) Parte alta del ciclo 
2D4C:  MOVLW  45
2D4E:  MOVWF  FBE
2D50:  MOVF   FBD,W
2D52:  ANDLW  CF
2D54:  IORLW  30
2D56:  MOVWF  FBD
....................    //////////////////////////////////// 
....................    ini = read_eeprom(100); // Carga estado de inicio 
2D58:  MOVFF  FF2,1D0
2D5C:  BCF    FF2.7
2D5E:  MOVLW  64
2D60:  MOVWF  FA9
2D62:  BCF    FA6.6
2D64:  BCF    FA6.7
2D66:  BSF    FA6.0
2D68:  MOVF   FA8,W
2D6A:  MOVLB  1
2D6C:  BTFSC  xD0.7
2D6E:  BSF    FF2.7
2D70:  MOVWF  40
....................    if (ini != 1) 
2D72:  DECFSZ 40,W
2D74:  BRA    2D78
2D76:  BRA    2DAA
....................    {                        // Verifica si es la primera vez que se enciende el poste y graba configuracion inicial 
....................       write_eeprom(100, 1); // Graba inicio 
2D78:  MOVF   FF2,W
2D7A:  MOVWF  00
2D7C:  BCF    FF2.7
2D7E:  MOVLW  64
2D80:  MOVWF  FA9
2D82:  MOVLW  01
2D84:  MOVWF  FA8
2D86:  BCF    FA6.6
2D88:  BCF    FA6.7
2D8A:  BSF    FA6.2
2D8C:  MOVLB  F
2D8E:  MOVLW  55
2D90:  MOVWF  FA7
2D92:  MOVLW  AA
2D94:  MOVWF  FA7
2D96:  BSF    FA6.1
2D98:  BTFSC  FA6.1
2D9A:  BRA    2D98
2D9C:  BCF    FA6.2
2D9E:  MOVF   00,W
2DA0:  IORWF  FF2,F
....................       limpiar();            // pone en 0 el registro de cuentas almacenadas. 
2DA2:  MOVLB  0
2DA4:  CALL   0D2A
2DA8:  MOVLB  1
....................    } 
....................    ///////////////////////////////////////////////////////////////////////////////////////////////// 
....................    entraron_total();                            // carga el total de entradas registradas 
2DAA:  MOVLB  0
2DAC:  GOTO   0D96
....................    salieron_total();                            // carga el total de salidas registradas 
2DB0:  GOTO   0DF0
....................    ent1 = ent2 = ent3 = ent4 = ent5 = ent6 = 0; // inicia en 0 variables de estado de sensores 
2DB4:  CLRF   5A
2DB6:  MOVFF  5A,59
2DBA:  MOVFF  59,58
2DBE:  MOVFF  58,57
2DC2:  MOVFF  57,56
2DC6:  MOVFF  56,55
....................    tim_p1 = tim_p2 = tim_p3 = 0;                // inicia en 0 las cuentas para detectar sensores bloqueados 
2DCA:  CLRF   xA6
2DCC:  CLRF   xA5
2DCE:  MOVFF  A6,A4
2DD2:  MOVFF  A5,A3
2DD6:  MOVFF  A4,A2
2DDA:  MOVFF  A3,A1
....................    en_b1 = en_b2 = en_b3 = 0;                   // bandera de pares bloqueados 
2DDE:  CLRF   xA0
2DE0:  MOVFF  A0,9F
2DE4:  MOVFF  9F,9E
....................    time_envio = 0;                              // inicia en 0 cuenta para transmitir datos 
2DE8:  CLRF   xAA
2DEA:  CLRF   xA9
....................    if (input(frente)) 
2DEC:  BSF    F95.2
2DEE:  BTFSS  F83.2
2DF0:  BRA    2DFC
....................    { // revisa si es maestro (1) o escalvo (2) 
....................       master = 1; 
2DF2:  MOVLW  01
2DF4:  MOVWF  45
....................       size_s = 29; 
2DF6:  MOVLW  1D
2DF8:  MOVWF  22
....................    } 
2DFA:  BRA    2E02
....................    else 
....................    { 
....................       master = 0; 
2DFC:  CLRF   45
....................       size_s = 15; 
2DFE:  MOVLW  0F
2E00:  MOVWF  22
....................    } 
....................    lcd_cuentas();                   // Escribe texto base en LCD 
2E02:  CALL   0A72
....................    cta_bloq1 = read_ext_eeprom(9);  // carga bloqueos acumulados en par1 
2E06:  MOVLB  1
2E08:  CLRF   xD5
2E0A:  MOVLW  09
2E0C:  MOVWF  xD4
2E0E:  MOVLB  0
2E10:  CALL   0782
2E14:  MOVFF  01,52
....................    cta_bloq2 = read_ext_eeprom(10); // carga bloqueos acumulados en par2 
2E18:  MOVLB  1
2E1A:  CLRF   xD5
2E1C:  MOVLW  0A
2E1E:  MOVWF  xD4
2E20:  MOVLB  0
2E22:  CALL   0782
2E26:  MOVFF  01,53
....................    cta_bloq3 = read_ext_eeprom(11); // carga bloqueos acumulados en par3 
2E2A:  MOVLB  1
2E2C:  CLRF   xD5
2E2E:  MOVLW  0B
2E30:  MOVWF  xD4
2E32:  MOVLB  0
2E34:  CALL   0782
2E38:  MOVFF  01,54
....................    int tem_res; 
....................    tem_res = input(rst_cta); // inicializa variable de reset de cuenta fisico 
2E3C:  BSF    F95.3
2E3E:  MOVLB  1
2E40:  CLRF   xCF
2E42:  BTFSC  F83.3
2E44:  INCF   xCF,F
....................    j = 0; 
2E46:  CLRF   43
....................    flag_enviar = 0; 
2E48:  CLRF   46
....................    salian = 0; 
2E4A:  CLRF   3D
2E4C:  CLRF   3C
....................    enable_interrupts(INT_RDA); // habilita interrupcion serial 
2E4E:  BSF    F9D.5
....................    setup_wdt(WDT_ON);          // habilita watch dog 
2E50:  BSF    FD1.0
....................    sub_cta1 = sub_cta2 = sub_cta3 = sub_cta4 = sub_cta5 = sub_cta6 = 0; 
2E52:  MOVLB  0
2E54:  CLRF   x68
2E56:  CLRF   x67
2E58:  MOVFF  68,66
2E5C:  MOVFF  67,65
2E60:  MOVFF  66,64
2E64:  MOVFF  65,63
2E68:  MOVFF  64,62
2E6C:  MOVFF  63,61
2E70:  MOVFF  62,60
2E74:  MOVFF  61,5F
2E78:  MOVFF  60,5E
2E7C:  MOVFF  5F,5D
....................    tem_entraront = tem_salieront = 0; 
2E80:  CLRF   x95
2E82:  CLRF   x94
2E84:  MOVFF  95,93
2E88:  MOVFF  94,92
....................    error = 0; 
2E8C:  CLRF   23
....................    reset(); // Revisa causa de inicio del pic 
2E8E:  GOTO   0E6C
....................    transmitir = 0; 
2E92:  CLRF   24
....................    output_low(salida02); 
2E94:  BCF    F94.4
2E96:  BCF    F8B.4
....................    sub_atras = baj_atras = 0; 
2E98:  CLRF   37
2E9A:  CLRF   36
2E9C:  MOVFF  37,35
2EA0:  MOVFF  36,34
....................    clear_lcd1 = 0; 
2EA4:  CLRF   xAB
....................  
....................    output_low(HB); // esperamos a que se aliste un dato del puerto serial emulado 
2EA6:  BCF    F96.0
2EA8:  BCF    F8D.0
....................    bandera_revision = 1; 
2EAA:  MOVLW  01
2EAC:  MOVWF  xAE
....................    caso_valor = 0; 
2EAE:  CLRF   xF0
....................  
....................    while (TRUE) 
....................    { 
....................       // solo para reinicializar interrupciones despues de obtener datos por puerto serial nato 
....................       if (y == 1) 
2EB0:  DECFSZ xAD,W
2EB2:  BRA    2EBA
....................       { 
....................          enable_interrupts(GLOBAL); // habilita interrupciones globales 
2EB4:  MOVLW  C0
2EB6:  IORWF  FF2,F
....................          y = 0; 
2EB8:  CLRF   xAD
....................       } 
....................       //////////////////////boton para reset cuenta//////////////////////////////////////////// 
....................       if (tem_res != input(rst_cta)) 
2EBA:  BSF    F95.3
2EBC:  MOVLW  00
2EBE:  BTFSC  F83.3
2EC0:  MOVLW  01
2EC2:  MOVLB  1
2EC4:  SUBWF  xCF,W
2EC6:  BZ    2F10
....................       { // BOTON DE RESET DE CUENTA 
....................          delay_ms(50); 
2EC8:  MOVLW  32
2ECA:  MOVWF  xDB
2ECC:  MOVLB  0
2ECE:  CALL   0418
....................          if (tem_res != input(rst_cta)) 
2ED2:  BSF    F95.3
2ED4:  MOVLW  00
2ED6:  BTFSC  F83.3
2ED8:  MOVLW  01
2EDA:  MOVLB  1
2EDC:  SUBWF  xCF,W
2EDE:  BZ    2F10
....................          { 
....................             tem_res = input(rst_cta); 
2EE0:  BSF    F95.3
2EE2:  CLRF   xCF
2EE4:  BTFSC  F83.3
2EE6:  INCF   xCF,F
....................             if ((master == 1) && (tem_res == 0)) 
2EE8:  DECFSZ 45,W
2EEA:  BRA    2F10
2EEC:  MOVF   xCF,F
2EEE:  BNZ   2F10
....................             { 
....................                fprintf(monitor, "BORRAR_ALL\r"); 
2EF0:  MOVLW  EA
2EF2:  MOVWF  FF6
2EF4:  MOVLW  00
2EF6:  MOVWF  FF7
2EF8:  MOVLB  0
2EFA:  CALL   0E4A
....................                printf(lcd_putc, "\fBORRAR_ALL"); 
2EFE:  MOVLW  8C
2F00:  MOVWF  FF6
2F02:  MOVLW  02
2F04:  MOVWF  FF7
2F06:  CALL   0A52
....................                limpiar(); 
2F0A:  CALL   0D2A
2F0E:  MOVLB  1
....................             } 
....................          } 
....................       } 
....................       //-------pines de monitoreo de datos seriales por puerto emulado---------------------------- 
....................       if (input(EN) == 1 && bandera_revision == 1) 
2F10:  BSF    F96.1
2F12:  BTFSS  F84.1
2F14:  BRA    2FB4
2F16:  MOVLB  0
2F18:  DECFSZ xAE,W
2F1A:  BRA    2F1E
2F1C:  BRA    2F22
2F1E:  MOVLB  1
2F20:  BRA    2FB4
....................       {                   // 1 
....................          output_high(HB); // avisa que ya est� listo para recibir dato serial 
2F22:  BCF    F96.0
2F24:  BSF    F8D.0
....................          cntbnd = 0; 
2F26:  CLRF   xB0
2F28:  CLRF   xAF
....................          // i=0; 
....................          bandera_revision = 0; 
2F2A:  CLRF   xAE
....................          output_high(salida03); 
2F2C:  BCF    F94.5
2F2E:  BSF    F8B.5
....................          // fprintf(monitor,"relay-"); 
....................          while (kbhit(GPS) != 1 || cntbnd >= 200) /// espera a que se complete dato serial o timer se agote 
2F30:  MOVLW  00
2F32:  BTFSS  F82.0
2F34:  MOVLW  01
2F36:  SUBLW  01
2F38:  BNZ   2F44
2F3A:  MOVF   xB0,F
2F3C:  BNZ   2F44
2F3E:  MOVF   xAF,W
2F40:  SUBLW  C7
2F42:  BC    2F4A
....................          // while (XX[0]==0 || cntbnd >= 200) /// espera a que se complete dato serial o timer se agote 
....................          { 
....................             bandera_revision = 1; 
2F44:  MOVLW  01
2F46:  MOVWF  xAE
2F48:  BRA    2F30
....................             // fprintf(monitor,"wh-"); 
....................          } 
....................          XX[0] = fgetc(GPS); 
2F4A:  GOTO   0EA4
2F4E:  MOVFF  01,191
....................  
....................          if (XX[0] == 63) 
2F52:  MOVLB  1
2F54:  MOVF   x91,W
2F56:  SUBLW  3F
2F58:  BNZ   2FB4
....................          { 
....................             output_low(salida03); 
2F5A:  BCF    F94.5
2F5C:  BCF    F8B.5
....................             j = 1; 
2F5E:  MOVLW  01
2F60:  MOVWF  43
....................             sub_cta1 = sub_cta2 = sub_cta3 = sub_cta4 = sub_cta5 = sub_cta6 = 0; // se inicializa cuenta pasajeros 
2F62:  MOVLB  0
2F64:  CLRF   x68
2F66:  CLRF   x67
2F68:  MOVFF  68,66
2F6C:  MOVFF  67,65
2F70:  MOVFF  66,64
2F74:  MOVFF  65,63
2F78:  MOVFF  64,62
2F7C:  MOVFF  63,61
2F80:  MOVFF  62,60
2F84:  MOVFF  61,5F
2F88:  MOVFF  60,5E
2F8C:  MOVFF  5F,5D
....................             solicitud_reset_gps = 1; 
2F90:  MOVWF  xF1
....................  
....................             strcpy(XX, "BORRAR_ALL\r"); // BORRAR_ALL\r 
2F92:  MOVWF  FEA
2F94:  MOVLW  91
2F96:  MOVWF  FE9
2F98:  MOVLW  00
2F9A:  CALL   00DA
2F9E:  TBLRD*-
2FA0:  TBLRD*+
2FA2:  MOVF   FF5,W
2FA4:  MOVWF  FEE
2FA6:  IORLW  00
2FA8:  BNZ   2FA0
....................             output_low(HB);             // se reinicia la espera de nuevo dato serial 
2FAA:  BCF    F96.0
2FAC:  BCF    F8D.0
....................             bandera_revision = 1; 
2FAE:  MOVLW  01
2FB0:  MOVWF  xAE
2FB2:  MOVLB  1
....................          } 
....................       } 
....................       //------------------------------------------------------------------------------ 
....................  
....................       if (j == 1) 
2FB4:  DECFSZ 43,W
2FB6:  BRA    3174
....................       {               // Revisa si hubo datos por cualquiera de los 2 puertos seriales 
....................          //rd_eeprom(); // valida dato recibido para ver si es una palabra de control 
....................          caso_valor = evaluar_string(XX); 
2FB8:  MOVLW  01
2FBA:  MOVWF  xD1
2FBC:  MOVLW  91
2FBE:  MOVWF  xD0
2FC0:  MOVLB  0
2FC2:  GOTO   0F96
2FC6:  MOVFF  01,F0
....................          lcd_gotoxy(9, 1); 
2FCA:  MOVLW  09
2FCC:  MOVLB  1
2FCE:  MOVWF  xDB
2FD0:  MOVLW  01
2FD2:  MOVWF  xDC
2FD4:  MOVLB  0
2FD6:  CALL   087C
....................          printf(lcd_putc, "%d ", caso_valor); // pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
2FDA:  MOVFF  F0,1D0
2FDE:  MOVLW  18
2FE0:  MOVLB  1
2FE2:  MOVWF  xD1
2FE4:  MOVLB  0
2FE6:  CALL   1050
2FEA:  MOVLW  20
2FEC:  MOVLB  1
2FEE:  MOVWF  xDA
2FF0:  MOVLB  0
2FF2:  CALL   08CE
....................  
....................          switch (caso_valor) 
2FF6:  MOVF   xF0,W
2FF8:  XORLW  01
2FFA:  BZ    301C
2FFC:  XORLW  03
2FFE:  BZ    3048
3000:  XORLW  01
3002:  BZ    304E
3004:  XORLW  07
3006:  BZ    308C
3008:  XORLW  01
300A:  BZ    3092
300C:  XORLW  03
300E:  BZ    30BA
3010:  XORLW  01
3012:  BZ    30EA
3014:  XORLW  0F
3016:  BTFSC  FD8.2
3018:  BRA    310E
301A:  BRA    3136
....................          { 
....................          case 1: 
....................          { // Se pone en 0 la cuenta 
....................             limpiar(); 
301C:  CALL   0D2A
....................             if (master == 1) 
3020:  DECFSZ 45,W
3022:  BRA    3030
....................                fprintf(monitor, "BORRAR_ALL\r"); // 4 
3024:  MOVLW  98
3026:  MOVWF  FF6
3028:  MOVLW  02
302A:  MOVWF  FF7
302C:  CALL   0E4A
....................             if (solicitud_reset_gps == 1 && master == 1) 
3030:  DECFSZ xF1,W
3032:  BRA    3046
3034:  DECFSZ 45,W
3036:  BRA    3046
....................             { 
....................                solicitud_reset_gps = 0; 
3038:  CLRF   xF1
....................                fprintf(GPS, "RESET_OK\r\n"); // confirma a gsm 
303A:  MOVLW  A4
303C:  MOVWF  FF6
303E:  MOVLW  02
3040:  MOVWF  FF7
3042:  CALL   1162
....................             } 
....................             break; 
3046:  BRA    3152
....................          } 
....................          case 2: 
....................          { // Se hace solicitud de cuenta del poste trasero 
....................             solicitar(); 
3048:  CALL   1182
....................             break; 
304C:  BRA    3152
....................          } 
....................          case 3: 
....................          { // Se pone en 0 la cuenta por peticion del GPRS 
....................             if (master == 1) 
304E:  DECFSZ 45,W
3050:  BRA    305E
....................                fprintf(GPS, "RESET_OK\r\n"); // confirma a gsm 
3052:  MOVLW  B0
3054:  MOVWF  FF6
3056:  MOVLW  02
3058:  MOVWF  FF7
305A:  CALL   1162
....................             delay_ms(1000); 
305E:  MOVLW  04
3060:  MOVLB  1
3062:  MOVWF  xD0
3064:  MOVLW  FA
3066:  MOVWF  xDB
3068:  MOVLB  0
306A:  CALL   0418
306E:  MOVLB  1
3070:  DECFSZ xD0,F
3072:  BRA    3064
....................             limpiar(); 
3074:  MOVLB  0
3076:  CALL   0D2A
....................             if (master == 1) 
307A:  DECFSZ 45,W
307C:  BRA    308A
....................                fprintf(monitor, "BORRAR_ALL\r"); // 4 
307E:  MOVLW  BC
3080:  MOVWF  FF6
3082:  MOVLW  02
3084:  MOVWF  FF7
3086:  CALL   0E4A
....................             break; 
308A:  BRA    3152
....................          } 
....................          case 4: 
....................          { // ver pasaje total de este acceso (contador atras) 
....................             envio_master(); 
308C:  CALL   119A
....................             break; 
3090:  BRA    3152
....................          } 
....................          case 5: 
....................          { // envia a GPS pasaje total actual de ambos accesos (recibe cuenta de atras y suma) 
....................             flag_enviar = 0; 
3092:  CLRF   46
....................             enviop1(); 
3094:  GOTO   1658
....................             transmitir = 1; 
3098:  MOVLW  01
309A:  MOVWF  24
....................             lcd_gotoxy(9, 4); 
309C:  MOVLW  09
309E:  MOVLB  1
30A0:  MOVWF  xDB
30A2:  MOVLW  04
30A4:  MOVWF  xDC
30A6:  MOVLB  0
30A8:  CALL   087C
....................             lcd_putc("C2OK"); 
30AC:  MOVLW  C8
30AE:  MOVWF  FF6
30B0:  MOVLW  02
30B2:  MOVWF  FF7
30B4:  CALL   0A52
....................  
....................             break; 
30B8:  BRA    3152
....................          } 
....................          case 6: 
....................          { // TEST DE COMUNICACION SERIAL 
....................             clear_lcd1 = 1; 
30BA:  MOVLW  01
30BC:  MOVWF  xAB
....................             time_lcd1 = 0; 
30BE:  CLRF   xAC
....................             lcd_gotoxy(9, 3); 
30C0:  MOVLW  09
30C2:  MOVLB  1
30C4:  MOVWF  xDB
30C6:  MOVLW  03
30C8:  MOVWF  xDC
30CA:  MOVLB  0
30CC:  CALL   087C
....................             lcd_putc("C1OK"); 
30D0:  MOVLW  CE
30D2:  MOVWF  FF6
30D4:  MOVLW  02
30D6:  MOVWF  FF7
30D8:  CALL   0A52
....................             fprintf(monitor, "SERIAL_TOK\r"); // 
30DC:  MOVLW  D4
30DE:  MOVWF  FF6
30E0:  MOVLW  02
30E2:  MOVWF  FF7
30E4:  CALL   0E4A
....................             break; 
30E8:  BRA    3152
....................          } 
....................          case 7: 
....................          { // CONFIRMACION DE COMUNICACION SERIAL 
....................             clear_lcd1 = 1; 
30EA:  MOVLW  01
30EC:  MOVWF  xAB
....................             time_lcd1 = 0; 
30EE:  CLRF   xAC
....................             lcd_gotoxy(9, 4); 
30F0:  MOVLW  09
30F2:  MOVLB  1
30F4:  MOVWF  xDB
30F6:  MOVLW  04
30F8:  MOVWF  xDC
30FA:  MOVLB  0
30FC:  CALL   087C
....................             lcd_putc("C2OK"); 
3100:  MOVLW  E0
3102:  MOVWF  FF6
3104:  MOVLW  02
3106:  MOVWF  FF7
3108:  CALL   0A52
....................             break; 
310C:  BRA    3152
....................          } 
....................          case 8: 
....................          { // Suben por atras 
....................             clear_lcd1 = 1; 
310E:  MOVLW  01
3110:  MOVWF  xAB
....................             time_lcd1 = 0; 
3112:  CLRF   xAC
....................             lcd_gotoxy(9, 4); 
3114:  MOVLW  09
3116:  MOVLB  1
3118:  MOVWF  xDB
311A:  MOVLW  04
311C:  MOVWF  xDC
311E:  MOVLB  0
3120:  CALL   087C
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
3124:  CALL   18C8
....................             lcd_putc("Sub2"); 
3128:  MOVLW  E6
312A:  MOVWF  FF6
312C:  MOVLW  02
312E:  MOVWF  FF7
3130:  CALL   0A52
....................             break; 
3134:  BRA    3152
....................          } 
....................          default: 
....................          { 
....................             lcd_gotoxy(9, 2); 
3136:  MOVLW  09
3138:  MOVLB  1
313A:  MOVWF  xDB
313C:  MOVLW  02
313E:  MOVWF  xDC
3140:  MOVLB  0
3142:  CALL   087C
....................             printf(lcd_putc, "c=0"); 
3146:  MOVLW  EC
3148:  MOVWF  FF6
314A:  MOVLW  02
314C:  MOVWF  FF7
314E:  CALL   0A52
....................          } 
....................          } // end switch 
....................  
....................          caso_valor = 0; 
3152:  CLRF   xF0
....................          memset(XX, 0, sizeof(XX)); 
3154:  MOVLW  01
3156:  MOVWF  FEA
3158:  MOVLW  91
315A:  MOVWF  FE9
315C:  CLRF   00
315E:  CLRF   02
3160:  MOVLW  20
3162:  MOVWF  01
3164:  CALL   11F0
....................          time_clr = 0; 
3168:  CLRF   3F
316A:  CLRF   3E
....................          f_clr = 1; 
316C:  MOVLW  01
316E:  MOVWF  47
....................          j = 0; 
3170:  CLRF   43
3172:  MOVLB  1
....................       } 
....................       if ((time_envio >= 180) && (master)) 
3174:  MOVLB  0
3176:  MOVF   xAA,F
3178:  BNZ   3180
317A:  MOVF   xA9,W
317C:  SUBLW  B3
317E:  BC    3188
3180:  MOVF   45,F
3182:  BZ    3188
....................       { // Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
....................          solicitar(); 
3184:  CALL   1182
....................       } 
....................       if ((clear_lcd1) && (time_lcd1 >= 10)) 
3188:  MOVF   xAB,F
318A:  BZ    31E8
318C:  MOVF   xAC,W
318E:  SUBLW  09
3190:  BC    31E8
....................       { // cronometro para limpiar notificaciones LCD 
....................          clear_lcd1 = 0; 
3192:  CLRF   xAB
....................          lcd_gotoxy(9, 1); 
3194:  MOVLW  09
3196:  MOVLB  1
3198:  MOVWF  xDB
319A:  MOVLW  01
319C:  MOVWF  xDC
319E:  MOVLB  0
31A0:  CALL   087C
....................          lcd_putc("    "); 
31A4:  MOVLW  F0
31A6:  MOVWF  FF6
31A8:  MOVLW  02
31AA:  MOVWF  FF7
31AC:  CALL   0A52
....................          lcd_gotoxy(9, 3); 
31B0:  MOVLW  09
31B2:  MOVLB  1
31B4:  MOVWF  xDB
31B6:  MOVLW  03
31B8:  MOVWF  xDC
31BA:  MOVLB  0
31BC:  CALL   087C
....................          lcd_putc("    "); 
31C0:  MOVLW  F6
31C2:  MOVWF  FF6
31C4:  MOVLW  02
31C6:  MOVWF  FF7
31C8:  CALL   0A52
....................          lcd_gotoxy(9, 4); 
31CC:  MOVLW  09
31CE:  MOVLB  1
31D0:  MOVWF  xDB
31D2:  MOVLW  04
31D4:  MOVWF  xDC
31D6:  MOVLB  0
31D8:  CALL   087C
....................          lcd_putc("    "); 
31DC:  MOVLW  FC
31DE:  MOVWF  FF6
31E0:  MOVLW  02
31E2:  MOVWF  FF7
31E4:  CALL   0A52
....................       } 
....................  
....................       if ((flag_enviar) && (cta_enviar >= 2000) && (master)) 
31E8:  MOVF   46,F
31EA:  BZ    3204
31EC:  MOVF   4F,W
31EE:  SUBLW  06
31F0:  BC    3204
31F2:  XORLW  FF
31F4:  BNZ   31FC
31F6:  MOVF   4E,W
31F8:  SUBLW  CF
31FA:  BC    3204
31FC:  MOVF   45,F
31FE:  BZ    3204
....................          envia2(); // Si el poste esclavo no contesta enviar sin conexion 
3200:  GOTO   1A4C
....................       if (transmitir) 
3204:  MOVF   24,F
3206:  BZ    320C
....................          envio(); // cuando el esclavo reporto su cuenta, maestro prepara paquete para mandar a la nube 
3208:  GOTO   1BA2
....................  
....................       if ((bloq_p1) && (tim_p1 >= time_bloqueo) && (!en_b1)) 
320C:  MOVF   x9B,F
320E:  BZ    327C
3210:  MOVF   xA2,W
3212:  SUBLW  00
3214:  BC    327C
3216:  XORLW  FF
3218:  BNZ   3220
321A:  MOVF   xA1,W
321C:  SUBLW  F3
321E:  BC    327C
3220:  MOVF   x9E,F
3222:  BNZ   327C
....................       {               // bloqueo de par 1 por m�s de X segundos 
....................          bloq_p1 = 0; // bandera de par de sensores bloqueados detectando, no significa contador bloqueado 
3224:  CLRF   x9B
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
3226:  MOVF   x9E,F
3228:  BNZ   3278
322A:  MOVF   x9F,F
322C:  BNZ   3278
322E:  MOVF   xA0,F
3230:  BNZ   3278
....................          {                     // si no habia un bloqueo antes 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
3232:  MOVLW  0A
3234:  MOVLB  1
3236:  MOVWF  xDB
3238:  MOVLW  01
323A:  MOVWF  xDC
323C:  MOVLB  0
323E:  CALL   087C
....................             lcd_putc("BL"); 
3242:  MOVLW  02
3244:  MOVWF  FF6
3246:  MOVLW  03
3248:  MOVWF  FF7
324A:  CALL   0A52
....................             cta_bloq1++; 
324E:  INCF   52,F
....................             write_ext_eeprom(9, cta_bloq1); // bloq1 
3250:  MOVLB  1
3252:  CLRF   xD5
3254:  MOVLW  09
3256:  MOVWF  xD4
3258:  MOVFF  52,1D6
325C:  MOVLB  0
325E:  CALL   05C2
....................             if ((master == 1) && (j == 0)) 
3262:  DECFSZ 45,W
3264:  BRA    3270
3266:  MOVF   43,F
3268:  BNZ   3270
....................                solicitar(); 
326A:  CALL   1182
326E:  BRA    3278
....................             else if (j == 0) 
3270:  MOVF   43,F
3272:  BNZ   3278
....................                envio_master(); 
3274:  CALL   119A
....................          } 
....................          en_b1 = 1; // bandera de bloqueo detectado en par 1 
3278:  MOVLW  01
327A:  MOVWF  x9E
....................       } 
....................       if ((bloq_p2) && (tim_p2 >= time_bloqueo) && (!en_b2)) 
327C:  MOVF   x9C,F
327E:  BZ    32EC
3280:  MOVF   xA4,W
3282:  SUBLW  00
3284:  BC    32EC
3286:  XORLW  FF
3288:  BNZ   3290
328A:  MOVF   xA3,W
328C:  SUBLW  F3
328E:  BC    32EC
3290:  MOVF   x9F,F
3292:  BNZ   32EC
....................       { // bloqueo de par 2 por m�s de X segundos 
....................          bloq_p2 = 0; 
3294:  CLRF   x9C
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
3296:  MOVF   x9E,F
3298:  BNZ   32E8
329A:  MOVF   x9F,F
329C:  BNZ   32E8
329E:  MOVF   xA0,F
32A0:  BNZ   32E8
....................          { 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
32A2:  MOVLW  0A
32A4:  MOVLB  1
32A6:  MOVWF  xDB
32A8:  MOVLW  01
32AA:  MOVWF  xDC
32AC:  MOVLB  0
32AE:  CALL   087C
....................             lcd_putc("BL"); 
32B2:  MOVLW  06
32B4:  MOVWF  FF6
32B6:  MOVLW  03
32B8:  MOVWF  FF7
32BA:  CALL   0A52
....................             cta_bloq2++; 
32BE:  INCF   53,F
....................             write_ext_eeprom(10, cta_bloq2); // bloq2 
32C0:  MOVLB  1
32C2:  CLRF   xD5
32C4:  MOVLW  0A
32C6:  MOVWF  xD4
32C8:  MOVFF  53,1D6
32CC:  MOVLB  0
32CE:  CALL   05C2
....................             if ((master == 1) && (j == 0)) 
32D2:  DECFSZ 45,W
32D4:  BRA    32E0
32D6:  MOVF   43,F
32D8:  BNZ   32E0
....................                solicitar(); 
32DA:  CALL   1182
32DE:  BRA    32E8
....................             else if (j == 0) 
32E0:  MOVF   43,F
32E2:  BNZ   32E8
....................                envio_master(); 
32E4:  CALL   119A
....................          } 
....................          en_b2 = 1; 
32E8:  MOVLW  01
32EA:  MOVWF  x9F
....................       } 
....................       if ((bloq_p3) && (tim_p3 >= time_bloqueo) && (!en_b3)) 
32EC:  MOVF   x9D,F
32EE:  BZ    335C
32F0:  MOVF   xA6,W
32F2:  SUBLW  00
32F4:  BC    335C
32F6:  XORLW  FF
32F8:  BNZ   3300
32FA:  MOVF   xA5,W
32FC:  SUBLW  F3
32FE:  BC    335C
3300:  MOVF   xA0,F
3302:  BNZ   335C
....................       { // bloqueo de par 3 por m�s de X segundos 
....................          bloq_p3 = 0; 
3304:  CLRF   x9D
....................          if ((!en_b1) && (!en_b2) && (!en_b3)) 
3306:  MOVF   x9E,F
3308:  BNZ   3358
330A:  MOVF   x9F,F
330C:  BNZ   3358
330E:  MOVF   xA0,F
3310:  BNZ   3358
....................          { 
....................             lcd_gotoxy(10, 1); // cronometro para limpiar 
3312:  MOVLW  0A
3314:  MOVLB  1
3316:  MOVWF  xDB
3318:  MOVLW  01
331A:  MOVWF  xDC
331C:  MOVLB  0
331E:  CALL   087C
....................             lcd_putc("BL"); 
3322:  MOVLW  0A
3324:  MOVWF  FF6
3326:  MOVLW  03
3328:  MOVWF  FF7
332A:  CALL   0A52
....................             cta_bloq3++; 
332E:  INCF   54,F
....................             write_ext_eeprom(11, cta_bloq3); // bloq3 
3330:  MOVLB  1
3332:  CLRF   xD5
3334:  MOVLW  0B
3336:  MOVWF  xD4
3338:  MOVFF  54,1D6
333C:  MOVLB  0
333E:  CALL   05C2
....................             if ((master == 1) && (j == 0)) 
3342:  DECFSZ 45,W
3344:  BRA    3350
3346:  MOVF   43,F
3348:  BNZ   3350
....................                solicitar(); 
334A:  CALL   1182
334E:  BRA    3358
....................             else if (j == 0) 
3350:  MOVF   43,F
3352:  BNZ   3358
....................                envio_master(); 
3354:  CALL   119A
....................          } 
....................          en_b3 = 1; 
3358:  MOVLW  01
335A:  MOVWF  xA0
....................       } // end deteccion 
....................       if ((!bloq_p3) && (!bloq_p2) && (!bloq_p1)) 
335C:  MOVF   x9D,F
335E:  BNZ   3384
3360:  MOVF   x9C,F
3362:  BNZ   3384
3364:  MOVF   x9B,F
3366:  BNZ   3384
....................       { // Si todos los pares estan desbloqueados limpia estado de bloqueo LCD 
....................          lcd_gotoxy(10, 1); 
3368:  MOVLW  0A
336A:  MOVLB  1
336C:  MOVWF  xDB
336E:  MOVLW  01
3370:  MOVWF  xDC
3372:  MOVLB  0
3374:  CALL   087C
....................          lcd_putc("  "); 
3378:  MOVLW  0E
337A:  MOVWF  FF6
337C:  MOVLW  03
337E:  MOVWF  FF7
3380:  CALL   0A52
....................       } 
....................  
....................       if ((time_clr >= 900) && (f_clr)) 
3384:  MOVF   3F,W
3386:  SUBLW  02
3388:  BC    339E
338A:  XORLW  FF
338C:  BNZ   3394
338E:  MOVF   3E,W
3390:  SUBLW  83
3392:  BC    339E
3394:  MOVF   47,F
3396:  BZ    339E
....................       { // refresca LCD 
....................          lcd_cuentas(); 
3398:  CALL   0A72
....................          f_clr = 0; 
339C:  CLRF   47
....................       } 
....................       sensores(); // Revisa estado de los sensores 
339E:  GOTO   27EE
....................       ////////////////// verificar si ya conto el pasajero y enviar pulso por relay ////////////////////////////////////////// 
....................       if ((nuevo_pulso) && (time_s3 >= 100)) 
33A2:  MOVF   xB1,F
33A4:  BZ    33BC
33A6:  MOVF   xB2,W
33A8:  SUBLW  63
33AA:  BC    33BC
....................       { // Nuevo Pulso de subida para impresion (flanco alto) 
....................          nuevo_pulso = 0; 
33AC:  CLRF   xB1
....................          fls3 = 1; 
33AE:  MOVLW  01
33B0:  MOVWF  xB3
....................          time_s3 = 0; 
33B2:  CLRF   xB2
....................          output_high(salida03); 
33B4:  BCF    F94.5
33B6:  BSF    F8B.5
....................          rev_suben(); 
33B8:  CALL   18B6
....................       } 
....................       ///////////////apagar pulso de relay///////////////////////////////////////////////////////////////////////////////////// 
....................       if ((time_s3 >= 10) && (fls3)) 
33BC:  MOVF   xB2,W
33BE:  SUBLW  09
33C0:  BC    33D8
33C2:  MOVF   xB3,F
33C4:  BZ    33D8
....................       { // Pulsos de subida para impresion (flanco bajo) 
....................          output_low(salida03); 
33C6:  BCF    F94.5
33C8:  BCF    F8B.5
....................          cta_pulsos--; 
33CA:  DECF   xB4,F
....................          if (cta_pulsos > 0) 
33CC:  MOVF   xB4,F
33CE:  BZ    33D4
....................             nuevo_pulso = 1; 
33D0:  MOVLW  01
33D2:  MOVWF  xB1
....................          fls3 = 0; 
33D4:  CLRF   xB3
....................          time_s3 = 0; 
33D6:  CLRF   xB2
....................       } 
....................       ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................       restart_wdt(); 
33D8:  CLRWDT
33DA:  BRA    2EB0
....................    } // end true 
.................... } // end main 
....................  
33DC:  SLEEP 
.................... void solicitar() 
.................... {                                    // Solicita cuenta al poste esclavo 
....................    fprintf(monitor, "SOLICITADO\r"); // 4 
*
1182:  MOVLW  12
1184:  MOVWF  FF6
1186:  MOVLW  03
1188:  MOVWF  FF7
118A:  RCALL  0E4A
....................    time_envio = 0; 
118C:  CLRF   xAA
118E:  CLRF   xA9
....................    flag_enviar = 1; 
1190:  MOVLW  01
1192:  MOVWF  46
....................    cta_enviar = 0; 
1194:  CLRF   4F
1196:  CLRF   4E
1198:  RETURN 0
.................... } 
....................  
.................... void envio_master() 
.................... { // reporta al maestro 
....................    int16 envit; 
....................    envit = (entraront + salieront) / 2; 
119A:  MOVF   x8C,W
119C:  ADDWF  x8A,W
119E:  MOVLB  1
11A0:  MOVWF  xD2
11A2:  MOVLB  0
11A4:  MOVF   x8D,W
11A6:  ADDWFC x8B,W
11A8:  MOVLB  1
11AA:  MOVWF  xD3
11AC:  BCF    FD8.0
11AE:  RRCF   xD3,W
11B0:  MOVWF  xD1
11B2:  RRCF   xD2,W
11B4:  MOVWF  xD0
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
11B6:  MOVF   53,W
11B8:  ADDWF  52,W
11BA:  ADDWF  54,W
11BC:  MOVWF  4C
11BE:  CLRF   4D
....................    clear_lcd1 = 1; 
11C0:  MOVLW  01
11C2:  MOVLB  0
11C4:  MOVWF  xAB
....................    time_lcd1 = 0; 
11C6:  CLRF   xAC
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
11C8:  MOVLW  09
11CA:  MOVLB  1
11CC:  MOVWF  xDB
11CE:  MOVLW  03
11D0:  MOVWF  xDC
11D2:  MOVLB  0
11D4:  CALL   087C
....................    lcd_putc(0xAB); 
11D8:  MOVLW  AB
11DA:  MOVLB  1
11DC:  MOVWF  xDA
11DE:  MOVLB  0
11E0:  CALL   08CE
....................    // fprintf(monitor,"PASAJEROS:%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
....................    fprintf(monitor, "PASAJEROS:\r"); 
11E4:  MOVLW  1E
11E6:  MOVWF  FF6
11E8:  MOVLW  03
11EA:  MOVWF  FF7
11EC:  RCALL  0E4A
11EE:  RETURN 0
.................... } 
....................  
.................... /* 
.................... int convertir_to_entero(char *cadena) 
.................... { 
....................    int valor = 0; 
....................    if (cadena == '0') 
....................       valor = 0; 
....................    else if (cadena == '1') 
....................       valor = 1; 
....................    else if (cadena == '2') 
....................       valor = 2; 
....................    else if (cadena == '3') 
....................       valor = 3; 
....................    else if (cadena == '4') 
....................       valor = 4; 
....................    else if (cadena == '5') 
....................       valor = 5; 
....................    else if (cadena == '6') 
....................       valor = 6; 
....................    else if (cadena == '7') 
....................       valor = 7; 
....................    else if (cadena == '8') 
....................       valor = 8; 
....................    else if (cadena == '9') 
....................       valor = 9; 
....................    return valor; 
.................... } 
.................... */ 
....................  
.................... void enviop1() 
.................... { // Convierte a enteros la cadena recibida por el poste esclavo 
....................    disable_interrupts(INT_RDA); 
*
1658:  BCF    F9D.5
....................    entran1 = 0; 
165A:  CLRF   39
165C:  CLRF   38
....................    salen1 = 0; 
165E:  CLRF   3B
1660:  CLRF   3A
....................    temporal1 = 0; 
1662:  CLRF   2F
1664:  CLRF   2E
....................    temporal2 = 0; 
1666:  CLRF   31
1668:  CLRF   30
....................    temporal3 = 0; 
166A:  CLRF   x97
166C:  CLRF   x96
....................    tempo_tn = 0; 
166E:  CLRF   33
1670:  CLRF   32
....................    pasajet = 0; 
1672:  CLRF   x91
1674:  CLRF   x90
....................    memset(entran, 0, sizeof(entran));       // entran=0; 
1676:  MOVLW  01
1678:  MOVWF  FEA
167A:  MOVLW  B1
167C:  MOVWF  FE9
167E:  CLRF   00
1680:  CLRF   02
1682:  MOVLW  05
1684:  MOVWF  01
1686:  RCALL  11F0
....................    memset(salen, 0, sizeof(salen));         // salen=0; 
1688:  MOVLW  01
168A:  MOVWF  FEA
168C:  MOVLW  B6
168E:  MOVWF  FE9
1690:  CLRF   00
1692:  CLRF   02
1694:  MOVLW  05
1696:  MOVWF  01
1698:  RCALL  11F0
....................    memset(bloqueado, 0, sizeof(bloqueado)); // bloqueado=0; 
169A:  MOVLW  01
169C:  MOVWF  FEA
169E:  MOVLW  BB
16A0:  MOVWF  FE9
16A2:  CLRF   00
16A4:  CLRF   02
16A6:  MOVLW  05
16A8:  MOVWF  01
16AA:  RCALL  11F0
....................    memset(bloqueado, 0, sizeof(tempo_tc));  // total 
16AC:  MOVLW  01
16AE:  MOVWF  FEA
16B0:  MOVLW  BB
16B2:  MOVWF  FE9
16B4:  CLRF   00
16B6:  CLRF   02
16B8:  MOVLW  05
16BA:  MOVWF  01
16BC:  RCALL  11F0
....................    i = 10; 
16BE:  MOVLW  0A
16C0:  MOVWF  41
....................    ii = 0; 
16C2:  CLRF   42
....................    strcpy(term, ":/"); 
16C4:  CLRF   FEA
16C6:  MOVLW  B5
16C8:  MOVWF  FE9
16CA:  MOVLW  00
16CC:  CALL   00F6
16D0:  TBLRD*-
16D2:  TBLRD*+
16D4:  MOVF   FF5,W
16D6:  MOVWF  FEE
16D8:  IORLW  00
16DA:  BNZ   16D2
....................    ptr = strtok(XX, term); 
16DC:  MOVLW  01
16DE:  MOVLB  1
16E0:  MOVWF  xD2
16E2:  MOVLW  91
16E4:  MOVWF  xD1
16E6:  CLRF   xD4
16E8:  MOVLW  B5
16EA:  MOVWF  xD3
16EC:  MOVLB  0
16EE:  RCALL  1314
16F0:  MOVFF  02,B9
16F4:  MOVFF  01,B8
....................  
....................    int conteo_wl = 0; 
16F8:  MOVLB  1
16FA:  CLRF   xD0
....................  
....................    strcpy(data1, ptr);                // 1ra Palabra 
16FC:  CLRF   FEA
16FE:  MOVLW  BA
1700:  MOVWF  FE9
1702:  MOVFF  B9,FE2
1706:  MOVFF  B8,FE1
170A:  MOVF   FE7,F
170C:  MOVFF  FE6,FEE
1710:  BNZ   170A
....................    strcpy(data2, strtok(NULL, term)); // 2ra Palabra 
1712:  CLRF   xD2
1714:  CLRF   xD1
1716:  CLRF   xD4
1718:  MOVLW  B5
171A:  MOVWF  xD3
171C:  MOVLB  0
171E:  RCALL  1314
1720:  MOVFF  02,1D2
1724:  MOVFF  01,1D1
1728:  CLRF   FEA
172A:  MOVLW  C8
172C:  MOVWF  FE9
172E:  MOVFF  02,FE2
1732:  MOVFF  01,FE1
1736:  MOVF   FE7,F
1738:  MOVFF  FE6,FEE
173C:  BNZ   1736
....................    strcpy(data3, strtok(NULL, term)); // 3ra Palabra 
173E:  MOVLB  1
1740:  CLRF   xD2
1742:  CLRF   xD1
1744:  CLRF   xD4
1746:  MOVLW  B5
1748:  MOVWF  xD3
174A:  MOVLB  0
174C:  RCALL  1314
174E:  MOVFF  02,1D2
1752:  MOVFF  01,1D1
1756:  CLRF   FEA
1758:  MOVLW  D2
175A:  MOVWF  FE9
175C:  MOVFF  02,FE2
1760:  MOVFF  01,FE1
1764:  MOVF   FE7,F
1766:  MOVFF  FE6,FEE
176A:  BNZ   1764
....................    strcpy(data4, strtok(NULL, term)); // 4ra Palabra 
176C:  MOVLB  1
176E:  CLRF   xD2
1770:  CLRF   xD1
1772:  CLRF   xD4
1774:  MOVLW  B5
1776:  MOVWF  xD3
1778:  MOVLB  0
177A:  RCALL  1314
177C:  MOVFF  02,1D2
1780:  MOVFF  01,1D1
1784:  CLRF   FEA
1786:  MOVLW  DC
1788:  MOVWF  FE9
178A:  MOVFF  02,FE2
178E:  MOVFF  01,FE1
1792:  MOVF   FE7,F
1794:  MOVFF  FE6,FEE
1798:  BNZ   1792
....................    strcpy(data5, strtok(NULL, term)); // 5ra Palabra 
179A:  MOVLB  1
179C:  CLRF   xD2
179E:  CLRF   xD1
17A0:  CLRF   xD4
17A2:  MOVLW  B5
17A4:  MOVWF  xD3
17A6:  MOVLB  0
17A8:  RCALL  1314
17AA:  MOVFF  02,1D2
17AE:  MOVFF  01,1D1
17B2:  CLRF   FEA
17B4:  MOVLW  E6
17B6:  MOVWF  FE9
17B8:  MOVFF  02,FE2
17BC:  MOVFF  01,FE1
17C0:  MOVF   FE7,F
17C2:  MOVFF  FE6,FEE
17C6:  BNZ   17C0
....................    ptr = strtok(0, term); 
17C8:  MOVLB  1
17CA:  CLRF   xD2
17CC:  CLRF   xD1
17CE:  CLRF   xD4
17D0:  MOVLW  B5
17D2:  MOVWF  xD3
17D4:  MOVLB  0
17D6:  RCALL  1314
17D8:  MOVFF  02,B9
17DC:  MOVFF  01,B8
....................  
....................    conteo_wl++; 
17E0:  MOVLB  1
17E2:  INCF   xD0,F
....................    sub_atras = atoi32(data2); 
17E4:  CLRF   xD2
17E6:  MOVLW  C8
17E8:  MOVWF  xD1
17EA:  MOVLB  0
17EC:  RCALL  13C4
17EE:  MOVFF  01,35
17F2:  MOVFF  00,34
....................    baj_atras = atoi32(data3); 
17F6:  MOVLB  1
17F8:  CLRF   xD2
17FA:  MOVLW  D2
17FC:  MOVWF  xD1
17FE:  MOVLB  0
1800:  RCALL  13C4
1802:  MOVFF  01,37
1806:  MOVFF  00,36
....................    temporal3 = atoi32(data4); 
180A:  MOVLB  1
180C:  CLRF   xD2
180E:  MOVLW  DC
1810:  MOVWF  xD1
1812:  MOVLB  0
1814:  RCALL  13C4
1816:  MOVFF  01,97
181A:  MOVFF  00,96
....................    tempo_tn = atoi32(data5); 
181E:  MOVLB  1
1820:  CLRF   xD2
1822:  MOVLW  E6
1824:  MOVWF  xD1
1826:  MOVLB  0
1828:  RCALL  13C4
182A:  MOVFF  01,33
182E:  MOVFF  00,32
....................  
....................    lcd_gotoxy(14, 3); 
1832:  MOVLW  0E
1834:  MOVLB  1
1836:  MOVWF  xDB
1838:  MOVLW  03
183A:  MOVWF  xDC
183C:  MOVLB  0
183E:  CALL   087C
....................    printf(lcd_putc, "S2:%Ld ", sub_atras); 
1842:  MOVLW  2A
1844:  MOVWF  FF6
1846:  MOVLW  03
1848:  MOVWF  FF7
184A:  MOVLW  03
184C:  MOVLB  1
184E:  MOVWF  xD1
1850:  MOVLB  0
1852:  CALL   092E
1856:  MOVLW  10
1858:  MOVWF  FE9
185A:  MOVFF  35,1D2
185E:  MOVFF  34,1D1
1862:  CALL   0956
1866:  MOVLW  20
1868:  MOVLB  1
186A:  MOVWF  xDA
186C:  MOVLB  0
186E:  CALL   08CE
....................    lcd_gotoxy(14, 4); 
1872:  MOVLW  0E
1874:  MOVLB  1
1876:  MOVWF  xDB
1878:  MOVLW  04
187A:  MOVWF  xDC
187C:  MOVLB  0
187E:  CALL   087C
....................    printf(lcd_putc, "B2:%Ld ", baj_atras); 
1882:  MOVLW  32
1884:  MOVWF  FF6
1886:  MOVLW  03
1888:  MOVWF  FF7
188A:  MOVLW  03
188C:  MOVLB  1
188E:  MOVWF  xD1
1890:  MOVLB  0
1892:  CALL   092E
1896:  MOVLW  10
1898:  MOVWF  FE9
189A:  MOVFF  37,1D2
189E:  MOVFF  36,1D1
18A2:  CALL   0956
18A6:  MOVLW  20
18A8:  MOVLB  1
18AA:  MOVWF  xDA
18AC:  MOVLB  0
18AE:  CALL   08CE
18B2:  GOTO   3098 (RETURN)
.................... } 
....................  
.................... void envio() 
.................... { // crea paquete para enviar al modulo GPRS 
....................    ////////////// Detectando envio total 
....................  
....................    temporal1 = sub_atras; 
*
1BA2:  MOVFF  35,2F
1BA6:  MOVFF  34,2E
....................    temporal2 = baj_atras; 
1BAA:  MOVFF  37,31
1BAE:  MOVFF  36,30
....................    entran1 = (entraront + salieront) / 2; 
1BB2:  MOVF   x8C,W
1BB4:  ADDWF  x8A,W
1BB6:  MOVLB  1
1BB8:  MOVWF  xD0
1BBA:  MOVLB  0
1BBC:  MOVF   x8D,W
1BBE:  ADDWFC x8B,W
1BC0:  MOVLB  1
1BC2:  MOVWF  xD1
1BC4:  BCF    FD8.0
1BC6:  RRCF   xD1,W
1BC8:  MOVWF  39
1BCA:  RRCF   xD0,W
1BCC:  MOVWF  38
....................  
....................    total2_t = (temporal1 + temporal2) / 2; 
1BCE:  MOVF   30,W
1BD0:  ADDWF  2E,W
1BD2:  MOVWF  xD0
1BD4:  MOVF   31,W
1BD6:  ADDWFC 2F,W
1BD8:  MOVWF  xD1
1BDA:  BCF    FD8.0
1BDC:  RRCF   xD1,W
1BDE:  MOVWF  51
1BE0:  RRCF   xD0,W
1BE2:  MOVWF  50
....................  
....................    leer_conta2(); 
1BE4:  MOVLB  0
1BE6:  CALL   082A
....................    if (total2_t == tempo_tn) 
1BEA:  MOVF   32,W
1BEC:  SUBWF  50,W
1BEE:  BNZ   1C0E
1BF0:  MOVF   33,W
1BF2:  SUBWF  51,W
1BF4:  BNZ   1C0E
....................    { // dato recibido correcto 
....................       salian = salen1 = total2_t; 
1BF6:  MOVFF  51,3B
1BFA:  MOVFF  50,3A
1BFE:  MOVFF  3B,3D
1C02:  MOVFF  3A,3C
....................       graba_conta2(); 
1C06:  CALL   06C8
....................       error = 0; 
1C0A:  CLRF   23
....................    } 
1C0C:  BRA    1C12
....................    else 
....................       error = 2; 
1C0E:  MOVLW  02
1C10:  MOVWF  23
....................    ///////////// 
....................    pasajet = entran1 + salen1; 
1C12:  MOVF   3A,W
1C14:  ADDWF  38,W
1C16:  MOVWF  x90
1C18:  MOVF   3B,W
1C1A:  ADDWFC 39,W
1C1C:  MOVWF  x91
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
1C1E:  MOVF   53,W
1C20:  ADDWF  52,W
1C22:  ADDWF  54,W
1C24:  MOVWF  4C
1C26:  CLRF   4D
....................    // fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,temporal1,temporal2,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS, "ACC+01:%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n", pasajet, entran1, salen1, cta_bloqueo, temporal3, error); 
1C28:  MOVLW  3A
1C2A:  MOVWF  FF6
1C2C:  MOVLW  03
1C2E:  MOVWF  FF7
1C30:  MOVLW  07
1C32:  MOVLB  1
1C34:  MOVWF  xD0
1C36:  MOVLB  0
1C38:  RCALL  18D8
1C3A:  MOVLW  09
1C3C:  MOVWF  FE9
1C3E:  MOVFF  91,1D1
1C42:  MOVFF  90,1D0
1C46:  RCALL  1900
1C48:  MOVLW  2C
1C4A:  MOVLB  1
1C4C:  MOVWF  xD9
1C4E:  MOVLB  0
1C50:  CALL   1114
1C54:  MOVLW  09
1C56:  MOVWF  FE9
1C58:  MOVFF  39,1D1
1C5C:  MOVFF  38,1D0
1C60:  RCALL  1900
1C62:  MOVLW  2C
1C64:  MOVLB  1
1C66:  MOVWF  xD9
1C68:  MOVLB  0
1C6A:  CALL   1114
1C6E:  MOVLW  09
1C70:  MOVWF  FE9
1C72:  MOVFF  3B,1D1
1C76:  MOVFF  3A,1D0
1C7A:  RCALL  1900
1C7C:  MOVLW  2C
1C7E:  MOVLB  1
1C80:  MOVWF  xD9
1C82:  MOVLB  0
1C84:  CALL   1114
1C88:  MOVLW  0A
1C8A:  MOVWF  FE9
1C8C:  MOVFF  4D,1D1
1C90:  MOVFF  4C,1D0
1C94:  RCALL  1900
1C96:  MOVLW  2C
1C98:  MOVLB  1
1C9A:  MOVWF  xD9
1C9C:  MOVLB  0
1C9E:  CALL   1114
1CA2:  MOVLW  0A
1CA4:  MOVWF  FE9
1CA6:  MOVFF  97,1D1
1CAA:  MOVFF  96,1D0
1CAE:  RCALL  1900
1CB0:  MOVLW  2C
1CB2:  MOVLB  1
1CB4:  MOVWF  xD9
1CB6:  MOVLB  0
1CB8:  CALL   1114
1CBC:  MOVFF  23,1D0
1CC0:  MOVLW  01
1CC2:  MOVLB  1
1CC4:  MOVWF  xD1
1CC6:  MOVLB  0
1CC8:  RCALL  19C6
1CCA:  MOVLW  63
1CCC:  MOVWF  FF6
1CCE:  MOVLW  03
1CD0:  MOVWF  FF7
1CD2:  MOVLW  03
1CD4:  MOVLB  1
1CD6:  MOVWF  xD0
1CD8:  MOVLB  0
1CDA:  RCALL  18D8
....................    lcd_cuentas(); 
1CDC:  CALL   0A72
....................  
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
1CE0:  MOVLW  09
1CE2:  MOVLB  1
1CE4:  MOVWF  xDB
1CE6:  MOVLW  03
1CE8:  MOVWF  xDC
1CEA:  MOVLB  0
1CEC:  CALL   087C
....................    lcd_putc(0xAB); 
1CF0:  MOVLW  AB
1CF2:  MOVLB  1
1CF4:  MOVWF  xDA
1CF6:  MOVLB  0
1CF8:  CALL   08CE
....................  
....................    clear_lcd1 = 1; 
1CFC:  MOVLW  01
1CFE:  MOVWF  xAB
....................    time_lcd1 = 0; 
1D00:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio = 0; // reinicia el tiempo para el siguiente envio 
1D02:  CLRF   xAA
1D04:  CLRF   xA9
....................    transmitir = 0; 
1D06:  CLRF   24
....................    enable_interrupts(INT_RDA); 
1D08:  BSF    F9D.5
1D0A:  GOTO   320C (RETURN)
.................... } 
....................  
.................... void envia2() 
.................... { // Crea paquete para enviar a modulo GPRS cuando no hay conexion con esclavo 
....................    disable_interrupts(INT_RDA); 
*
1A4C:  BCF    F9D.5
....................    cta_bloqueo = cta_bloq1 + cta_bloq2 + cta_bloq3; 
1A4E:  MOVF   53,W
1A50:  ADDWF  52,W
1A52:  ADDWF  54,W
1A54:  MOVWF  4C
1A56:  CLRF   4D
....................    memset(entran, 0, sizeof(entran));       // entran=0; 
1A58:  MOVLW  01
1A5A:  MOVWF  FEA
1A5C:  MOVLW  B1
1A5E:  MOVWF  FE9
1A60:  CLRF   00
1A62:  CLRF   02
1A64:  MOVLW  05
1A66:  MOVWF  01
1A68:  CALL   11F0
....................    memset(salen, 0, sizeof(salen));         // salen=0; 
1A6C:  MOVLW  01
1A6E:  MOVWF  FEA
1A70:  MOVLW  B6
1A72:  MOVWF  FE9
1A74:  CLRF   00
1A76:  CLRF   02
1A78:  MOVLW  05
1A7A:  MOVWF  01
1A7C:  CALL   11F0
....................    memset(bloqueado, 0, sizeof(bloqueado)); // bloqueado=0; 
1A80:  MOVLW  01
1A82:  MOVWF  FEA
1A84:  MOVLW  BB
1A86:  MOVWF  FE9
1A88:  CLRF   00
1A8A:  CLRF   02
1A8C:  MOVLW  05
1A8E:  MOVWF  01
1A90:  CALL   11F0
....................    i = 10; 
1A94:  MOVLW  0A
1A96:  MOVWF  41
....................    ii = 0; 
1A98:  CLRF   42
....................    entran1 = (entraront + salieront) / 2; 
1A9A:  MOVF   x8C,W
1A9C:  ADDWF  x8A,W
1A9E:  MOVLB  1
1AA0:  MOVWF  xD0
1AA2:  MOVLB  0
1AA4:  MOVF   x8D,W
1AA6:  ADDWFC x8B,W
1AA8:  MOVLB  1
1AAA:  MOVWF  xD1
1AAC:  BCF    FD8.0
1AAE:  RRCF   xD1,W
1AB0:  MOVWF  39
1AB2:  RRCF   xD0,W
1AB4:  MOVWF  38
....................    leer_conta2(); 
1AB6:  MOVLB  0
1AB8:  CALL   082A
....................    pasajet = entran1 + salian; 
1ABC:  MOVF   3C,W
1ABE:  ADDWF  38,W
1AC0:  MOVWF  x90
1AC2:  MOVF   3D,W
1AC4:  ADDWFC 39,W
1AC6:  MOVWF  x91
....................    error = 1; 
1AC8:  MOVLW  01
1ACA:  MOVWF  23
....................    // fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,DESC,DESC,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS, "ACC+01:%04Lu,%04Lu,DESC,%03Lu,000,%02u,\r\n", pasajet, entran1, cta_bloqueo, error); 
1ACC:  MOVLW  68
1ACE:  MOVWF  FF6
1AD0:  MOVLW  03
1AD2:  MOVWF  FF7
1AD4:  MOVLW  07
1AD6:  MOVLB  1
1AD8:  MOVWF  xD0
1ADA:  MOVLB  0
1ADC:  RCALL  18D8
1ADE:  MOVLW  09
1AE0:  MOVWF  FE9
1AE2:  MOVFF  91,1D1
1AE6:  MOVFF  90,1D0
1AEA:  RCALL  1900
1AEC:  MOVLW  2C
1AEE:  MOVLB  1
1AF0:  MOVWF  xD9
1AF2:  MOVLB  0
1AF4:  CALL   1114
1AF8:  MOVLW  09
1AFA:  MOVWF  FE9
1AFC:  MOVFF  39,1D1
1B00:  MOVFF  38,1D0
1B04:  RCALL  1900
1B06:  MOVLW  7A
1B08:  MOVWF  FF6
1B0A:  MOVLW  03
1B0C:  MOVWF  FF7
1B0E:  MOVLW  06
1B10:  MOVLB  1
1B12:  MOVWF  xD0
1B14:  MOVLB  0
1B16:  RCALL  18D8
1B18:  MOVLW  0A
1B1A:  MOVWF  FE9
1B1C:  MOVFF  4D,1D1
1B20:  MOVFF  4C,1D0
1B24:  RCALL  1900
1B26:  MOVLW  85
1B28:  MOVWF  FF6
1B2A:  MOVLW  03
1B2C:  MOVWF  FF7
1B2E:  MOVLW  05
1B30:  MOVLB  1
1B32:  MOVWF  xD0
1B34:  MOVLB  0
1B36:  RCALL  18D8
1B38:  MOVFF  23,1D0
1B3C:  MOVLW  01
1B3E:  MOVLB  1
1B40:  MOVWF  xD1
1B42:  MOVLB  0
1B44:  RCALL  19C6
1B46:  MOVLW  8E
1B48:  MOVWF  FF6
1B4A:  MOVLW  03
1B4C:  MOVWF  FF7
1B4E:  MOVLW  03
1B50:  MOVLB  1
1B52:  MOVWF  xD0
1B54:  MOVLB  0
1B56:  RCALL  18D8
....................    //!   lcd_gotoxy(1,4); 
....................    //!   printf(lcd_putc,"T:%04Lu BS:%03Lu ",pasajet,cta_bloqueo); 
....................    lcd_gotoxy(9, 3); // cronometro para limpiar 
1B58:  MOVLW  09
1B5A:  MOVLB  1
1B5C:  MOVWF  xDB
1B5E:  MOVLW  03
1B60:  MOVWF  xDC
1B62:  MOVLB  0
1B64:  CALL   087C
....................    lcd_putc(0xAB); 
1B68:  MOVLW  AB
1B6A:  MOVLB  1
1B6C:  MOVWF  xDA
1B6E:  MOVLB  0
1B70:  CALL   08CE
....................    lcd_gotoxy(9, 4); // cronometro para limpiar 
1B74:  MOVLW  09
1B76:  MOVLB  1
1B78:  MOVWF  xDB
1B7A:  MOVLW  04
1B7C:  MOVWF  xDC
1B7E:  MOVLB  0
1B80:  CALL   087C
....................    lcd_putc("DESC"); 
1B84:  MOVLW  92
1B86:  MOVWF  FF6
1B88:  MOVLW  03
1B8A:  MOVWF  FF7
1B8C:  CALL   0A52
....................    clear_lcd1 = 1; 
1B90:  MOVLW  01
1B92:  MOVWF  xAB
....................    time_lcd1 = 0; 
1B94:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio = 0; // reinicia el tiempo para el siguiente envio 
1B96:  CLRF   xAA
1B98:  CLRF   xA9
....................    flag_enviar = 0; 
1B9A:  CLRF   46
....................    enable_interrupts(INT_RDA); 
1B9C:  BSF    F9D.5
1B9E:  GOTO   3204 (RETURN)
.................... } 
....................  
.................... void limpiar() 
.................... { // borra cuentas de subidas, bajadas y bloqueos 
....................    tem_entraront = 0; 
*
0D2A:  CLRF   x93
0D2C:  CLRF   x92
....................    tem_salieront = 0; 
0D2E:  CLRF   x95
0D30:  CLRF   x94
....................    salian = 0; 
0D32:  CLRF   3D
0D34:  CLRF   3C
....................    graba_conta2(); 
0D36:  RCALL  06C8
....................    leer_conta2(); 
0D38:  RCALL  082A
....................    pasaje = 0; 
0D3A:  CLRF   x8F
0D3C:  CLRF   x8E
....................    pasajet = 0; 
0D3E:  CLRF   x91
0D40:  CLRF   x90
....................    salieront = 0; 
0D42:  CLRF   x8D
0D44:  CLRF   x8C
....................    entraront = 0; 
0D46:  CLRF   x8B
0D48:  CLRF   x8A
....................    write_ent(); 
0D4A:  RCALL  0CBE
....................    write_sal(); 
0D4C:  RCALL  0CF4
....................    cta_bloqueo = 0; 
0D4E:  CLRF   4D
0D50:  CLRF   4C
....................    cta_bloq1 = 0; 
0D52:  CLRF   52
....................    cta_bloq2 = 0; 
0D54:  CLRF   53
....................    cta_bloq3 = 0; 
0D56:  CLRF   54
....................    write_ext_eeprom(9, cta_bloq1);  // bloq1 
0D58:  MOVLB  1
0D5A:  CLRF   xD5
0D5C:  MOVLW  09
0D5E:  MOVWF  xD4
0D60:  MOVFF  52,1D6
0D64:  MOVLB  0
0D66:  RCALL  05C2
....................    write_ext_eeprom(10, cta_bloq2); // bloq2 
0D68:  MOVLB  1
0D6A:  CLRF   xD5
0D6C:  MOVLW  0A
0D6E:  MOVWF  xD4
0D70:  MOVFF  53,1D6
0D74:  MOVLB  0
0D76:  RCALL  05C2
....................    write_ext_eeprom(11, cta_bloq3); // bloq3 
0D78:  MOVLB  1
0D7A:  CLRF   xD5
0D7C:  MOVLW  0B
0D7E:  MOVWF  xD4
0D80:  MOVFF  54,1D6
0D84:  MOVLB  0
0D86:  RCALL  05C2
....................    lcd_putc("\f"); 
0D88:  MOVLW  98
0D8A:  MOVWF  FF6
0D8C:  MOVLW  03
0D8E:  MOVWF  FF7
0D90:  RCALL  0A52
....................    lcd_cuentas(); 
0D92:  RCALL  0A72
0D94:  RETURN 0
.................... } 
....................  
.................... void detecta_suma() 
.................... { // Realiza suma de entradas o salidas 
....................    if ((!detec1) && (!detec2) && (!detec3) && (!detec4) && (!detec5) && (!detec6)) 
*
1FDE:  MOVF   x69,F
1FE0:  BNZ   204E
1FE2:  MOVF   x6A,F
1FE4:  BNZ   204E
1FE6:  MOVF   x6B,F
1FE8:  BNZ   204E
1FEA:  MOVF   x6C,F
1FEC:  BNZ   204E
1FEE:  MOVF   x6D,F
1FF0:  BNZ   204E
1FF2:  MOVF   x6E,F
1FF4:  BNZ   204E
....................    { // suma sin bloqueos 
....................       sumae1 = fse1 + fse2 + fse3; 
1FF6:  MOVF   29,W
1FF8:  ADDWF  28,W
1FFA:  ADDWF  2A,W
1FFC:  MOVWF  25
....................       sumas1 = fss1 + fss2 + fss3; 
1FFE:  MOVF   2C,W
2000:  ADDWF  2B,W
2002:  ADDWF  2D,W
2004:  MOVWF  26
....................       //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
....................       //!      printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................       if ((sumae1 >= 2) || (sumas1 >= 2)) 
2006:  MOVF   25,W
2008:  SUBLW  01
200A:  BNC   2012
200C:  MOVF   26,W
200E:  SUBLW  01
2010:  BC    2030
....................       { 
....................          if (sumae1 > sumas1) 
2012:  MOVF   25,W
2014:  SUBWF  26,W
2016:  BC    2026
....................          { 
....................             entraront++; 
2018:  INCF   x8A,F
201A:  BTFSC  FD8.2
201C:  INCF   x8B,F
....................             write_ent(); 
201E:  CALL   0CBE
....................             /////enciende relay//// 
....................             cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
2022:  RCALL  18C8
....................             //////// 
....................          } 
2024:  BRA    2030
....................          else 
....................          { 
....................             salieront++; 
2026:  INCF   x8C,F
2028:  BTFSC  FD8.2
202A:  INCF   x8D,F
....................             write_sal(); 
202C:  CALL   0CF4
....................          } 
....................       } 
....................       sumae1 = fse1 = fse2 = fse3 = 0; 
2030:  CLRF   2A
2032:  MOVFF  2A,29
2036:  MOVFF  29,28
203A:  MOVFF  28,25
....................       sumas1 = fss1 = fss2 = fss3 = 0; 
203E:  CLRF   2D
2040:  MOVFF  2D,2C
2044:  MOVFF  2C,2B
2048:  MOVFF  2B,26
....................       // envio_PC(); 
....................    } // fin suma sin bloqueos 
204C:  BRA    2158
....................    else if ((en_b1) || (en_b2) || (en_b3)) 
204E:  MOVF   x9E,F
2050:  BNZ   205C
2052:  MOVF   x9F,F
2054:  BNZ   205C
2056:  MOVF   xA0,F
2058:  BTFSC  FD8.2
205A:  BRA    2158
....................    { // contar con bloqueos 
....................       lim_b = en_b1 + en_b2 + en_b3; 
205C:  MOVF   x9F,W
205E:  ADDWF  x9E,W
2060:  ADDWF  xA0,W
2062:  MOVWF  27
....................  
....................       if (lim_b == 1) 
2064:  DECFSZ 27,W
2066:  BRA    2100
....................       { // un solo bloqueo 
....................          if (en_b1) 
2068:  MOVF   x9E,F
206A:  BZ    209A
....................          { 
....................             if ((!detec3) && (!detec4) && (!detec5) && (!detec6)) 
206C:  MOVF   x6B,F
206E:  BNZ   2098
2070:  MOVF   x6C,F
2072:  BNZ   2098
2074:  MOVF   x6D,F
2076:  BNZ   2098
2078:  MOVF   x6E,F
207A:  BNZ   2098
....................             { 
....................                if (sen_ent == 1) 
207C:  DECFSZ 5B,W
207E:  BRA    208E
....................                { 
....................                   entraront++; 
2080:  INCF   x8A,F
2082:  BTFSC  FD8.2
2084:  INCF   x8B,F
....................                   write_ent(); 
2086:  CALL   0CBE
....................                   /////enciende relay//// 
....................                   cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
208A:  RCALL  18C8
....................                   //////// 
....................                } 
208C:  BRA    2098
....................                else 
....................                { 
....................                   salieront++; 
208E:  INCF   x8C,F
2090:  BTFSC  FD8.2
2092:  INCF   x8D,F
....................                   write_sal(); 
2094:  CALL   0CF4
....................                } 
....................             } // fin sensores 0 
....................          }    // fin bloqueo par 1 
2098:  BRA    20FE
....................          else if (en_b2) 
209A:  MOVF   x9F,F
209C:  BZ    20CC
....................          { // bloqueo en par 2 
....................             if ((!detec1) && (!detec2) && (!detec5) && (!detec6)) 
209E:  MOVF   x69,F
20A0:  BNZ   20CA
20A2:  MOVF   x6A,F
20A4:  BNZ   20CA
20A6:  MOVF   x6D,F
20A8:  BNZ   20CA
20AA:  MOVF   x6E,F
20AC:  BNZ   20CA
....................             { 
....................                if (sen_ent) 
20AE:  MOVF   5B,F
20B0:  BZ    20C0
....................                { 
....................                   entraront++; 
20B2:  INCF   x8A,F
20B4:  BTFSC  FD8.2
20B6:  INCF   x8B,F
....................                   write_ent(); 
20B8:  CALL   0CBE
....................                   /////enciende relay//// 
....................                   cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
20BC:  RCALL  18C8
....................                   //////// 
....................                } 
20BE:  BRA    20CA
....................                else 
....................                { 
....................                   salieront++; 
20C0:  INCF   x8C,F
20C2:  BTFSC  FD8.2
20C4:  INCF   x8D,F
....................                   write_sal(); 
20C6:  CALL   0CF4
....................                } 
....................             } // fin sensores 0 
....................          }    // fin par 2 
20CA:  BRA    20FE
....................          else if (en_b3) 
20CC:  MOVF   xA0,F
20CE:  BZ    20FE
....................          { // bloqueao en par 3 
....................             if ((!detec3) && (!detec4) && (!detec1) && (!detec2)) 
20D0:  MOVF   x6B,F
20D2:  BNZ   20FE
20D4:  MOVF   x6C,F
20D6:  BNZ   20FE
20D8:  MOVF   x69,F
20DA:  BNZ   20FE
20DC:  MOVF   x6A,F
20DE:  BNZ   20FE
....................             { 
....................                if (sen_ent) 
20E0:  MOVF   5B,F
20E2:  BZ    20F4
....................                { 
....................                   entraront++; 
20E4:  INCF   x8A,F
20E6:  BTFSC  FD8.2
20E8:  INCF   x8B,F
....................                   write_ent(); 
20EA:  CALL   0CBE
....................                   /////enciende relay//// 
....................                   cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
20EE:  CALL   18C8
....................                   //////// 
....................                } 
20F2:  BRA    20FE
....................                else 
....................                { 
....................                   salieront++; 
20F4:  INCF   x8C,F
20F6:  BTFSC  FD8.2
20F8:  INCF   x8D,F
....................                   write_sal(); 
20FA:  CALL   0CF4
....................                } 
....................             } 
....................          } // fin par 3 
....................       }    // fin un solo bloqueo 
20FE:  BRA    213C
....................       //----------------------------------------------------------------------------- 
....................       else 
....................       { // mas de un bloqueo 
....................          sumae1 = fse1 + fse2 + fse3; 
2100:  MOVF   29,W
2102:  ADDWF  28,W
2104:  ADDWF  2A,W
2106:  MOVWF  25
....................          sumas1 = fss1 + fss2 + fss3; 
2108:  MOVF   2C,W
210A:  ADDWF  2B,W
210C:  ADDWF  2D,W
210E:  MOVWF  26
....................          // lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
....................          // printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................          if ((sumae1 >= 1) || (sumas1 >= 1)) 
2110:  MOVF   25,W
2112:  SUBLW  00
2114:  BNC   211C
2116:  MOVF   26,W
2118:  SUBLW  00
211A:  BC    213C
....................          { 
....................             if (sumae1 > sumas1) 
211C:  MOVF   25,W
211E:  SUBWF  26,W
2120:  BC    2132
....................             { 
....................                entraront++; 
2122:  INCF   x8A,F
2124:  BTFSC  FD8.2
2126:  INCF   x8B,F
....................                write_ent(); 
2128:  CALL   0CBE
....................                /////enciende relay//// 
....................                cuenta_pulsos(); // Pulsos de subida para impresion (flanco alto) 
212C:  CALL   18C8
....................                //////// 
....................             } 
2130:  BRA    213C
....................             else 
....................             { 
....................                salieront++; 
2132:  INCF   x8C,F
2134:  BTFSC  FD8.2
2136:  INCF   x8D,F
....................                write_sal(); 
2138:  CALL   0CF4
....................             } 
....................          } 
....................       } // fin mas de un bloqueo 
....................       sumae1 = fse1 = fse2 = fse3 = 0; 
213C:  CLRF   2A
213E:  MOVFF  2A,29
2142:  MOVFF  29,28
2146:  MOVFF  28,25
....................       sumas1 = fss1 = fss2 = fss3 = 0; 
214A:  CLRF   2D
214C:  MOVFF  2D,2C
2150:  MOVFF  2C,2B
2154:  MOVFF  2B,26
....................       //----------------------------------------------------------------------------- 
....................    } // end bloqueos 
2158:  RETURN 0
.................... } 
....................  
.................... void finsuma() 
.................... { // Pinta en LCD la nueva cifra de entrada o salida 
....................  
....................    pasaje = (entraront + salieront) / 2; 
*
0C80:  MOVF   x8C,W
0C82:  ADDWF  x8A,W
0C84:  MOVLB  1
0C86:  MOVWF  xD0
0C88:  MOVLB  0
0C8A:  MOVF   x8D,W
0C8C:  ADDWFC x8B,W
0C8E:  MOVLB  1
0C90:  MOVWF  xD1
0C92:  BCF    FD8.0
0C94:  RRCF   xD1,W
0C96:  MOVLB  0
0C98:  MOVWF  x8F
0C9A:  MOVLB  1
0C9C:  RRCF   xD0,W
0C9E:  MOVLB  0
0CA0:  MOVWF  x8E
....................    lcd_cuentas(); 
0CA2:  RCALL  0A72
....................    sen_ent = 0; 
0CA4:  CLRF   5B
....................    sen_sal = 0; 
0CA6:  CLRF   5C
....................    fse1 = fse2 = fse3 = 0; 
0CA8:  CLRF   2A
0CAA:  MOVFF  2A,29
0CAE:  MOVFF  29,28
....................    fss1 = fss2 = fss3 = 0; 
0CB2:  CLRF   2D
0CB4:  MOVFF  2D,2C
0CB8:  MOVFF  2C,2B
0CBC:  RETURN 0
.................... } 
....................  
.................... void contando1() 
.................... { // Revisa maquina de estados para par 1 
....................    if (entra_temp1 != edo1) 
*
215A:  MOVF   x76,W
215C:  SUBWF  x7B,W
215E:  BZ    2168
....................    { 
....................       entra_temp1 = edo1; 
2160:  MOVFF  76,7B
....................       enable1 = 1; 
2164:  MOVLW  01
2166:  MOVWF  x7A
....................    } 
....................    if (enable1 == 1) 
2168:  DECFSZ x7A,W
216A:  BRA    21A8
....................    { 
....................       switch (edo1) 
216C:  MOVLW  01
216E:  SUBWF  x76,W
2170:  ADDLW  F4
2172:  BC    21A4
2174:  ADDLW  0C
2176:  GOTO   21AA
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
217A:  BRA    21A4
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss1) 
217C:  MOVF   2B,F
217E:  BNZ   2186
....................             fse1 = 1; // si no ha salido antes 
2180:  MOVLW  01
2182:  MOVWF  28
2184:  BRA    2188
....................          else 
....................             fss1 = 0; 
2186:  CLRF   2B
....................          detecta_suma(); 
2188:  RCALL  1FDE
....................          break; 
218A:  BRA    21A4
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
218C:  RCALL  1FDE
....................          break; 
218E:  BRA    21A4
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
2190:  BRA    21A4
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse1) 
2192:  MOVF   28,F
2194:  BNZ   219C
....................             fss1 = 1; // si no ha entrado antes 
2196:  MOVLW  01
2198:  MOVWF  2B
219A:  BRA    219E
....................          else 
....................             fse1 = 0; 
219C:  CLRF   28
....................          detecta_suma(); 
219E:  RCALL  1FDE
....................          break; 
21A0:  BRA    21A4
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
21A2:  RCALL  1FDE
....................          break; 
....................       } 
....................       } 
....................       enable1 = 0; 
21A4:  CLRF   x7A
....................       entra_act1 = 0; 
21A6:  CLRF   x75
....................    } 
21A8:  RETURN 0
.................... } 
....................  
.................... void contando2() 
.................... { // Revisa maquina de estados para par 2 
....................    if (entra_temp2 != edo2) 
*
2462:  MOVF   x7D,W
2464:  SUBWF  x82,W
2466:  BZ    2470
....................    { 
....................       entra_temp2 = edo2; 
2468:  MOVFF  7D,82
....................       enable2 = 1; 
246C:  MOVLW  01
246E:  MOVWF  x81
....................    } 
....................    if (enable2 == 1) 
2470:  DECFSZ x81,W
2472:  BRA    24B0
....................    { 
....................       switch (edo2) 
2474:  MOVLW  01
2476:  SUBWF  x7D,W
2478:  ADDLW  F4
247A:  BC    24AC
247C:  ADDLW  0C
247E:  GOTO   24B2
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
2482:  BRA    24AC
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss2) 
2484:  MOVF   2C,F
2486:  BNZ   248E
....................             fse2 = 1; 
2488:  MOVLW  01
248A:  MOVWF  29
248C:  BRA    2490
....................          else 
....................             fss2 = 0; 
248E:  CLRF   2C
....................          detecta_suma(); 
2490:  RCALL  1FDE
....................          break; 
2492:  BRA    24AC
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
2494:  RCALL  1FDE
....................          break; 
2496:  BRA    24AC
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
2498:  BRA    24AC
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse2) 
249A:  MOVF   29,F
249C:  BNZ   24A4
....................             fss2 = 1; 
249E:  MOVLW  01
24A0:  MOVWF  2C
24A2:  BRA    24A6
....................          else 
....................             fse2 = 0; 
24A4:  CLRF   29
....................          detecta_suma(); 
24A6:  RCALL  1FDE
....................          break; 
24A8:  BRA    24AC
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
24AA:  RCALL  1FDE
....................          break; 
....................       } 
....................       } 
....................       enable2 = 0; 
24AC:  CLRF   x81
....................       entra_act2 = 0; 
24AE:  CLRF   x7C
....................    } 
24B0:  RETURN 0
.................... } 
....................  
.................... void contando3() 
.................... { // Revisa maquina de estados para par 3 
....................    if (entra_temp3 != edo3) 
*
276C:  MOVF   x84,W
276E:  SUBWF  x89,W
2770:  BZ    277A
....................    { 
....................       entra_temp3 = edo3; 
2772:  MOVFF  84,89
....................       enable3 = 1; 
2776:  MOVLW  01
2778:  MOVWF  x88
....................    } 
....................    if (enable3 == 1) 
277A:  DECFSZ x88,W
277C:  BRA    27BA
....................    { 
....................       switch (edo3) 
277E:  MOVLW  01
2780:  SUBWF  x84,W
2782:  ADDLW  F4
2784:  BC    27B6
2786:  ADDLW  0C
2788:  GOTO   27BC
....................       { 
....................       case 1: 
....................       { // LLEGA PERSONA EN ENTRADA1 
....................          break; 
278C:  BRA    27B6
....................       } 
....................       case 5: 
....................       { // PERSONA A ENTRADO 
....................          if (!fss3) 
278E:  MOVF   2D,F
2790:  BNZ   2798
....................             fse3 = 1; 
2792:  MOVLW  01
2794:  MOVWF  2A
2796:  BRA    279A
....................          else 
....................             fss3 = 0; 
2798:  CLRF   2D
....................          detecta_suma(); 
279A:  RCALL  1FDE
....................          break; 
279C:  BRA    27B6
....................       } 
....................       case 6: 
....................       { // entraba y se regresa 
....................          detecta_suma(); 
279E:  RCALL  1FDE
....................          break; 
27A0:  BRA    27B6
....................       } 
....................       case 7: 
....................       { // PERSONA DETECTADO -SALIENDO 
....................          break; 
27A2:  BRA    27B6
....................       } 
....................       case 11: 
....................       { // PERSONA A SALIDO 
....................          if (!fse3) 
27A4:  MOVF   2A,F
27A6:  BNZ   27AE
....................             fss3 = 1; 
27A8:  MOVLW  01
27AA:  MOVWF  2D
27AC:  BRA    27B0
....................          else 
....................             fse3 = 0; 
27AE:  CLRF   2A
....................          detecta_suma(); 
27B0:  RCALL  1FDE
....................          break; 
27B2:  BRA    27B6
....................       } 
....................       case 12: 
....................       { // SALIA y se regresa 
....................          detecta_suma(); 
27B4:  RCALL  1FDE
....................          break; 
....................       } 
....................       } 
....................       enable3 = 0; 
27B6:  CLRF   x88
....................       entra_act3 = 0; 
27B8:  CLRF   x83
....................    } 
27BA:  RETURN 0
.................... } 
....................  
.................... void sensando1() 
.................... { // Define estados para la maquina de estados del par 1 
....................    /////normal/////// 
....................    if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 0) && (sale1 == 0)) 
*
1D58:  MOVF   x75,F
1D5A:  BNZ   1DA0
1D5C:  DECFSZ x69,W
1D5E:  BRA    1DA0
1D60:  MOVF   x6A,F
1D62:  BNZ   1DA0
1D64:  MOVF   x77,F
1D66:  BNZ   1DA0
1D68:  MOVF   x78,F
1D6A:  BNZ   1DA0
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
1D6C:  MOVF   5B,F
1D6E:  BNZ   1D76
1D70:  MOVF   5C,F
1D72:  BNZ   1D76
....................          sentidos(); 
1D74:  RCALL  1D0E
....................       lcd_gotoxy(8, 2); 
1D76:  MOVLW  08
1D78:  MOVLB  1
1D7A:  MOVWF  xDB
1D7C:  MOVLW  02
1D7E:  MOVWF  xDC
1D80:  MOVLB  0
1D82:  CALL   087C
....................       lcd_putc(0x7F); // flecha del sentido 
1D86:  MOVLW  7F
1D88:  MOVLB  1
1D8A:  MOVWF  xDA
1D8C:  MOVLB  0
1D8E:  CALL   08CE
....................       des1 = 1; 
1D92:  MOVLW  01
1D94:  MOVWF  x98
....................       //// 
....................       edo1 = 1; 
1D96:  MOVWF  x76
....................       entra1 = 1; 
1D98:  MOVWF  x77
....................       edoa1 = 1; 
1D9A:  MOVWF  x79
....................       entra_act1 = 1; 
1D9C:  MOVWF  x75
....................    } 
1D9E:  BRA    1FDC
....................    /// prioridad 
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 1) && (entra1 == 1) && (sale1 == 0)) 
1DA0:  MOVF   x75,F
1DA2:  BNZ   1DC0
1DA4:  DECFSZ x69,W
1DA6:  BRA    1DC0
1DA8:  DECFSZ x6A,W
1DAA:  BRA    1DC0
1DAC:  DECFSZ x77,W
1DAE:  BRA    1DC0
1DB0:  MOVF   x78,F
1DB2:  BNZ   1DC0
....................    { // PERSONA ENTRANDO 
....................       edo1 = 3; 
1DB4:  MOVLW  03
1DB6:  MOVWF  x76
....................       edoa1 = 0; 
1DB8:  CLRF   x79
....................       entra_act1 = 1; 
1DBA:  MOVLW  01
1DBC:  MOVWF  x75
....................    } 
1DBE:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 1) && (sale1 == 0)) 
1DC0:  MOVF   x75,F
1DC2:  BNZ   1DDE
1DC4:  MOVF   x69,F
1DC6:  BNZ   1DDE
1DC8:  DECFSZ x6A,W
1DCA:  BRA    1DDE
1DCC:  DECFSZ x77,W
1DCE:  BRA    1DDE
1DD0:  MOVF   x78,F
1DD2:  BNZ   1DDE
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo1 = 4; 
1DD4:  MOVLW  04
1DD6:  MOVWF  x76
....................       entra_act1 = 1; 
1DD8:  MOVLW  01
1DDA:  MOVWF  x75
....................    } 
1DDC:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 0) && (entra1 == 1) && (sale1 == 0)) 
1DDE:  MOVF   x75,F
1DE0:  BNZ   1E36
1DE2:  MOVF   x69,F
1DE4:  BNZ   1E36
1DE6:  MOVF   x6A,F
1DE8:  BNZ   1E36
1DEA:  MOVF   x79,F
1DEC:  BNZ   1E36
1DEE:  DECFSZ x77,W
1DF0:  BRA    1E36
1DF2:  MOVF   x78,F
1DF4:  BNZ   1E36
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 2); 
1DF6:  MOVLW  08
1DF8:  MOVLB  1
1DFA:  MOVWF  xDB
1DFC:  MOVLW  02
1DFE:  MOVWF  xDC
1E00:  MOVLB  0
1E02:  CALL   087C
....................       lcd_putc(" "); 
1E06:  MOVLW  9A
1E08:  MOVWF  FF6
1E0A:  MOVLW  03
1E0C:  MOVWF  FF7
1E0E:  CALL   0A52
....................       des1 = 0; 
1E12:  CLRF   x98
....................       if (entra_temp1 == 4) 
1E14:  MOVF   x7B,W
1E16:  SUBLW  04
1E18:  BNZ   1E26
....................       { 
....................          edo1 = 5; 
1E1A:  MOVLW  05
1E1C:  MOVWF  x76
....................          entra1 = 0; 
1E1E:  CLRF   x77
....................          entra_act1 = 1; 
1E20:  MOVLW  01
1E22:  MOVWF  x75
....................       } 
1E24:  BRA    1E34
....................       else 
....................       { // entraba y se regresa 
....................          des1 = 0; 
1E26:  CLRF   x98
....................          edo1 = 6; 
1E28:  MOVLW  06
1E2A:  MOVWF  x76
....................          entra1 = 0; 
1E2C:  CLRF   x77
....................          edoa1 = 0; 
1E2E:  CLRF   x79
....................          entra_act1 = 1; 
1E30:  MOVLW  01
1E32:  MOVWF  x75
....................       } 
....................    } 
1E34:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 1) && (entra1 == 1) && (sale1 == 0)) 
1E36:  MOVF   x75,F
1E38:  BNZ   1E7A
1E3A:  MOVF   x69,F
1E3C:  BNZ   1E7A
1E3E:  MOVF   x6A,F
1E40:  BNZ   1E7A
1E42:  DECFSZ x79,W
1E44:  BRA    1E7A
1E46:  DECFSZ x77,W
1E48:  BRA    1E7A
1E4A:  MOVF   x78,F
1E4C:  BNZ   1E7A
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 2); 
1E4E:  MOVLW  08
1E50:  MOVLB  1
1E52:  MOVWF  xDB
1E54:  MOVLW  02
1E56:  MOVWF  xDC
1E58:  MOVLB  0
1E5A:  CALL   087C
....................       lcd_putc(" "); 
1E5E:  MOVLW  9C
1E60:  MOVWF  FF6
1E62:  MOVLW  03
1E64:  MOVWF  FF7
1E66:  CALL   0A52
....................       des1 = 0; 
1E6A:  CLRF   x98
....................       edo1 = 6; 
1E6C:  MOVLW  06
1E6E:  MOVWF  x76
....................       entra1 = 0; 
1E70:  CLRF   x77
....................       edoa1 = 0; 
1E72:  CLRF   x79
....................       entra_act1 = 1; 
1E74:  MOVLW  01
1E76:  MOVWF  x75
....................    } 
1E78:  BRA    1FDC
....................    ///// 
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 1) && (sale1 == 0)) 
1E7A:  MOVF   x75,F
1E7C:  BNZ   1E9A
1E7E:  DECFSZ x69,W
1E80:  BRA    1E9A
1E82:  MOVF   x6A,F
1E84:  BNZ   1E9A
1E86:  DECFSZ x77,W
1E88:  BRA    1E9A
1E8A:  MOVF   x78,F
1E8C:  BNZ   1E9A
....................    { 
....................       edo1 = 2; 
1E8E:  MOVLW  02
1E90:  MOVWF  x76
....................       edoa1 = 1; 
1E92:  MOVLW  01
1E94:  MOVWF  x79
....................       entra_act1 = 1; 
1E96:  MOVWF  x75
....................    } // checar prioridad 
1E98:  BRA    1FDC
....................    //////sentido inverso/// 
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 0) && (sale1 == 0)) 
1E9A:  MOVF   x75,F
1E9C:  BNZ   1EE4
1E9E:  MOVF   x69,F
1EA0:  BNZ   1EE4
1EA2:  DECFSZ x6A,W
1EA4:  BRA    1EE4
1EA6:  MOVF   x77,F
1EA8:  BNZ   1EE4
1EAA:  MOVF   x78,F
1EAC:  BNZ   1EE4
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
1EAE:  MOVF   5B,F
1EB0:  BNZ   1EB8
1EB2:  MOVF   5C,F
1EB4:  BNZ   1EB8
....................          sentidos(); 
1EB6:  RCALL  1D0E
....................       lcd_gotoxy(8, 2); 
1EB8:  MOVLW  08
1EBA:  MOVLB  1
1EBC:  MOVWF  xDB
1EBE:  MOVLW  02
1EC0:  MOVWF  xDC
1EC2:  MOVLB  0
1EC4:  CALL   087C
....................       lcd_putc(0x7E); // flecha del sentido 
1EC8:  MOVLW  7E
1ECA:  MOVLB  1
1ECC:  MOVWF  xDA
1ECE:  MOVLB  0
1ED0:  CALL   08CE
....................       des1 = 1; 
1ED4:  MOVLW  01
1ED6:  MOVWF  x98
....................       edo1 = 7; 
1ED8:  MOVLW  07
1EDA:  MOVWF  x76
....................       sale1 = 1; 
1EDC:  MOVLW  01
1EDE:  MOVWF  x78
....................       entra_act1 = 1; 
1EE0:  MOVWF  x75
....................    } 
1EE2:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 1) && (entra1 == 0) && (sale1 == 1)) 
1EE4:  MOVF   x75,F
1EE6:  BNZ   1F04
1EE8:  MOVF   x69,F
1EEA:  BNZ   1F04
1EEC:  DECFSZ x6A,W
1EEE:  BRA    1F04
1EF0:  MOVF   x77,F
1EF2:  BNZ   1F04
1EF4:  DECFSZ x78,W
1EF6:  BRA    1F04
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo1 = 8; 
1EF8:  MOVLW  08
1EFA:  MOVWF  x76
....................       edoa1 = 1; 
1EFC:  MOVLW  01
1EFE:  MOVWF  x79
....................       entra_act1 = 1; 
1F00:  MOVWF  x75
....................    } 
1F02:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 1) && (entra1 == 0) && (sale1 == 1)) 
1F04:  MOVF   x75,F
1F06:  BNZ   1F24
1F08:  DECFSZ x69,W
1F0A:  BRA    1F24
1F0C:  DECFSZ x6A,W
1F0E:  BRA    1F24
1F10:  MOVF   x77,F
1F12:  BNZ   1F24
1F14:  DECFSZ x78,W
1F16:  BRA    1F24
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo1 = 9; 
1F18:  MOVLW  09
1F1A:  MOVWF  x76
....................       edoa1 = 0; 
1F1C:  CLRF   x79
....................       entra_act1 = 1; 
1F1E:  MOVLW  01
1F20:  MOVWF  x75
....................    } 
1F22:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 1) && (detec2 == 0) && (entra1 == 0) && (sale1 == 1)) 
1F24:  MOVF   x75,F
1F26:  BNZ   1F42
1F28:  DECFSZ x69,W
1F2A:  BRA    1F42
1F2C:  MOVF   x6A,F
1F2E:  BNZ   1F42
1F30:  MOVF   x77,F
1F32:  BNZ   1F42
1F34:  DECFSZ x78,W
1F36:  BRA    1F42
....................    { // CASI TERMINA DE SALIR 
....................       edo1 = 10; 
1F38:  MOVLW  0A
1F3A:  MOVWF  x76
....................       entra_act1 = 1; 
1F3C:  MOVLW  01
1F3E:  MOVWF  x75
....................    } 
1F40:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 0) && (entra1 == 0) && (sale1 == 1)) 
1F42:  MOVF   x75,F
1F44:  BNZ   1F9A
1F46:  MOVF   x69,F
1F48:  BNZ   1F9A
1F4A:  MOVF   x6A,F
1F4C:  BNZ   1F9A
1F4E:  MOVF   x79,F
1F50:  BNZ   1F9A
1F52:  MOVF   x77,F
1F54:  BNZ   1F9A
1F56:  DECFSZ x78,W
1F58:  BRA    1F9A
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 2); 
1F5A:  MOVLW  08
1F5C:  MOVLB  1
1F5E:  MOVWF  xDB
1F60:  MOVLW  02
1F62:  MOVWF  xDC
1F64:  MOVLB  0
1F66:  CALL   087C
....................       lcd_putc(" "); 
1F6A:  MOVLW  9E
1F6C:  MOVWF  FF6
1F6E:  MOVLW  03
1F70:  MOVWF  FF7
1F72:  CALL   0A52
....................       if (entra_temp1 == 10) 
1F76:  MOVF   x7B,W
1F78:  SUBLW  0A
1F7A:  BNZ   1F8A
....................       { 
....................          des1 = 0; 
1F7C:  CLRF   x98
....................          edo1 = 11; 
1F7E:  MOVLW  0B
1F80:  MOVWF  x76
....................          sale1 = 0; 
1F82:  CLRF   x78
....................          entra_act1 = 1; 
1F84:  MOVLW  01
1F86:  MOVWF  x75
....................       } 
1F88:  BRA    1F98
....................       else 
....................       { 
....................          des1 = 0; 
1F8A:  CLRF   x98
....................          edo1 = 12; 
1F8C:  MOVLW  0C
1F8E:  MOVWF  x76
....................          sale1 = 0; 
1F90:  CLRF   x78
....................          edoa1 = 0; 
1F92:  CLRF   x79
....................          entra_act1 = 1; 
1F94:  MOVLW  01
1F96:  MOVWF  x75
....................       } 
....................    } 
1F98:  BRA    1FDC
....................    else if ((entra_act1 == 0) && (detec1 == 0) && (detec2 == 0) && (edoa1 == 1) && (entra1 == 0) && (sale1 == 1)) 
1F9A:  MOVF   x75,F
1F9C:  BNZ   1FDC
1F9E:  MOVF   x69,F
1FA0:  BNZ   1FDC
1FA2:  MOVF   x6A,F
1FA4:  BNZ   1FDC
1FA6:  DECFSZ x79,W
1FA8:  BRA    1FDC
1FAA:  MOVF   x77,F
1FAC:  BNZ   1FDC
1FAE:  DECFSZ x78,W
1FB0:  BRA    1FDC
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 2); 
1FB2:  MOVLW  08
1FB4:  MOVLB  1
1FB6:  MOVWF  xDB
1FB8:  MOVLW  02
1FBA:  MOVWF  xDC
1FBC:  MOVLB  0
1FBE:  CALL   087C
....................       lcd_putc(" "); 
1FC2:  MOVLW  A0
1FC4:  MOVWF  FF6
1FC6:  MOVLW  03
1FC8:  MOVWF  FF7
1FCA:  CALL   0A52
....................       des1 = 0; 
1FCE:  CLRF   x98
....................       edo1 = 12; 
1FD0:  MOVLW  0C
1FD2:  MOVWF  x76
....................       sale1 = 0; 
1FD4:  CLRF   x78
....................       edoa1 = 0; 
1FD6:  CLRF   x79
....................       entra_act1 = 1; 
1FD8:  MOVLW  01
1FDA:  MOVWF  x75
....................    } 
1FDC:  RETURN 0
.................... } 
....................  
.................... void sensando2() 
.................... { // Define estados para la maquina de estados del par 2 
....................    /////normal/////// 
....................    if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 0) && (sale2 == 0)) 
*
21DC:  MOVF   x7C,F
21DE:  BNZ   2224
21E0:  DECFSZ x6B,W
21E2:  BRA    2224
21E4:  MOVF   x6C,F
21E6:  BNZ   2224
21E8:  MOVF   x7E,F
21EA:  BNZ   2224
21EC:  MOVF   x7F,F
21EE:  BNZ   2224
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
21F0:  MOVF   5B,F
21F2:  BNZ   21FA
21F4:  MOVF   5C,F
21F6:  BNZ   21FA
....................          sentidos(); 
21F8:  RCALL  1D0E
....................       lcd_gotoxy(8, 3); 
21FA:  MOVLW  08
21FC:  MOVLB  1
21FE:  MOVWF  xDB
2200:  MOVLW  03
2202:  MOVWF  xDC
2204:  MOVLB  0
2206:  CALL   087C
....................       lcd_putc(0x7F); 
220A:  MOVLW  7F
220C:  MOVLB  1
220E:  MOVWF  xDA
2210:  MOVLB  0
2212:  CALL   08CE
....................       des2 = 1; 
2216:  MOVLW  01
2218:  MOVWF  x99
....................       edo2 = 1; 
221A:  MOVWF  x7D
....................       entra2 = 1; 
221C:  MOVWF  x7E
....................       edoa2 = 1; 
221E:  MOVWF  x80
....................       entra_act2 = 1; 
2220:  MOVWF  x7C
....................    } 
2222:  BRA    2460
....................    /// prioridad 
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 1) && (entra2 == 1) && (sale2 == 0)) 
2224:  MOVF   x7C,F
2226:  BNZ   2244
2228:  DECFSZ x6B,W
222A:  BRA    2244
222C:  DECFSZ x6C,W
222E:  BRA    2244
2230:  DECFSZ x7E,W
2232:  BRA    2244
2234:  MOVF   x7F,F
2236:  BNZ   2244
....................    { // PERSONA ENTRANDO 
....................       edo2 = 3; 
2238:  MOVLW  03
223A:  MOVWF  x7D
....................       edoa2 = 0; 
223C:  CLRF   x80
....................       entra_act2 = 1; 
223E:  MOVLW  01
2240:  MOVWF  x7C
....................    } 
2242:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 1) && (sale2 == 0)) 
2244:  MOVF   x7C,F
2246:  BNZ   2262
2248:  MOVF   x6B,F
224A:  BNZ   2262
224C:  DECFSZ x6C,W
224E:  BRA    2262
2250:  DECFSZ x7E,W
2252:  BRA    2262
2254:  MOVF   x7F,F
2256:  BNZ   2262
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo2 = 4; 
2258:  MOVLW  04
225A:  MOVWF  x7D
....................       entra_act2 = 1; 
225C:  MOVLW  01
225E:  MOVWF  x7C
....................    } 
2260:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 0) && (entra2 == 1) && (sale2 == 0)) 
2262:  MOVF   x7C,F
2264:  BNZ   22BA
2266:  MOVF   x6B,F
2268:  BNZ   22BA
226A:  MOVF   x6C,F
226C:  BNZ   22BA
226E:  MOVF   x80,F
2270:  BNZ   22BA
2272:  DECFSZ x7E,W
2274:  BRA    22BA
2276:  MOVF   x7F,F
2278:  BNZ   22BA
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 3); 
227A:  MOVLW  08
227C:  MOVLB  1
227E:  MOVWF  xDB
2280:  MOVLW  03
2282:  MOVWF  xDC
2284:  MOVLB  0
2286:  CALL   087C
....................       lcd_putc(" "); 
228A:  MOVLW  A2
228C:  MOVWF  FF6
228E:  MOVLW  03
2290:  MOVWF  FF7
2292:  CALL   0A52
....................       if (entra_temp2 == 4) 
2296:  MOVF   x82,W
2298:  SUBLW  04
229A:  BNZ   22AA
....................       { 
....................          des2 = 0; 
229C:  CLRF   x99
....................          edo2 = 5; 
229E:  MOVLW  05
22A0:  MOVWF  x7D
....................          entra2 = 0; 
22A2:  CLRF   x7E
....................          entra_act2 = 1; 
22A4:  MOVLW  01
22A6:  MOVWF  x7C
....................       } 
22A8:  BRA    22B8
....................       else 
....................       { 
....................          des2 = 0; 
22AA:  CLRF   x99
....................          edo2 = 6; 
22AC:  MOVLW  06
22AE:  MOVWF  x7D
....................          entra2 = 0; 
22B0:  CLRF   x7E
....................          edoa2 = 0; 
22B2:  CLRF   x80
....................          entra_act2 = 1; 
22B4:  MOVLW  01
22B6:  MOVWF  x7C
....................       } 
....................    } 
22B8:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 1) && (entra2 == 1) && (sale2 == 0)) 
22BA:  MOVF   x7C,F
22BC:  BNZ   22FE
22BE:  MOVF   x6B,F
22C0:  BNZ   22FE
22C2:  MOVF   x6C,F
22C4:  BNZ   22FE
22C6:  DECFSZ x80,W
22C8:  BRA    22FE
22CA:  DECFSZ x7E,W
22CC:  BRA    22FE
22CE:  MOVF   x7F,F
22D0:  BNZ   22FE
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 3); 
22D2:  MOVLW  08
22D4:  MOVLB  1
22D6:  MOVWF  xDB
22D8:  MOVLW  03
22DA:  MOVWF  xDC
22DC:  MOVLB  0
22DE:  CALL   087C
....................       lcd_putc(" "); 
22E2:  MOVLW  A4
22E4:  MOVWF  FF6
22E6:  MOVLW  03
22E8:  MOVWF  FF7
22EA:  CALL   0A52
....................       des2 = 0; 
22EE:  CLRF   x99
....................       edo2 = 6; 
22F0:  MOVLW  06
22F2:  MOVWF  x7D
....................       entra2 = 0; 
22F4:  CLRF   x7E
....................       edoa2 = 0; 
22F6:  CLRF   x80
....................       entra_act2 = 1; 
22F8:  MOVLW  01
22FA:  MOVWF  x7C
....................    } 
22FC:  BRA    2460
....................    ///// 
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 1) && (sale2 == 0)) 
22FE:  MOVF   x7C,F
2300:  BNZ   231E
2302:  DECFSZ x6B,W
2304:  BRA    231E
2306:  MOVF   x6C,F
2308:  BNZ   231E
230A:  DECFSZ x7E,W
230C:  BRA    231E
230E:  MOVF   x7F,F
2310:  BNZ   231E
....................    { 
....................       edo2 = 2; 
2312:  MOVLW  02
2314:  MOVWF  x7D
....................       edoa2 = 1; 
2316:  MOVLW  01
2318:  MOVWF  x80
....................       entra_act2 = 1; 
231A:  MOVWF  x7C
....................    } // checar prioridad 
231C:  BRA    2460
....................    //////sentido inverso/// 
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 0) && (sale2 == 0)) 
231E:  MOVF   x7C,F
2320:  BNZ   2368
2322:  MOVF   x6B,F
2324:  BNZ   2368
2326:  DECFSZ x6C,W
2328:  BRA    2368
232A:  MOVF   x7E,F
232C:  BNZ   2368
232E:  MOVF   x7F,F
2330:  BNZ   2368
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
2332:  MOVF   5B,F
2334:  BNZ   233C
2336:  MOVF   5C,F
2338:  BNZ   233C
....................          sentidos(); 
233A:  RCALL  1D0E
....................       lcd_gotoxy(8, 3); 
233C:  MOVLW  08
233E:  MOVLB  1
2340:  MOVWF  xDB
2342:  MOVLW  03
2344:  MOVWF  xDC
2346:  MOVLB  0
2348:  CALL   087C
....................       lcd_putc(0x7E); // flecha del sentido 
234C:  MOVLW  7E
234E:  MOVLB  1
2350:  MOVWF  xDA
2352:  MOVLB  0
2354:  CALL   08CE
....................       des2 = 1; 
2358:  MOVLW  01
235A:  MOVWF  x99
....................       edo2 = 7; 
235C:  MOVLW  07
235E:  MOVWF  x7D
....................       sale2 = 1; 
2360:  MOVLW  01
2362:  MOVWF  x7F
....................       entra_act2 = 1; 
2364:  MOVWF  x7C
....................    } 
2366:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 1) && (entra2 == 0) && (sale2 == 1)) 
2368:  MOVF   x7C,F
236A:  BNZ   2388
236C:  MOVF   x6B,F
236E:  BNZ   2388
2370:  DECFSZ x6C,W
2372:  BRA    2388
2374:  MOVF   x7E,F
2376:  BNZ   2388
2378:  DECFSZ x7F,W
237A:  BRA    2388
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo2 = 8; 
237C:  MOVLW  08
237E:  MOVWF  x7D
....................       edoa2 = 1; 
2380:  MOVLW  01
2382:  MOVWF  x80
....................       entra_act2 = 1; 
2384:  MOVWF  x7C
....................    } 
2386:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 1) && (entra2 == 0) && (sale2 == 1)) 
2388:  MOVF   x7C,F
238A:  BNZ   23A8
238C:  DECFSZ x6B,W
238E:  BRA    23A8
2390:  DECFSZ x6C,W
2392:  BRA    23A8
2394:  MOVF   x7E,F
2396:  BNZ   23A8
2398:  DECFSZ x7F,W
239A:  BRA    23A8
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo2 = 9; 
239C:  MOVLW  09
239E:  MOVWF  x7D
....................       edoa2 = 0; 
23A0:  CLRF   x80
....................       entra_act2 = 1; 
23A2:  MOVLW  01
23A4:  MOVWF  x7C
....................    } 
23A6:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 1) && (detec4 == 0) && (entra2 == 0) && (sale2 == 1)) 
23A8:  MOVF   x7C,F
23AA:  BNZ   23C6
23AC:  DECFSZ x6B,W
23AE:  BRA    23C6
23B0:  MOVF   x6C,F
23B2:  BNZ   23C6
23B4:  MOVF   x7E,F
23B6:  BNZ   23C6
23B8:  DECFSZ x7F,W
23BA:  BRA    23C6
....................    { // CASI TERMINA DE SALIR 
....................       edo2 = 10; 
23BC:  MOVLW  0A
23BE:  MOVWF  x7D
....................       entra_act2 = 1; 
23C0:  MOVLW  01
23C2:  MOVWF  x7C
....................    } 
23C4:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 0) && (entra2 == 0) && (sale2 == 1)) 
23C6:  MOVF   x7C,F
23C8:  BNZ   241E
23CA:  MOVF   x6B,F
23CC:  BNZ   241E
23CE:  MOVF   x6C,F
23D0:  BNZ   241E
23D2:  MOVF   x80,F
23D4:  BNZ   241E
23D6:  MOVF   x7E,F
23D8:  BNZ   241E
23DA:  DECFSZ x7F,W
23DC:  BRA    241E
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 3); 
23DE:  MOVLW  08
23E0:  MOVLB  1
23E2:  MOVWF  xDB
23E4:  MOVLW  03
23E6:  MOVWF  xDC
23E8:  MOVLB  0
23EA:  CALL   087C
....................       lcd_putc(" "); 
23EE:  MOVLW  A6
23F0:  MOVWF  FF6
23F2:  MOVLW  03
23F4:  MOVWF  FF7
23F6:  CALL   0A52
....................       if (entra_temp2 == 10) 
23FA:  MOVF   x82,W
23FC:  SUBLW  0A
23FE:  BNZ   240E
....................       { 
....................          des2 = 0; 
2400:  CLRF   x99
....................          edo2 = 11; 
2402:  MOVLW  0B
2404:  MOVWF  x7D
....................          sale2 = 0; 
2406:  CLRF   x7F
....................          entra_act2 = 1; 
2408:  MOVLW  01
240A:  MOVWF  x7C
....................       } 
240C:  BRA    241C
....................       else 
....................       { 
....................          des2 = 0; 
240E:  CLRF   x99
....................          edo2 = 12; 
2410:  MOVLW  0C
2412:  MOVWF  x7D
....................          sale2 = 0; 
2414:  CLRF   x7F
....................          edoa2 = 0; 
2416:  CLRF   x80
....................          entra_act2 = 1; 
2418:  MOVLW  01
241A:  MOVWF  x7C
....................       } 
....................    } 
241C:  BRA    2460
....................    else if ((entra_act2 == 0) && (detec3 == 0) && (detec4 == 0) && (edoa2 == 1) && (entra2 == 0) && (sale2 == 1)) 
241E:  MOVF   x7C,F
2420:  BNZ   2460
2422:  MOVF   x6B,F
2424:  BNZ   2460
2426:  MOVF   x6C,F
2428:  BNZ   2460
242A:  DECFSZ x80,W
242C:  BRA    2460
242E:  MOVF   x7E,F
2430:  BNZ   2460
2432:  DECFSZ x7F,W
2434:  BRA    2460
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 3); 
2436:  MOVLW  08
2438:  MOVLB  1
243A:  MOVWF  xDB
243C:  MOVLW  03
243E:  MOVWF  xDC
2440:  MOVLB  0
2442:  CALL   087C
....................       lcd_putc(" "); 
2446:  MOVLW  A8
2448:  MOVWF  FF6
244A:  MOVLW  03
244C:  MOVWF  FF7
244E:  CALL   0A52
....................       des2 = 0; 
2452:  CLRF   x99
....................       edo2 = 12; 
2454:  MOVLW  0C
2456:  MOVWF  x7D
....................       sale2 = 0; 
2458:  CLRF   x7F
....................       edoa2 = 0; 
245A:  CLRF   x80
....................       entra_act2 = 1; 
245C:  MOVLW  01
245E:  MOVWF  x7C
....................    } 
2460:  RETURN 0
.................... } 
....................  
.................... void sensando3() 
.................... { // Define estados para la maquina de estados del par 3 
....................    /////normal/////// 
....................    if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 0) && (sale3 == 0)) 
*
24E4:  MOVF   x83,F
24E6:  BNZ   252C
24E8:  DECFSZ x6D,W
24EA:  BRA    252C
24EC:  MOVF   x6E,F
24EE:  BNZ   252C
24F0:  MOVF   x85,F
24F2:  BNZ   252C
24F4:  MOVF   x86,F
24F6:  BNZ   252C
....................    { // LLEGA PERSONA EN ENTRADA1 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
24F8:  MOVF   5B,F
24FA:  BNZ   2502
24FC:  MOVF   5C,F
24FE:  BNZ   2502
....................          sentidos(); 
2500:  RCALL  1D0E
....................       lcd_gotoxy(8, 4); 
2502:  MOVLW  08
2504:  MOVLB  1
2506:  MOVWF  xDB
2508:  MOVLW  04
250A:  MOVWF  xDC
250C:  MOVLB  0
250E:  CALL   087C
....................       lcd_putc(0x7F); 
2512:  MOVLW  7F
2514:  MOVLB  1
2516:  MOVWF  xDA
2518:  MOVLB  0
251A:  CALL   08CE
....................       des3 = 1; 
251E:  MOVLW  01
2520:  MOVWF  x9A
....................       edo3 = 1; 
2522:  MOVWF  x84
....................       entra3 = 1; 
2524:  MOVWF  x85
....................       edoa3 = 1; 
2526:  MOVWF  x87
....................       entra_act3 = 1; 
2528:  MOVWF  x83
....................    } 
252A:  BRA    276A
....................    /// prioridad 
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 1) && (entra3 == 1) && (sale3 == 0)) 
252C:  MOVF   x83,F
252E:  BNZ   254C
2530:  DECFSZ x6D,W
2532:  BRA    254C
2534:  DECFSZ x6E,W
2536:  BRA    254C
2538:  DECFSZ x85,W
253A:  BRA    254C
253C:  MOVF   x86,F
253E:  BNZ   254C
....................    { // PERSONA ENTRANDO 
....................       edo3 = 3; 
2540:  MOVLW  03
2542:  MOVWF  x84
....................       edoa3 = 0; 
2544:  CLRF   x87
....................       entra_act3 = 1; 
2546:  MOVLW  01
2548:  MOVWF  x83
....................    } 
254A:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 1) && (sale3 == 0)) 
254C:  MOVF   x83,F
254E:  BNZ   256A
2550:  MOVF   x6D,F
2552:  BNZ   256A
2554:  DECFSZ x6E,W
2556:  BRA    256A
2558:  DECFSZ x85,W
255A:  BRA    256A
255C:  MOVF   x86,F
255E:  BNZ   256A
....................    { // PERSONA CASI TERMINA DE ENTRAR 
....................       edo3 = 4; 
2560:  MOVLW  04
2562:  MOVWF  x84
....................       entra_act3 = 1; 
2564:  MOVLW  01
2566:  MOVWF  x83
....................    } 
2568:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 0) && (entra3 == 1) && (sale3 == 0)) 
256A:  MOVF   x83,F
256C:  BNZ   25C2
256E:  MOVF   x6D,F
2570:  BNZ   25C2
2572:  MOVF   x6E,F
2574:  BNZ   25C2
2576:  MOVF   x87,F
2578:  BNZ   25C2
257A:  DECFSZ x85,W
257C:  BRA    25C2
257E:  MOVF   x86,F
2580:  BNZ   25C2
....................    { // PERSONA A ENTRADO 
....................       lcd_gotoxy(8, 4); 
2582:  MOVLW  08
2584:  MOVLB  1
2586:  MOVWF  xDB
2588:  MOVLW  04
258A:  MOVWF  xDC
258C:  MOVLB  0
258E:  CALL   087C
....................       lcd_putc(" "); 
2592:  MOVLW  AA
2594:  MOVWF  FF6
2596:  MOVLW  03
2598:  MOVWF  FF7
259A:  CALL   0A52
....................       if (entra_temp3 == 4) 
259E:  MOVF   x89,W
25A0:  SUBLW  04
25A2:  BNZ   25B2
....................       { 
....................          des3 = 0; 
25A4:  CLRF   x9A
....................          edo3 = 5; 
25A6:  MOVLW  05
25A8:  MOVWF  x84
....................          entra3 = 0; 
25AA:  CLRF   x85
....................          entra_act3 = 1; 
25AC:  MOVLW  01
25AE:  MOVWF  x83
....................       } 
25B0:  BRA    25C0
....................       else 
....................       { 
....................          des3 = 0; 
25B2:  CLRF   x9A
....................          edo3 = 6; 
25B4:  MOVLW  06
25B6:  MOVWF  x84
....................          entra3 = 0; 
25B8:  CLRF   x85
....................          edoa3 = 0; 
25BA:  CLRF   x87
....................          entra_act3 = 1; 
25BC:  MOVLW  01
25BE:  MOVWF  x83
....................       } 
....................    } 
25C0:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 1) && (entra3 == 1) && (sale3 == 0)) 
25C2:  MOVF   x83,F
25C4:  BNZ   2606
25C6:  MOVF   x6D,F
25C8:  BNZ   2606
25CA:  MOVF   x6E,F
25CC:  BNZ   2606
25CE:  DECFSZ x87,W
25D0:  BRA    2606
25D2:  DECFSZ x85,W
25D4:  BRA    2606
25D6:  MOVF   x86,F
25D8:  BNZ   2606
....................    { // entraba y se regresa 
....................       lcd_gotoxy(8, 4); 
25DA:  MOVLW  08
25DC:  MOVLB  1
25DE:  MOVWF  xDB
25E0:  MOVLW  04
25E2:  MOVWF  xDC
25E4:  MOVLB  0
25E6:  CALL   087C
....................       lcd_putc(" "); 
25EA:  MOVLW  AC
25EC:  MOVWF  FF6
25EE:  MOVLW  03
25F0:  MOVWF  FF7
25F2:  CALL   0A52
....................       des3 = 0; 
25F6:  CLRF   x9A
....................       edo3 = 6; 
25F8:  MOVLW  06
25FA:  MOVWF  x84
....................       entra3 = 0; 
25FC:  CLRF   x85
....................       edoa3 = 0; 
25FE:  CLRF   x87
....................       entra_act3 = 1; 
2600:  MOVLW  01
2602:  MOVWF  x83
....................    } 
2604:  BRA    276A
....................    ///// 
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 1) && (sale3 == 0)) 
2606:  MOVF   x83,F
2608:  BNZ   2626
260A:  DECFSZ x6D,W
260C:  BRA    2626
260E:  MOVF   x6E,F
2610:  BNZ   2626
2612:  DECFSZ x85,W
2614:  BRA    2626
2616:  MOVF   x86,F
2618:  BNZ   2626
....................    { 
....................       // sentidos(); 
....................       edo3 = 2; 
261A:  MOVLW  02
261C:  MOVWF  x84
....................       edoa3 = 1; 
261E:  MOVLW  01
2620:  MOVWF  x87
....................       entra_act3 = 1; 
2622:  MOVWF  x83
....................    } // checar prioridad 
2624:  BRA    276A
....................    //////sentido inverso/// 
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 0) && (sale3 == 0)) 
2626:  MOVF   x83,F
2628:  BNZ   2672
262A:  MOVF   x6D,F
262C:  BNZ   2672
262E:  DECFSZ x6E,W
2630:  BRA    2672
2632:  MOVF   x85,F
2634:  BNZ   2672
2636:  MOVF   x86,F
2638:  BNZ   2672
....................    { // PERSONA DETECTADO -SALIENDO POR ENTRADA 
....................       if ((sen_ent == 0) && (sen_sal == 0)) 
263A:  MOVF   5B,F
263C:  BNZ   2646
263E:  MOVF   5C,F
2640:  BNZ   2646
....................          sentidos(); 
2642:  CALL   1D0E
....................       lcd_gotoxy(8, 4); 
2646:  MOVLW  08
2648:  MOVLB  1
264A:  MOVWF  xDB
264C:  MOVLW  04
264E:  MOVWF  xDC
2650:  MOVLB  0
2652:  CALL   087C
....................       lcd_putc(0x7E); // flecha del sentido 
2656:  MOVLW  7E
2658:  MOVLB  1
265A:  MOVWF  xDA
265C:  MOVLB  0
265E:  CALL   08CE
....................       des3 = 1; 
2662:  MOVLW  01
2664:  MOVWF  x9A
....................       edo3 = 7; 
2666:  MOVLW  07
2668:  MOVWF  x84
....................       sale3 = 1; 
266A:  MOVLW  01
266C:  MOVWF  x86
....................       entra_act3 = 1; 
266E:  MOVWF  x83
....................    } 
2670:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 1) && (entra3 == 0) && (sale3 == 1)) 
2672:  MOVF   x83,F
2674:  BNZ   2692
2676:  MOVF   x6D,F
2678:  BNZ   2692
267A:  DECFSZ x6E,W
267C:  BRA    2692
267E:  MOVF   x85,F
2680:  BNZ   2692
2682:  DECFSZ x86,W
2684:  BRA    2692
....................    { // SALIENDO POR ENTRADA PARTE 1 
....................       edo3 = 8; 
2686:  MOVLW  08
2688:  MOVWF  x84
....................       edoa3 = 1; 
268A:  MOVLW  01
268C:  MOVWF  x87
....................       entra_act3 = 1; 
268E:  MOVWF  x83
....................    } 
2690:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 1) && (entra3 == 0) && (sale3 == 1)) 
2692:  MOVF   x83,F
2694:  BNZ   26B2
2696:  DECFSZ x6D,W
2698:  BRA    26B2
269A:  DECFSZ x6E,W
269C:  BRA    26B2
269E:  MOVF   x85,F
26A0:  BNZ   26B2
26A2:  DECFSZ x86,W
26A4:  BRA    26B2
....................    { // SALIENDO POR ENTRADA PARTE 2 
....................       edo3 = 9; 
26A6:  MOVLW  09
26A8:  MOVWF  x84
....................       edoa3 = 0; 
26AA:  CLRF   x87
....................       entra_act3 = 1; 
26AC:  MOVLW  01
26AE:  MOVWF  x83
....................    } 
26B0:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 1) && (detec6 == 0) && (entra3 == 0) && (sale3 == 1)) 
26B2:  MOVF   x83,F
26B4:  BNZ   26D0
26B6:  DECFSZ x6D,W
26B8:  BRA    26D0
26BA:  MOVF   x6E,F
26BC:  BNZ   26D0
26BE:  MOVF   x85,F
26C0:  BNZ   26D0
26C2:  DECFSZ x86,W
26C4:  BRA    26D0
....................    { // CASI TERMINA DE SALIR 
....................       edo3 = 10; 
26C6:  MOVLW  0A
26C8:  MOVWF  x84
....................       entra_act3 = 1; 
26CA:  MOVLW  01
26CC:  MOVWF  x83
....................    } 
26CE:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 0) && (entra3 == 0) && (sale3 == 1)) 
26D0:  MOVF   x83,F
26D2:  BNZ   2728
26D4:  MOVF   x6D,F
26D6:  BNZ   2728
26D8:  MOVF   x6E,F
26DA:  BNZ   2728
26DC:  MOVF   x87,F
26DE:  BNZ   2728
26E0:  MOVF   x85,F
26E2:  BNZ   2728
26E4:  DECFSZ x86,W
26E6:  BRA    2728
....................    { // PERSONA A SALIDO POR ENTRADA 
....................       lcd_gotoxy(8, 4); 
26E8:  MOVLW  08
26EA:  MOVLB  1
26EC:  MOVWF  xDB
26EE:  MOVLW  04
26F0:  MOVWF  xDC
26F2:  MOVLB  0
26F4:  CALL   087C
....................       lcd_putc(" "); 
26F8:  MOVLW  AE
26FA:  MOVWF  FF6
26FC:  MOVLW  03
26FE:  MOVWF  FF7
2700:  CALL   0A52
....................       if (entra_temp3 == 10) 
2704:  MOVF   x89,W
2706:  SUBLW  0A
2708:  BNZ   2718
....................       { 
....................          des3 = 0; 
270A:  CLRF   x9A
....................          edo3 = 11; 
270C:  MOVLW  0B
270E:  MOVWF  x84
....................          sale3 = 0; 
2710:  CLRF   x86
....................          entra_act3 = 1; 
2712:  MOVLW  01
2714:  MOVWF  x83
....................       } 
2716:  BRA    2726
....................       else 
....................       { 
....................          des3 = 0; 
2718:  CLRF   x9A
....................          edo3 = 12; 
271A:  MOVLW  0C
271C:  MOVWF  x84
....................          sale3 = 0; 
271E:  CLRF   x86
....................          edoa3 = 0; 
2720:  CLRF   x87
....................          entra_act3 = 1; 
2722:  MOVLW  01
2724:  MOVWF  x83
....................       } 
....................    } 
2726:  BRA    276A
....................    else if ((entra_act3 == 0) && (detec5 == 0) && (detec6 == 0) && (edoa3 == 1) && (entra3 == 0) && (sale3 == 1)) 
2728:  MOVF   x83,F
272A:  BNZ   276A
272C:  MOVF   x6D,F
272E:  BNZ   276A
2730:  MOVF   x6E,F
2732:  BNZ   276A
2734:  DECFSZ x87,W
2736:  BRA    276A
2738:  MOVF   x85,F
273A:  BNZ   276A
273C:  DECFSZ x86,W
273E:  BRA    276A
....................    { // SALIA y se regresa 
....................       lcd_gotoxy(8, 4); 
2740:  MOVLW  08
2742:  MOVLB  1
2744:  MOVWF  xDB
2746:  MOVLW  04
2748:  MOVWF  xDC
274A:  MOVLB  0
274C:  CALL   087C
....................       lcd_putc(" "); 
2750:  MOVLW  B0
2752:  MOVWF  FF6
2754:  MOVLW  03
2756:  MOVWF  FF7
2758:  CALL   0A52
....................       des3 = 0; 
275C:  CLRF   x9A
....................       edo3 = 12; 
275E:  MOVLW  0C
2760:  MOVWF  x84
....................       sale3 = 0; 
2762:  CLRF   x86
....................       edoa3 = 0; 
2764:  CLRF   x87
....................       entra_act3 = 1; 
2766:  MOVLW  01
2768:  MOVWF  x83
....................    } 
276A:  RETURN 0
.................... } 
....................  
.................... void sensores() 
.................... { // Detecta estado (bloqueado o libre) de los sensores 
....................    // sensor1 
....................    ent1 = input(entrada01); 
*
27EE:  BSF    F93.4
27F0:  CLRF   55
27F2:  BTFSC  F81.4
27F4:  INCF   55,F
....................    if (ent1 == 1) 
27F6:  DECFSZ 55,W
27F8:  BRA    2812
....................    { 
....................       sub_cta1 = 0; 
27FA:  CLRF   5E
27FC:  CLRF   5D
....................       detec1 = 0; 
27FE:  CLRF   x69
....................       bloq_p1 = 0; // deshabilita bloqueo par1 
2800:  CLRF   x9B
....................       tim_p1 = 0; 
2802:  CLRF   xA2
2804:  CLRF   xA1
....................       if (en_b1) 
2806:  MOVF   x9E,F
2808:  BZ    2810
....................       {                        // pregunta si esta sonando el par1 
....................          output_low(salida01); // apaga alarma bloqueo 
280A:  BCF    F94.3
280C:  BCF    F8B.3
....................          en_b1 = 0; 
280E:  CLRF   x9E
....................       } 
....................    } 
2810:  BRA    286C
....................    else 
....................    { 
....................       if (sub_cta1 >= s_cta) 
2812:  MOVF   5E,F
2814:  BNZ   281C
2816:  MOVF   5D,W
2818:  SUBLW  04
281A:  BC    2820
....................          detec1 = 1; // revisa si se interumpio la luz en (5ms*4) 
281C:  MOVLW  01
281E:  MOVWF  x69
....................       if (sub_d1 != detec1) 
2820:  MOVF   x69,W
2822:  SUBWF  x6F,W
2824:  BZ    286C
....................       { // si, cambia de estado el sensor 
....................          sub_d1 = detec1; 
2826:  MOVFF  69,6F
....................          enable1 = 1; 
282A:  MOVLW  01
282C:  MOVWF  x7A
....................          lcd_gotoxy(5, 2); 
282E:  MOVLW  05
2830:  MOVLB  1
2832:  MOVWF  xDB
2834:  MOVLW  02
2836:  MOVWF  xDC
2838:  MOVLB  0
283A:  CALL   087C
....................          printf(lcd_putc, "1:%d", sub_d1); 
283E:  MOVLW  31
2840:  MOVLB  1
2842:  MOVWF  xDA
2844:  MOVLB  0
2846:  CALL   08CE
284A:  MOVLW  3A
284C:  MOVLB  1
284E:  MOVWF  xDA
2850:  MOVLB  0
2852:  CALL   08CE
2856:  MOVFF  6F,1D0
285A:  MOVLW  18
285C:  MOVLB  1
285E:  MOVWF  xD1
2860:  MOVLB  0
2862:  CALL   1050
....................          sensando1(); 
2866:  CALL   1D58
....................          contando1(); 
286A:  RCALL  215A
....................       } 
....................    } 
....................    // sensor2 
....................    ent2 = input(entrada02); 
286C:  BSF    F95.4
286E:  CLRF   56
2870:  BTFSC  F83.4
2872:  INCF   56,F
....................    if (ent2 == 1) 
2874:  DECFSZ 56,W
2876:  BRA    2894
....................    { 
....................       output_high(salida02); // 
2878:  BCF    F94.4
287A:  BSF    F8B.4
....................       sub_cta2 = 0; 
287C:  CLRF   x60
287E:  CLRF   5F
....................       detec2 = 0; 
2880:  CLRF   x6A
....................       bloq_p1 = 0; // deshabilita bloqueo 
2882:  CLRF   x9B
....................       tim_p1 = 0; 
2884:  CLRF   xA2
2886:  CLRF   xA1
....................       if (en_b1) 
2888:  MOVF   x9E,F
288A:  BZ    2892
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
288C:  BCF    F94.3
288E:  BCF    F8B.3
....................          en_b1 = 0; 
2890:  CLRF   x9E
....................       } 
....................    } 
2892:  BRA    28FC
....................    else 
....................    { 
....................       output_low(salida02); 
2894:  BCF    F94.4
2896:  BCF    F8B.4
....................       if (sub_cta2 >= s_cta) 
2898:  MOVF   x60,F
289A:  BNZ   28A2
289C:  MOVF   5F,W
289E:  SUBLW  04
28A0:  BC    28A6
....................          detec2 = 1; 
28A2:  MOVLW  01
28A4:  MOVWF  x6A
....................       if (sub_d2 != detec2) 
28A6:  MOVF   x6A,W
28A8:  SUBWF  x70,W
28AA:  BZ    28FC
....................       { 
....................          sub_d2 = detec2; 
28AC:  MOVFF  6A,70
....................          enable1 = 1; 
28B0:  MOVLW  01
28B2:  MOVWF  x7A
....................          lcd_gotoxy(1, 2); 
28B4:  MOVLB  1
28B6:  MOVWF  xDB
28B8:  MOVLW  02
28BA:  MOVWF  xDC
28BC:  MOVLB  0
28BE:  CALL   087C
....................          printf(lcd_putc, "2:%d ", sub_d2); 
28C2:  MOVLW  32
28C4:  MOVLB  1
28C6:  MOVWF  xDA
28C8:  MOVLB  0
28CA:  CALL   08CE
28CE:  MOVLW  3A
28D0:  MOVLB  1
28D2:  MOVWF  xDA
28D4:  MOVLB  0
28D6:  CALL   08CE
28DA:  MOVFF  70,1D0
28DE:  MOVLW  18
28E0:  MOVLB  1
28E2:  MOVWF  xD1
28E4:  MOVLB  0
28E6:  CALL   1050
28EA:  MOVLW  20
28EC:  MOVLB  1
28EE:  MOVWF  xDA
28F0:  MOVLB  0
28F2:  CALL   08CE
....................          sensando1(); 
28F6:  CALL   1D58
....................          contando1(); 
28FA:  RCALL  215A
....................       } 
....................    } 
....................    // sensor3 
....................    ent3 = input(entrada03); 
28FC:  BSF    F93.2
28FE:  CLRF   57
2900:  BTFSC  F81.2
2902:  INCF   57,F
....................    if (ent3 == 1) 
2904:  DECFSZ 57,W
2906:  BRA    2920
....................    { 
....................       sub_cta3 = 0; 
2908:  CLRF   x62
290A:  CLRF   x61
....................       detec3 = 0; 
290C:  CLRF   x6B
....................       bloq_p2 = 0; // deshabilita bloqueo 
290E:  CLRF   x9C
....................       tim_p2 = 0; 
2910:  CLRF   xA4
2912:  CLRF   xA3
....................       if (en_b2) 
2914:  MOVF   x9F,F
2916:  BZ    291E
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2918:  BCF    F94.3
291A:  BCF    F8B.3
....................          en_b2 = 0; 
291C:  CLRF   x9F
....................       } 
....................    } 
291E:  BRA    2978
....................    else 
....................    { 
....................       if (sub_cta3 >= s_cta) 
2920:  MOVF   x62,F
2922:  BNZ   292A
2924:  MOVF   x61,W
2926:  SUBLW  04
2928:  BC    292E
....................          detec3 = 1; 
292A:  MOVLW  01
292C:  MOVWF  x6B
....................       if (sub_d3 != detec3) 
292E:  MOVF   x6B,W
2930:  SUBWF  x71,W
2932:  BZ    2978
....................       { 
....................          sub_d3 = detec3; 
2934:  MOVFF  6B,71
....................          enable2 = 1; 
2938:  MOVLW  01
293A:  MOVWF  x81
....................          lcd_gotoxy(5, 3); 
293C:  MOVLW  05
293E:  MOVLB  1
2940:  MOVWF  xDB
2942:  MOVLW  03
2944:  MOVWF  xDC
2946:  MOVLB  0
2948:  CALL   087C
....................          printf(lcd_putc, "3:%d", sub_d3); 
294C:  MOVLW  33
294E:  MOVLB  1
2950:  MOVWF  xDA
2952:  MOVLB  0
2954:  CALL   08CE
2958:  MOVLW  3A
295A:  MOVLB  1
295C:  MOVWF  xDA
295E:  MOVLB  0
2960:  CALL   08CE
2964:  MOVFF  71,1D0
2968:  MOVLW  18
296A:  MOVLB  1
296C:  MOVWF  xD1
296E:  MOVLB  0
2970:  CALL   1050
....................          sensando2(); 
2974:  RCALL  21DC
....................          contando2(); 
2976:  RCALL  2462
....................       } 
....................    } 
....................    // sensor4 
....................    ent4 = input(entrada04); 
2978:  BSF    F93.3
297A:  CLRF   58
297C:  BTFSC  F81.3
297E:  INCF   58,F
....................    if (ent4 == 1) 
2980:  DECFSZ 58,W
2982:  BRA    29A0
....................    { 
....................       output_high(salida02); // 
2984:  BCF    F94.4
2986:  BSF    F8B.4
....................       sub_cta4 = 0; 
2988:  CLRF   x64
298A:  CLRF   x63
....................       detec4 = 0; 
298C:  CLRF   x6C
....................       bloq_p2 = 0; // deshabilita bloqueo 
298E:  CLRF   x9C
....................       tim_p2 = 0; 
2990:  CLRF   xA4
2992:  CLRF   xA3
....................       if (en_b2) 
2994:  MOVF   x9F,F
2996:  BZ    299E
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2998:  BCF    F94.3
299A:  BCF    F8B.3
....................          en_b2 = 0; 
299C:  CLRF   x9F
....................       } 
....................    } 
299E:  BRA    2A08
....................    else 
....................    { 
....................       output_low(salida02); 
29A0:  BCF    F94.4
29A2:  BCF    F8B.4
....................       if (sub_cta4 >= s_cta) 
29A4:  MOVF   x64,F
29A6:  BNZ   29AE
29A8:  MOVF   x63,W
29AA:  SUBLW  04
29AC:  BC    29B2
....................          detec4 = 1; 
29AE:  MOVLW  01
29B0:  MOVWF  x6C
....................       if (sub_d4 != detec4) 
29B2:  MOVF   x6C,W
29B4:  SUBWF  x72,W
29B6:  BZ    2A08
....................       { 
....................          sub_d4 = detec4; 
29B8:  MOVFF  6C,72
....................          enable2 = 1; 
29BC:  MOVLW  01
29BE:  MOVWF  x81
....................          lcd_gotoxy(1, 3); 
29C0:  MOVLB  1
29C2:  MOVWF  xDB
29C4:  MOVLW  03
29C6:  MOVWF  xDC
29C8:  MOVLB  0
29CA:  CALL   087C
....................          printf(lcd_putc, "4:%d ", sub_d4); 
29CE:  MOVLW  34
29D0:  MOVLB  1
29D2:  MOVWF  xDA
29D4:  MOVLB  0
29D6:  CALL   08CE
29DA:  MOVLW  3A
29DC:  MOVLB  1
29DE:  MOVWF  xDA
29E0:  MOVLB  0
29E2:  CALL   08CE
29E6:  MOVFF  72,1D0
29EA:  MOVLW  18
29EC:  MOVLB  1
29EE:  MOVWF  xD1
29F0:  MOVLB  0
29F2:  CALL   1050
29F6:  MOVLW  20
29F8:  MOVLB  1
29FA:  MOVWF  xDA
29FC:  MOVLB  0
29FE:  CALL   08CE
....................          sensando2(); 
2A02:  CALL   21DC
....................          contando2(); 
2A06:  RCALL  2462
....................       } 
....................    } 
....................    // sensor5 
....................    ent5 = input(entrada05); 
2A08:  BSF    F93.0
2A0A:  CLRF   59
2A0C:  BTFSC  F81.0
2A0E:  INCF   59,F
....................    if (ent5 == 1) 
2A10:  DECFSZ 59,W
2A12:  BRA    2A2C
....................    { 
....................       sub_cta5 = 0; 
2A14:  CLRF   x66
2A16:  CLRF   x65
....................       detec5 = 0; 
2A18:  CLRF   x6D
....................       bloq_p3 = 0; // deshabilita bloqueo 
2A1A:  CLRF   x9D
....................       tim_p3 = 0; 
2A1C:  CLRF   xA6
2A1E:  CLRF   xA5
....................       if (en_b3) 
2A20:  MOVF   xA0,F
2A22:  BZ    2A2A
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2A24:  BCF    F94.3
2A26:  BCF    F8B.3
....................          en_b3 = 0; 
2A28:  CLRF   xA0
....................       } 
....................    } 
2A2A:  BRA    2A84
....................    else 
....................    { 
....................       if (sub_cta5 >= s_cta) 
2A2C:  MOVF   x66,F
2A2E:  BNZ   2A36
2A30:  MOVF   x65,W
2A32:  SUBLW  04
2A34:  BC    2A3A
....................          detec5 = 1; 
2A36:  MOVLW  01
2A38:  MOVWF  x6D
....................       if (sub_d5 != detec5) 
2A3A:  MOVF   x6D,W
2A3C:  SUBWF  x73,W
2A3E:  BZ    2A84
....................       { 
....................          sub_d5 = detec5; 
2A40:  MOVFF  6D,73
....................          enable3 = 1; 
2A44:  MOVLW  01
2A46:  MOVWF  x88
....................          lcd_gotoxy(5, 4); 
2A48:  MOVLW  05
2A4A:  MOVLB  1
2A4C:  MOVWF  xDB
2A4E:  MOVLW  04
2A50:  MOVWF  xDC
2A52:  MOVLB  0
2A54:  CALL   087C
....................          printf(lcd_putc, "5:%d", sub_d5); 
2A58:  MOVLW  35
2A5A:  MOVLB  1
2A5C:  MOVWF  xDA
2A5E:  MOVLB  0
2A60:  CALL   08CE
2A64:  MOVLW  3A
2A66:  MOVLB  1
2A68:  MOVWF  xDA
2A6A:  MOVLB  0
2A6C:  CALL   08CE
2A70:  MOVFF  73,1D0
2A74:  MOVLW  18
2A76:  MOVLB  1
2A78:  MOVWF  xD1
2A7A:  MOVLB  0
2A7C:  CALL   1050
....................          sensando3(); 
2A80:  RCALL  24E4
....................          contando3(); 
2A82:  RCALL  276C
....................       } 
....................    } 
....................    // sensor6 
....................    ent6 = input(entrada06); 
2A84:  BSF    F93.1
2A86:  CLRF   5A
2A88:  BTFSC  F81.1
2A8A:  INCF   5A,F
....................    if (ent6 == 1) 
2A8C:  DECFSZ 5A,W
2A8E:  BRA    2AAC
....................    { 
....................       output_high(salida02); // 
2A90:  BCF    F94.4
2A92:  BSF    F8B.4
....................       sub_cta6 = 0; 
2A94:  CLRF   x68
2A96:  CLRF   x67
....................       detec6 = 0; 
2A98:  CLRF   x6E
....................       bloq_p3 = 0; // deshabilita bloqueo 
2A9A:  CLRF   x9D
....................       tim_p3 = 0; 
2A9C:  CLRF   xA6
2A9E:  CLRF   xA5
....................       if (en_b3) 
2AA0:  MOVF   xA0,F
2AA2:  BZ    2AAA
....................       { 
....................          output_low(salida01); // apaga alarma bloqueo 
2AA4:  BCF    F94.3
2AA6:  BCF    F8B.3
....................          en_b3 = 0; 
2AA8:  CLRF   xA0
....................       } 
....................    } 
2AAA:  BRA    2B12
....................    else 
....................    { 
....................       output_low(salida02); // 
2AAC:  BCF    F94.4
2AAE:  BCF    F8B.4
....................       if (sub_cta6 >= s_cta) 
2AB0:  MOVF   x68,F
2AB2:  BNZ   2ABA
2AB4:  MOVF   x67,W
2AB6:  SUBLW  04
2AB8:  BC    2ABE
....................          detec6 = 1; 
2ABA:  MOVLW  01
2ABC:  MOVWF  x6E
....................       if (sub_d6 != detec6) 
2ABE:  MOVF   x6E,W
2AC0:  SUBWF  x74,W
2AC2:  BZ    2B12
....................       { 
....................          sub_d6 = detec6; 
2AC4:  MOVFF  6E,74
....................          enable3 = 1; 
2AC8:  MOVLW  01
2ACA:  MOVWF  x88
....................          lcd_gotoxy(1, 4); 
2ACC:  MOVLB  1
2ACE:  MOVWF  xDB
2AD0:  MOVLW  04
2AD2:  MOVWF  xDC
2AD4:  MOVLB  0
2AD6:  CALL   087C
....................          printf(lcd_putc, "6:%d ", sub_d6); 
2ADA:  MOVLW  36
2ADC:  MOVLB  1
2ADE:  MOVWF  xDA
2AE0:  MOVLB  0
2AE2:  CALL   08CE
2AE6:  MOVLW  3A
2AE8:  MOVLB  1
2AEA:  MOVWF  xDA
2AEC:  MOVLB  0
2AEE:  CALL   08CE
2AF2:  MOVFF  74,1D0
2AF6:  MOVLW  18
2AF8:  MOVLB  1
2AFA:  MOVWF  xD1
2AFC:  MOVLB  0
2AFE:  CALL   1050
2B02:  MOVLW  20
2B04:  MOVLB  1
2B06:  MOVWF  xDA
2B08:  MOVLB  0
2B0A:  CALL   08CE
....................          sensando3(); 
2B0E:  RCALL  24E4
....................          contando3(); 
2B10:  RCALL  276C
....................       } 
....................    } 
....................    ////////////////////////// 
....................    if ((detec1 == 1) && (detec2 == 1) && (bloq_p1 == 0)) 
2B12:  DECFSZ x69,W
2B14:  BRA    2B26
2B16:  DECFSZ x6A,W
2B18:  BRA    2B26
2B1A:  MOVF   x9B,F
2B1C:  BNZ   2B26
....................    { 
....................       bloq_p1 = 1; 
2B1E:  MOVLW  01
2B20:  MOVWF  x9B
....................       tim_p1 = 0; 
2B22:  CLRF   xA2
2B24:  CLRF   xA1
....................    } 
....................    if ((detec3 == 1) && (detec4 == 1) && (bloq_p2 == 0)) 
2B26:  DECFSZ x6B,W
2B28:  BRA    2B3A
2B2A:  DECFSZ x6C,W
2B2C:  BRA    2B3A
2B2E:  MOVF   x9C,F
2B30:  BNZ   2B3A
....................    { 
....................       bloq_p2 = 1; 
2B32:  MOVLW  01
2B34:  MOVWF  x9C
....................       tim_p2 = 0; 
2B36:  CLRF   xA4
2B38:  CLRF   xA3
....................    } 
....................    if ((detec5 == 1) && (detec6 == 1) && (bloq_p3 == 0)) 
2B3A:  DECFSZ x6D,W
2B3C:  BRA    2B4E
2B3E:  DECFSZ x6E,W
2B40:  BRA    2B4E
2B42:  MOVF   x9D,F
2B44:  BNZ   2B4E
....................    { 
....................       bloq_p3 = 1; 
2B46:  MOVLW  01
2B48:  MOVWF  x9D
....................       tim_p3 = 0; 
2B4A:  CLRF   xA6
2B4C:  CLRF   xA5
....................    } 
2B4E:  GOTO   33A2 (RETURN)
.................... } // end sensores 
....................  
.................... void sentidos() 
.................... { // Define si la persona esta entrando o saliendo 
....................    if ((!sen_ent) && (!sen_sal)) 
*
1D0E:  MOVF   5B,F
1D10:  BNZ   1D56
1D12:  MOVF   5C,F
1D14:  BNZ   1D56
....................    { 
....................       if (((detec1 == 1) && (detec3 == 1)) || ((detec1 == 1) && (detec5 == 1)) || ((detec3 == 1) && (detec5 == 1))) 
1D16:  DECFSZ x69,W
1D18:  BRA    1D20
1D1A:  DECFSZ x6B,W
1D1C:  BRA    1D20
1D1E:  BRA    1D32
1D20:  DECFSZ x69,W
1D22:  BRA    1D2A
1D24:  DECFSZ x6D,W
1D26:  BRA    1D2A
1D28:  BRA    1D32
1D2A:  DECFSZ x6B,W
1D2C:  BRA    1D36
1D2E:  DECFSZ x6D,W
1D30:  BRA    1D36
....................       { 
....................          sen_ent = 1; 
1D32:  MOVLW  01
1D34:  MOVWF  5B
....................          //!      lcd_gotoxy(17,4); 
....................          //!      lcd_putc("Sub"); 
....................       } 
....................       if (((detec2 == 1) && (detec4 == 1)) || ((detec2 == 1) && (detec6 == 1)) || ((detec4 == 1) && (detec6 == 1))) 
1D36:  DECFSZ x6A,W
1D38:  BRA    1D40
1D3A:  DECFSZ x6C,W
1D3C:  BRA    1D40
1D3E:  BRA    1D52
1D40:  DECFSZ x6A,W
1D42:  BRA    1D4A
1D44:  DECFSZ x6E,W
1D46:  BRA    1D4A
1D48:  BRA    1D52
1D4A:  DECFSZ x6C,W
1D4C:  BRA    1D56
1D4E:  DECFSZ x6E,W
1D50:  BRA    1D56
....................       { 
....................          sen_sal = 1; 
1D52:  MOVLW  01
1D54:  MOVWF  5C
....................          //!      lcd_gotoxy(17,4); 
....................          //!      lcd_putc("Baj"); 
....................       } 
....................    } 
1D56:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void rd_eeprom() 
.................... { // Revisa si cadena recibida es un instruccion 
....................    a = b = 0; 
....................    n = word_size; // 
....................    // i=0; 
....................    // i=2; 
....................    while ((b <= data_set) && (a == 0)) 
....................    { // NUMERO TOTAL DE INSTRUCCIONES 
....................       i = 0; 
....................       b++; 
....................       while (i < word_size) 
....................       { // word_size=10 
....................          memory[i] = read_eeprom(n + i); 
....................  
....................          if (memory[i] != XX[i]) 
....................             break; 
....................          i++; 
....................          if (i == word_size) 
....................             a = 1; 
....................       } 
....................       // fprintf(monitor,"memory:%s\r",memory); 
....................       n = n + word_size; // WORD_SIZE=30 
....................       restart_wdt(); 
....................    } 
.................... } 
.................... */ 
....................  
.................... void rd_eeprom_inicio() 
.................... { // 
....................    a = b = 0; 
....................    n = word_size; // 
....................  
....................    while (b <= data_set) 
....................    { // NUMERO TOTAL DE INSTRUCCIONES 
....................       i = 0; 
....................       b++; 
....................       while (i < word_size) 
....................       { // word_size=10 
....................          memory[i] = read_eeprom(n + i); 
....................          i++; 
....................          if (i == word_size) 
....................             a = 1; 
....................       } 
....................       fprintf(monitor, "memory:%s\r", memory); 
....................       n = n + word_size; // WORD_SIZE=30 
....................    } 
.................... } 
....................  
.................... void lcd_cuentas() 
.................... { // Escribe las cuenta en LCD 
....................    lcd_gotoxy(1, 1); 
*
0A72:  MOVLW  01
0A74:  MOVLB  1
0A76:  MOVWF  xDB
0A78:  MOVWF  xDC
0A7A:  MOVLB  0
0A7C:  RCALL  087C
....................    if (master) 
0A7E:  MOVF   45,F
0A80:  BTFSC  FD8.2
0A82:  BRA    0BA2
....................    { 
....................       printf(lcd_putc, "1 %c%c%c%c%c ", version[0], version[1], version[2], version[3], version[4]); 
0A84:  MOVLW  31
0A86:  MOVLB  1
0A88:  MOVWF  xDA
0A8A:  MOVLB  0
0A8C:  RCALL  08CE
0A8E:  MOVLW  20
0A90:  MOVLB  1
0A92:  MOVWF  xDA
0A94:  MOVLB  0
0A96:  RCALL  08CE
0A98:  MOVFF  18C,1DA
0A9C:  RCALL  08CE
0A9E:  MOVFF  18D,1DA
0AA2:  RCALL  08CE
0AA4:  MOVFF  18E,1DA
0AA8:  RCALL  08CE
0AAA:  MOVFF  18F,1DA
0AAE:  RCALL  08CE
0AB0:  MOVFF  190,1DA
0AB4:  RCALL  08CE
0AB6:  MOVLW  20
0AB8:  MOVLB  1
0ABA:  MOVWF  xDA
0ABC:  MOVLB  0
0ABE:  RCALL  08CE
....................       lcd_gotoxy(14, 1); 
0AC0:  MOVLW  0E
0AC2:  MOVLB  1
0AC4:  MOVWF  xDB
0AC6:  MOVLW  01
0AC8:  MOVWF  xDC
0ACA:  MOVLB  0
0ACC:  RCALL  087C
....................       printf(lcd_putc, "S1:%Ld ", entraront); 
0ACE:  MOVLW  BE
0AD0:  MOVWF  FF6
0AD2:  MOVLW  03
0AD4:  MOVWF  FF7
0AD6:  MOVLW  03
0AD8:  MOVLB  1
0ADA:  MOVWF  xD1
0ADC:  MOVLB  0
0ADE:  RCALL  092E
0AE0:  MOVLW  10
0AE2:  MOVWF  FE9
0AE4:  MOVFF  8B,1D2
0AE8:  MOVFF  8A,1D1
0AEC:  RCALL  0956
0AEE:  MOVLW  20
0AF0:  MOVLB  1
0AF2:  MOVWF  xDA
0AF4:  MOVLB  0
0AF6:  RCALL  08CE
....................       lcd_gotoxy(14, 2); 
0AF8:  MOVLW  0E
0AFA:  MOVLB  1
0AFC:  MOVWF  xDB
0AFE:  MOVLW  02
0B00:  MOVWF  xDC
0B02:  MOVLB  0
0B04:  RCALL  087C
....................       printf(lcd_putc, "B1:%Ld ", salieront); 
0B06:  MOVLW  C6
0B08:  MOVWF  FF6
0B0A:  MOVLW  03
0B0C:  MOVWF  FF7
0B0E:  MOVLW  03
0B10:  MOVLB  1
0B12:  MOVWF  xD1
0B14:  MOVLB  0
0B16:  RCALL  092E
0B18:  MOVLW  10
0B1A:  MOVWF  FE9
0B1C:  MOVFF  8D,1D2
0B20:  MOVFF  8C,1D1
0B24:  RCALL  0956
0B26:  MOVLW  20
0B28:  MOVLB  1
0B2A:  MOVWF  xDA
0B2C:  MOVLB  0
0B2E:  RCALL  08CE
....................       lcd_gotoxy(14, 3); 
0B30:  MOVLW  0E
0B32:  MOVLB  1
0B34:  MOVWF  xDB
0B36:  MOVLW  03
0B38:  MOVWF  xDC
0B3A:  MOVLB  0
0B3C:  RCALL  087C
....................       printf(lcd_putc, "S2:%Ld ", sub_atras); 
0B3E:  MOVLW  CE
0B40:  MOVWF  FF6
0B42:  MOVLW  03
0B44:  MOVWF  FF7
0B46:  MOVLW  03
0B48:  MOVLB  1
0B4A:  MOVWF  xD1
0B4C:  MOVLB  0
0B4E:  RCALL  092E
0B50:  MOVLW  10
0B52:  MOVWF  FE9
0B54:  MOVFF  35,1D2
0B58:  MOVFF  34,1D1
0B5C:  RCALL  0956
0B5E:  MOVLW  20
0B60:  MOVLB  1
0B62:  MOVWF  xDA
0B64:  MOVLB  0
0B66:  RCALL  08CE
....................       lcd_gotoxy(14, 4); 
0B68:  MOVLW  0E
0B6A:  MOVLB  1
0B6C:  MOVWF  xDB
0B6E:  MOVLW  04
0B70:  MOVWF  xDC
0B72:  MOVLB  0
0B74:  RCALL  087C
....................       printf(lcd_putc, "B2:%Ld ", baj_atras); 
0B76:  MOVLW  D6
0B78:  MOVWF  FF6
0B7A:  MOVLW  03
0B7C:  MOVWF  FF7
0B7E:  MOVLW  03
0B80:  MOVLB  1
0B82:  MOVWF  xD1
0B84:  MOVLB  0
0B86:  RCALL  092E
0B88:  MOVLW  10
0B8A:  MOVWF  FE9
0B8C:  MOVFF  37,1D2
0B90:  MOVFF  36,1D1
0B94:  RCALL  0956
0B96:  MOVLW  20
0B98:  MOVLB  1
0B9A:  MOVWF  xDA
0B9C:  MOVLB  0
0B9E:  RCALL  08CE
....................    } 
0BA0:  BRA    0C7E
....................    else 
....................    { 
....................       printf(lcd_putc, "2 %c%c%c%c%c ", version[0], version[1], version[2], version[3], version[4]); 
0BA2:  MOVLW  32
0BA4:  MOVLB  1
0BA6:  MOVWF  xDA
0BA8:  MOVLB  0
0BAA:  RCALL  08CE
0BAC:  MOVLW  20
0BAE:  MOVLB  1
0BB0:  MOVWF  xDA
0BB2:  MOVLB  0
0BB4:  RCALL  08CE
0BB6:  MOVFF  18C,1DA
0BBA:  RCALL  08CE
0BBC:  MOVFF  18D,1DA
0BC0:  RCALL  08CE
0BC2:  MOVFF  18E,1DA
0BC6:  RCALL  08CE
0BC8:  MOVFF  18F,1DA
0BCC:  RCALL  08CE
0BCE:  MOVFF  190,1DA
0BD2:  RCALL  08CE
0BD4:  MOVLW  20
0BD6:  MOVLB  1
0BD8:  MOVWF  xDA
0BDA:  MOVLB  0
0BDC:  RCALL  08CE
....................       lcd_gotoxy(14, 1); 
0BDE:  MOVLW  0E
0BE0:  MOVLB  1
0BE2:  MOVWF  xDB
0BE4:  MOVLW  01
0BE6:  MOVWF  xDC
0BE8:  MOVLB  0
0BEA:  RCALL  087C
....................       lcd_putc("S1:    "); 
0BEC:  MOVLW  DE
0BEE:  MOVWF  FF6
0BF0:  MOVLW  03
0BF2:  MOVWF  FF7
0BF4:  RCALL  0A52
....................       lcd_gotoxy(14, 2); 
0BF6:  MOVLW  0E
0BF8:  MOVLB  1
0BFA:  MOVWF  xDB
0BFC:  MOVLW  02
0BFE:  MOVWF  xDC
0C00:  MOVLB  0
0C02:  RCALL  087C
....................       lcd_putc("B1:    "); 
0C04:  MOVLW  E6
0C06:  MOVWF  FF6
0C08:  MOVLW  03
0C0A:  MOVWF  FF7
0C0C:  RCALL  0A52
....................       lcd_gotoxy(14, 3); 
0C0E:  MOVLW  0E
0C10:  MOVLB  1
0C12:  MOVWF  xDB
0C14:  MOVLW  03
0C16:  MOVWF  xDC
0C18:  MOVLB  0
0C1A:  RCALL  087C
....................       printf(lcd_putc, "S2:%Ld ", entraront); 
0C1C:  MOVLW  EE
0C1E:  MOVWF  FF6
0C20:  MOVLW  03
0C22:  MOVWF  FF7
0C24:  MOVLW  03
0C26:  MOVLB  1
0C28:  MOVWF  xD1
0C2A:  MOVLB  0
0C2C:  RCALL  092E
0C2E:  MOVLW  10
0C30:  MOVWF  FE9
0C32:  MOVFF  8B,1D2
0C36:  MOVFF  8A,1D1
0C3A:  RCALL  0956
0C3C:  MOVLW  20
0C3E:  MOVLB  1
0C40:  MOVWF  xDA
0C42:  MOVLB  0
0C44:  RCALL  08CE
....................       lcd_gotoxy(14, 4); 
0C46:  MOVLW  0E
0C48:  MOVLB  1
0C4A:  MOVWF  xDB
0C4C:  MOVLW  04
0C4E:  MOVWF  xDC
0C50:  MOVLB  0
0C52:  RCALL  087C
....................       printf(lcd_putc, "B2:%Ld ", salieront); 
0C54:  MOVLW  F6
0C56:  MOVWF  FF6
0C58:  MOVLW  03
0C5A:  MOVWF  FF7
0C5C:  MOVLW  03
0C5E:  MOVLB  1
0C60:  MOVWF  xD1
0C62:  MOVLB  0
0C64:  RCALL  092E
0C66:  MOVLW  10
0C68:  MOVWF  FE9
0C6A:  MOVFF  8D,1D2
0C6E:  MOVFF  8C,1D1
0C72:  RCALL  0956
0C74:  MOVLW  20
0C76:  MOVLB  1
0C78:  MOVWF  xDA
0C7A:  MOVLB  0
0C7C:  RCALL  08CE
....................    } 
0C7E:  RETURN 0
.................... } 
....................  
.................... void write_ent() 
.................... { // Graba en eeprom las subidas del poste 
....................    disable_interrupts(GLOBAL); 
*
0CBE:  BCF    FF2.6
0CC0:  BCF    FF2.7
0CC2:  BTFSC  FF2.7
0CC4:  BRA    0CC0
....................    write_ext_eeprom(2, entraront);        // parte baja 
0CC6:  MOVLB  1
0CC8:  CLRF   xD5
0CCA:  MOVLW  02
0CCC:  MOVWF  xD4
0CCE:  MOVFF  8A,1D6
0CD2:  MOVLB  0
0CD4:  RCALL  05C2
....................    write_ext_eeprom(1, (entraront >> 8)); // parte alta 
0CD6:  MOVFF  8B,1D0
0CDA:  MOVLB  1
0CDC:  CLRF   xD1
0CDE:  CLRF   xD5
0CE0:  MOVLW  01
0CE2:  MOVWF  xD4
0CE4:  MOVFF  8B,1D6
0CE8:  MOVLB  0
0CEA:  RCALL  05C2
....................    enable_interrupts(GLOBAL); 
0CEC:  MOVLW  C0
0CEE:  IORWF  FF2,F
....................    finsuma(); 
0CF0:  RCALL  0C80
0CF2:  RETURN 0
.................... } 
....................  
.................... void write_sal() 
.................... { // Graba en eeprom las bajadas del poste 
....................    disable_interrupts(GLOBAL); 
0CF4:  BCF    FF2.6
0CF6:  BCF    FF2.7
0CF8:  BTFSC  FF2.7
0CFA:  BRA    0CF6
....................    write_ext_eeprom(4, salieront);        // parte baja 
0CFC:  MOVLB  1
0CFE:  CLRF   xD5
0D00:  MOVLW  04
0D02:  MOVWF  xD4
0D04:  MOVFF  8C,1D6
0D08:  MOVLB  0
0D0A:  RCALL  05C2
....................    write_ext_eeprom(3, (salieront >> 8)); // parte alta 
0D0C:  MOVFF  8D,1D0
0D10:  MOVLB  1
0D12:  CLRF   xD1
0D14:  CLRF   xD5
0D16:  MOVLW  03
0D18:  MOVWF  xD4
0D1A:  MOVFF  8D,1D6
0D1E:  MOVLB  0
0D20:  RCALL  05C2
....................    enable_interrupts(GLOBAL); 
0D22:  MOVLW  C0
0D24:  IORWF  FF2,F
....................    finsuma(); 
0D26:  RCALL  0C80
0D28:  RETURN 0
.................... } 
....................  
.................... void entraron_total() 
.................... { // Graba en eeprom el total de subidas 
....................    disable_interrupts(GLOBAL); 
*
0D96:  BCF    FF2.6
0D98:  BCF    FF2.7
0D9A:  BTFSC  FF2.7
0D9C:  BRA    0D98
....................    unsigned int reg_h = 0, reg_l = 0; 
....................    unsigned int16 total = 0; 
0D9E:  MOVLB  1
0DA0:  CLRF   xD0
0DA2:  CLRF   xD1
0DA4:  CLRF   xD3
0DA6:  CLRF   xD2
....................  
....................    reg_h = read_ext_eeprom(1); 
0DA8:  CLRF   xD5
0DAA:  MOVLW  01
0DAC:  MOVWF  xD4
0DAE:  MOVLB  0
0DB0:  RCALL  0782
0DB2:  MOVFF  01,1D0
....................    reg_l = read_ext_eeprom(2); 
0DB6:  MOVLB  1
0DB8:  CLRF   xD5
0DBA:  MOVLW  02
0DBC:  MOVWF  xD4
0DBE:  MOVLB  0
0DC0:  RCALL  0782
0DC2:  MOVFF  01,1D1
....................    total = reg_h; 
0DC6:  MOVLB  1
0DC8:  CLRF   xD3
0DCA:  MOVFF  1D0,1D2
....................    total = (total << 8) | reg_l; 
0DCE:  MOVFF  1D2,1D5
0DD2:  CLRF   xD4
0DD4:  MOVF   xD4,W
0DD6:  IORWF  xD1,W
0DD8:  MOVWF  xD2
0DDA:  MOVFF  1D5,1D3
....................    entraront = total; 
0DDE:  MOVFF  1D3,8B
0DE2:  MOVFF  1D2,8A
....................    enable_interrupts(GLOBAL); 
0DE6:  MOVLW  C0
0DE8:  IORWF  FF2,F
0DEA:  MOVLB  0
0DEC:  GOTO   2DB0 (RETURN)
.................... } 
....................  
.................... void salieron_total() 
.................... { // Graba en eeprom el total de bajadas 
....................    disable_interrupts(GLOBAL); 
0DF0:  BCF    FF2.6
0DF2:  BCF    FF2.7
0DF4:  BTFSC  FF2.7
0DF6:  BRA    0DF2
....................    unsigned int reg_h = 0, reg_l = 0; 
....................    unsigned int16 total = 0; 
0DF8:  MOVLB  1
0DFA:  CLRF   xD0
0DFC:  CLRF   xD1
0DFE:  CLRF   xD3
0E00:  CLRF   xD2
....................  
....................    reg_h = read_ext_eeprom(3); 
0E02:  CLRF   xD5
0E04:  MOVLW  03
0E06:  MOVWF  xD4
0E08:  MOVLB  0
0E0A:  RCALL  0782
0E0C:  MOVFF  01,1D0
....................    reg_l = read_ext_eeprom(4); 
0E10:  MOVLB  1
0E12:  CLRF   xD5
0E14:  MOVLW  04
0E16:  MOVWF  xD4
0E18:  MOVLB  0
0E1A:  RCALL  0782
0E1C:  MOVFF  01,1D1
....................    total = reg_h; 
0E20:  MOVLB  1
0E22:  CLRF   xD3
0E24:  MOVFF  1D0,1D2
....................    total = (total << 8) | reg_l; 
0E28:  MOVFF  1D2,1D5
0E2C:  CLRF   xD4
0E2E:  MOVF   xD4,W
0E30:  IORWF  xD1,W
0E32:  MOVWF  xD2
0E34:  MOVFF  1D5,1D3
....................    salieront = total; 
0E38:  MOVFF  1D3,8D
0E3C:  MOVFF  1D2,8C
....................    enable_interrupts(GLOBAL); 
0E40:  MOVLW  C0
0E42:  IORWF  FF2,F
0E44:  MOVLB  0
0E46:  GOTO   2DB4 (RETURN)
.................... } 
....................  
.................... void graba_conta2() 
.................... { // Graba en eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
06C8:  BCF    FF2.6
06CA:  BCF    FF2.7
06CC:  BTFSC  FF2.7
06CE:  BRA    06CA
....................    unsigned int reg_hc = 0, reg_lc = 0; 
....................    unsigned int16 totalc = 0; 
06D0:  MOVLB  1
06D2:  CLRF   xD0
06D4:  CLRF   xD1
06D6:  CLRF   xD3
06D8:  CLRF   xD2
....................    totalc = 0; 
06DA:  CLRF   xD3
06DC:  CLRF   xD2
....................    reg_lc = 0; 
06DE:  CLRF   xD1
....................    reg_hc = 0; 
06E0:  CLRF   xD0
....................  
....................    totalc = salian; 
06E2:  MOVFF  3D,1D3
06E6:  MOVFF  3C,1D2
....................    reg_lc = totalc; 
06EA:  MOVFF  1D2,1D1
....................    reg_hc = totalc >> 8; 
06EE:  MOVFF  1D3,1D0
....................    write_ext_eeprom(20, reg_hc); 
06F2:  CLRF   xD5
06F4:  MOVLW  14
06F6:  MOVWF  xD4
06F8:  MOVFF  1D0,1D6
06FC:  MOVLB  0
06FE:  RCALL  05C2
....................    write_ext_eeprom(21, reg_lc); 
0700:  MOVLB  1
0702:  CLRF   xD5
0704:  MOVLW  15
0706:  MOVWF  xD4
0708:  MOVFF  1D1,1D6
070C:  MOVLB  0
070E:  RCALL  05C2
....................    enable_interrupts(GLOBAL); 
0710:  MOVLW  C0
0712:  IORWF  FF2,F
0714:  RETURN 0
.................... } 
....................  
.................... void leer_conta2() 
.................... { // Carga de eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
082A:  BCF    FF2.6
082C:  BCF    FF2.7
082E:  BTFSC  FF2.7
0830:  BRA    082C
....................    unsigned int reg_hc = 0, reg_lc = 0; 
....................    unsigned int16 totalc = 0; 
0832:  MOVLB  1
0834:  CLRF   xD0
0836:  CLRF   xD1
0838:  CLRF   xD3
083A:  CLRF   xD2
....................  
....................    reg_hc = read_ext_eeprom(20); 
083C:  CLRF   xD5
083E:  MOVLW  14
0840:  MOVWF  xD4
0842:  MOVLB  0
0844:  RCALL  0782
0846:  MOVFF  01,1D0
....................    reg_lc = read_ext_eeprom(21); 
084A:  MOVLB  1
084C:  CLRF   xD5
084E:  MOVLW  15
0850:  MOVWF  xD4
0852:  MOVLB  0
0854:  RCALL  0782
0856:  MOVFF  01,1D1
....................    totalc = reg_hc; 
085A:  MOVLB  1
085C:  CLRF   xD3
085E:  MOVFF  1D0,1D2
....................    totalc = totalc << 8; 
0862:  MOVFF  1D2,1D3
0866:  CLRF   xD2
....................    totalc = totalc | reg_lc; 
0868:  MOVF   xD1,W
086A:  IORWF  xD2,F
....................    salian = totalc; 
086C:  MOVFF  1D3,3D
0870:  MOVFF  1D2,3C
....................    enable_interrupts(GLOBAL); 
0874:  MOVLW  C0
0876:  IORWF  FF2,F
0878:  MOVLB  0
087A:  RETURN 0
.................... } 
....................  
.................... void reset() 
.................... { 
....................    switch (restart_cause()) 
*
0E6C:  MOVF   FD0,W
0E6E:  ANDLW  0F
0E70:  BTFSS  FD0.4
0E72:  MOVLW  00
0E74:  BSF    FD0.0
0E76:  BSF    FD0.1
0E78:  BSF    FD0.4
0E7A:  BSF    FD8.3
0E7C:  BSF    FD8.4
0E7E:  XORLW  07
0E80:  BZ    0E90
0E82:  XORLW  08
0E84:  BZ    0E92
0E86:  XORLW  01
0E88:  BZ    0E9E
0E8A:  XORLW  02
0E8C:  BZ    0EA0
0E8E:  BRA    0EA0
....................    { 
....................    case WDT_TIMEOUT: 
....................    { // lcd_putc("REINICIO-WD");// 
....................       break; 
0E90:  BRA    0EA0
....................    } 
....................    case MCLR_FROM_RUN: // avisa que reinicio por master clear 
....................    { 
....................       fprintf(monitor, "SERIALTEST\r\n"); 
0E92:  MOVLW  FE
0E94:  MOVWF  FF6
0E96:  MOVLW  03
0E98:  MOVWF  FF7
0E9A:  RCALL  0E4A
....................       break; 
0E9C:  BRA    0EA0
....................    } 
....................    case BROWNOUT_RESTART: // avisa que el pic reinicio por un voltaje menor a 4v 
....................    { 
....................       break; 
0E9E:  BRA    0EA0
....................    } 
....................    case NORMAL_POWER_UP: 
....................    { 
....................       break; 
....................    } // END MODO 
....................    } 
0EA0:  GOTO   2E92 (RETURN)
.................... } 
....................  
.................... //// evalua el comando obetenido del serial nato /////////////////// 
.................... int evaluar_string(char *command[]) 
*
0F96:  MOVLB  1
0F98:  CLRF   xD2
.................... { 
....................    int conteo_command = 0; 
....................    int iresult; 
....................    //// recorremos los 11 comandos definidos en textosearxch[] //////// 
....................    while (conteo_command <= 10) 
0F9A:  MOVF   xD2,W
0F9C:  SUBLW  0A
0F9E:  BNC   0FE6
....................    { 
....................       iresult = strcoll(textosearch[conteo_command], command); 
0FA0:  CLRF   03
0FA2:  MOVFF  1D2,02
0FA6:  BCF    FD8.0
0FA8:  RLCF   02,F
0FAA:  RLCF   03,F
0FAC:  MOVF   02,W
0FAE:  ADDLW  F2
0FB0:  MOVWF  FE9
0FB2:  MOVLW  00
0FB4:  ADDWFC 03,W
0FB6:  MOVWF  FEA
0FB8:  MOVFF  FEC,1D5
0FBC:  MOVF   FED,F
0FBE:  MOVFF  FEF,1D4
0FC2:  MOVFF  1D5,1D7
0FC6:  MOVFF  1D4,1D6
0FCA:  MOVFF  1D1,1D9
0FCE:  MOVFF  1D0,1D8
0FD2:  MOVLB  0
0FD4:  BRA    0F1C
0FD6:  MOVFF  01,1D3
....................       //// si se encontr� el comando en la lista entonces deja de buscar // 
....................       if (iresult == 0) 
0FDA:  MOVLB  1
0FDC:  MOVF   xD3,F
0FDE:  BNZ   0FE2
....................       { 
....................          break; 
0FE0:  BRA    0FE6
....................       } 
....................       conteo_command++; 
0FE2:  INCF   xD2,F
0FE4:  BRA    0F9A
....................    } 
....................  
....................    //// si parte del comando es o empieza con "ASAJEROS" entra caso 5 // 
....................    if (XX[1] == 'A' && XX[2] == 'S' && XX[3] == 'A' && XX[4] == 'J' && XX[5] == 'E' && XX[6] == 'R' && XX[7] == 'O' && XX[8] == 'S') 
0FE6:  MOVF   x92,W
0FE8:  SUBLW  41
0FEA:  BNZ   101A
0FEC:  MOVF   x93,W
0FEE:  SUBLW  53
0FF0:  BNZ   101A
0FF2:  MOVF   x94,W
0FF4:  SUBLW  41
0FF6:  BNZ   101A
0FF8:  MOVF   x95,W
0FFA:  SUBLW  4A
0FFC:  BNZ   101A
0FFE:  MOVF   x96,W
1000:  SUBLW  45
1002:  BNZ   101A
1004:  MOVF   x97,W
1006:  SUBLW  52
1008:  BNZ   101A
100A:  MOVF   x98,W
100C:  SUBLW  4F
100E:  BNZ   101A
1010:  MOVF   x99,W
1012:  SUBLW  53
1014:  BNZ   101A
....................    { 
....................       conteo_command = 5; 
1016:  MOVLW  05
1018:  MOVWF  xD2
....................    } 
....................    /// retorna valor de comando para validar /////////////////////////// 
....................    return conteo_command; 
101A:  MOVFF  1D2,01
101E:  MOVLB  0
1020:  GOTO   2FC6 (RETURN)
.................... } 
....................  
.................... void cuenta_pulsos() 
.................... { // Pulsos de subida para impresion (flanco alto) 
....................    output_high(salida03); 
*
18C8:  BCF    F94.5
18CA:  BSF    F8B.5
....................    rev_suben(); 
18CC:  RCALL  18B6
....................    time_s3 = 0; 
18CE:  CLRF   xB2
....................    fls3 = 1; 
18D0:  MOVLW  01
18D2:  MOVWF  xB3
....................    cta_pulsos++; 
18D4:  INCF   xB4,F
18D6:  RETURN 0
.................... } 
....................  
.................... void rev_suben() 
.................... { 
....................    if (!master) 
*
18B6:  MOVF   45,F
18B8:  BNZ   18C6
....................    { 
....................       fprintf(monitor, "SUBIENDOC2"); // 
18BA:  MOVLW  0C
18BC:  MOVWF  FF6
18BE:  MOVLW  04
18C0:  MOVWF  FF7
18C2:  CALL   0E4A
....................    } 
18C6:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 181E   PUT BROWNOUT BORV21 NOWDT WDT4096
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
